{"ast":null,"code":"var __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _dirty, _ownerElement, _handleSlotChange, handleSlotChange_fn, _submenuConnected, submenuConnected_fn, _submenuDisconnected, submenuDisconnected_fn, _handleMenuItem, _handleKeyUp, handleKeyUp_fn, _handleKeyDown, handleKeyDown_fn, _reset, reset_fn;\nimport { globalThis, document } from \"../utils/server-safe-globals.js\";\nimport { InvokeEvent } from \"../utils/events.js\";\nimport { getDocumentOrShadowRoot, containsComposedNode, namedNodeMapToObject } from \"../utils/element-utils.js\";\nfunction getTemplateHTML(_attrs) {\n  return /*html*/`\n    <style>\n      :host {\n        transition: var(--media-menu-item-transition,\n          background .15s linear,\n          opacity .2s ease-in-out\n        );\n        outline: var(--media-menu-item-outline, 0);\n        outline-offset: var(--media-menu-item-outline-offset, -1px);\n        cursor: var(--media-cursor, pointer);\n        display: flex;\n        align-items: center;\n        align-self: stretch;\n        justify-self: stretch;\n        white-space: nowrap;\n        white-space-collapse: collapse;\n        text-wrap: nowrap;\n        padding: .4em .8em .4em 1em;\n      }\n\n      :host(:focus-visible) {\n        box-shadow: var(--media-menu-item-focus-shadow, inset 0 0 0 2px rgb(27 127 204 / .9));\n        outline: var(--media-menu-item-hover-outline, 0);\n        outline-offset: var(--media-menu-item-hover-outline-offset,  var(--media-menu-item-outline-offset, -1px));\n      }\n\n      :host(:hover) {\n        cursor: var(--media-cursor, pointer);\n        background: var(--media-menu-item-hover-background, rgb(92 92 102 / .5));\n        outline: var(--media-menu-item-hover-outline);\n        outline-offset: var(--media-menu-item-hover-outline-offset,  var(--media-menu-item-outline-offset, -1px));\n      }\n\n      :host([aria-checked=\"true\"]) {\n        background: var(--media-menu-item-checked-background);\n      }\n\n      :host([hidden]) {\n        display: none;\n      }\n\n      :host([disabled]) {\n        pointer-events: none;\n        color: rgba(255, 255, 255, .3);\n      }\n\n      slot:not([name]) {\n        width: 100%;\n      }\n\n      slot:not([name=\"submenu\"]) {\n        display: inline-flex;\n        align-items: center;\n        transition: inherit;\n        opacity: var(--media-menu-item-opacity, 1);\n      }\n\n      slot[name=\"description\"] {\n        justify-content: end;\n      }\n\n      slot[name=\"description\"] > span {\n        display: inline-block;\n        margin-inline: 1em .2em;\n        max-width: var(--media-menu-item-description-max-width, 100px);\n        text-overflow: ellipsis;\n        overflow: hidden;\n        font-size: .8em;\n        font-weight: 400;\n        text-align: right;\n        position: relative;\n        top: .04em;\n      }\n\n      slot[name=\"checked-indicator\"] {\n        display: none;\n      }\n\n      :host(:is([role=\"menuitemradio\"],[role=\"menuitemcheckbox\"])) slot[name=\"checked-indicator\"] {\n        display: var(--media-menu-item-checked-indicator-display, inline-block);\n      }\n\n      ${/* For all slotted icons in prefix and suffix. */\n  \"\"}\n      svg, img, ::slotted(svg), ::slotted(img) {\n        height: var(--media-menu-item-icon-height, var(--media-control-height, 24px));\n        fill: var(--media-icon-color, var(--media-primary-color, rgb(238 238 238)));\n        display: block;\n      }\n\n      ${/* Only for indicator icons like checked-indicator or captions-indicator. */\n  \"\"}\n      [part~=\"indicator\"],\n      ::slotted([part~=\"indicator\"]) {\n        fill: var(--media-menu-item-indicator-fill,\n          var(--media-icon-color, var(--media-primary-color, rgb(238 238 238))));\n        height: var(--media-menu-item-indicator-height, 1.25em);\n        margin-right: .5ch;\n      }\n\n      [part~=\"checked-indicator\"] {\n        visibility: hidden;\n      }\n\n      :host([aria-checked=\"true\"]) [part~=\"checked-indicator\"] {\n        visibility: visible;\n      }\n    </style>\n    <slot name=\"checked-indicator\">\n      <svg aria-hidden=\"true\" viewBox=\"0 1 24 24\" part=\"checked-indicator indicator\">\n        <path d=\"m10 15.17 9.193-9.191 1.414 1.414-10.606 10.606-6.364-6.364 1.414-1.414 4.95 4.95Z\"/>\n      </svg>\n    </slot>\n    <slot name=\"prefix\"></slot>\n    <slot></slot>\n    <slot name=\"description\"></slot>\n    <slot name=\"suffix\">\n      ${this.getSuffixSlotInnerHTML(_attrs)}\n    </slot>\n    <slot name=\"submenu\"></slot>\n  `;\n}\nfunction getSuffixSlotInnerHTML(_attrs) {\n  return \"\";\n}\nconst Attributes = {\n  TYPE: \"type\",\n  VALUE: \"value\",\n  CHECKED: \"checked\",\n  DISABLED: \"disabled\"\n};\nclass MediaChromeMenuItem extends globalThis.HTMLElement {\n  constructor() {\n    super();\n    __privateAdd(this, _handleSlotChange);\n    __privateAdd(this, _submenuConnected);\n    __privateAdd(this, _submenuDisconnected);\n    __privateAdd(this, _handleKeyUp);\n    __privateAdd(this, _handleKeyDown);\n    __privateAdd(this, _reset);\n    __privateAdd(this, _dirty, false);\n    __privateAdd(this, _ownerElement, void 0);\n    /**\n     * If there is a slotted submenu the fallback content of the description slot\n     * is populated with the text of the first checked item.\n     */\n    __privateAdd(this, _handleMenuItem, () => {\n      var _a, _b;\n      this.setAttribute(\"submenusize\", `${this.submenuElement.items.length}`);\n      const descriptionSlot = this.shadowRoot.querySelector('slot[name=\"description\"]');\n      const checkedItem = (_a = this.submenuElement.checkedItems) == null ? void 0 : _a[0];\n      const description = (_b = checkedItem == null ? void 0 : checkedItem.dataset.description) != null ? _b : checkedItem == null ? void 0 : checkedItem.text;\n      const span = document.createElement(\"span\");\n      span.textContent = description != null ? description : \"\";\n      descriptionSlot.replaceChildren(span);\n    });\n    if (!this.shadowRoot) {\n      this.attachShadow(this.constructor.shadowRootOptions);\n      const attrs = namedNodeMapToObject(this.attributes);\n      this.shadowRoot.innerHTML = this.constructor.getTemplateHTML(attrs);\n    }\n    this.shadowRoot.addEventListener(\"slotchange\", this);\n  }\n  static get observedAttributes() {\n    return [Attributes.TYPE, Attributes.DISABLED, Attributes.CHECKED, Attributes.VALUE];\n  }\n  enable() {\n    if (!this.hasAttribute(\"tabindex\")) {\n      this.setAttribute(\"tabindex\", \"-1\");\n    }\n    if (isCheckable(this) && !this.hasAttribute(\"aria-checked\")) {\n      this.setAttribute(\"aria-checked\", \"false\");\n    }\n    this.addEventListener(\"click\", this);\n    this.addEventListener(\"keydown\", this);\n  }\n  disable() {\n    this.removeAttribute(\"tabindex\");\n    this.removeEventListener(\"click\", this);\n    this.removeEventListener(\"keydown\", this);\n    this.removeEventListener(\"keyup\", this);\n  }\n  handleEvent(event) {\n    switch (event.type) {\n      case \"slotchange\":\n        __privateMethod(this, _handleSlotChange, handleSlotChange_fn).call(this, event);\n        break;\n      case \"click\":\n        this.handleClick(event);\n        break;\n      case \"keydown\":\n        __privateMethod(this, _handleKeyDown, handleKeyDown_fn).call(this, event);\n        break;\n      case \"keyup\":\n        __privateMethod(this, _handleKeyUp, handleKeyUp_fn).call(this, event);\n        break;\n    }\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName === Attributes.CHECKED && isCheckable(this) && !__privateGet(this, _dirty)) {\n      this.setAttribute(\"aria-checked\", newValue != null ? \"true\" : \"false\");\n    } else if (attrName === Attributes.TYPE && newValue !== oldValue) {\n      this.role = \"menuitem\" + newValue;\n    } else if (attrName === Attributes.DISABLED && newValue !== oldValue) {\n      if (newValue == null) {\n        this.enable();\n      } else {\n        this.disable();\n      }\n    }\n  }\n  connectedCallback() {\n    if (!this.hasAttribute(Attributes.DISABLED)) {\n      this.enable();\n    }\n    this.role = \"menuitem\" + this.type;\n    __privateSet(this, _ownerElement, closestMenuItemsContainer(this, this.parentNode));\n    __privateMethod(this, _reset, reset_fn).call(this);\n  }\n  disconnectedCallback() {\n    this.disable();\n    __privateMethod(this, _reset, reset_fn).call(this);\n    __privateSet(this, _ownerElement, null);\n  }\n  get invokeTarget() {\n    return this.getAttribute(\"invoketarget\");\n  }\n  set invokeTarget(value) {\n    this.setAttribute(\"invoketarget\", `${value}`);\n  }\n  /**\n   * Returns the element with the id specified by the `invoketarget` attribute\n   * or the slotted submenu element.\n   */\n  get invokeTargetElement() {\n    var _a;\n    if (this.invokeTarget) {\n      return (_a = getDocumentOrShadowRoot(this)) == null ? void 0 : _a.querySelector(`#${this.invokeTarget}`);\n    }\n    return this.submenuElement;\n  }\n  /**\n   * Returns the slotted submenu element.\n   */\n  get submenuElement() {\n    const submenuSlot = this.shadowRoot.querySelector('slot[name=\"submenu\"]');\n    return submenuSlot.assignedElements({\n      flatten: true\n    })[0];\n  }\n  get type() {\n    var _a;\n    return (_a = this.getAttribute(Attributes.TYPE)) != null ? _a : \"\";\n  }\n  set type(val) {\n    this.setAttribute(Attributes.TYPE, `${val}`);\n  }\n  get value() {\n    var _a;\n    return (_a = this.getAttribute(Attributes.VALUE)) != null ? _a : this.text;\n  }\n  set value(val) {\n    this.setAttribute(Attributes.VALUE, val);\n  }\n  get text() {\n    var _a;\n    return ((_a = this.textContent) != null ? _a : \"\").trim();\n  }\n  get checked() {\n    if (!isCheckable(this)) return void 0;\n    return this.getAttribute(\"aria-checked\") === \"true\";\n  }\n  set checked(value) {\n    if (!isCheckable(this)) return;\n    __privateSet(this, _dirty, true);\n    this.setAttribute(\"aria-checked\", value ? \"true\" : \"false\");\n    if (value) {\n      this.part.add(\"checked\");\n    } else {\n      this.part.remove(\"checked\");\n    }\n  }\n  handleClick(event) {\n    if (isCheckable(this)) return;\n    if (this.invokeTargetElement && containsComposedNode(this, event.target)) {\n      this.invokeTargetElement.dispatchEvent(new InvokeEvent({\n        relatedTarget: this\n      }));\n    }\n  }\n  get keysUsed() {\n    return [\"Enter\", \" \"];\n  }\n}\n_dirty = new WeakMap();\n_ownerElement = new WeakMap();\n_handleSlotChange = new WeakSet();\nhandleSlotChange_fn = function (event) {\n  const slot = event.target;\n  const isDefaultSlot = !(slot == null ? void 0 : slot.name);\n  if (isDefaultSlot) {\n    for (const node of slot.assignedNodes({\n      flatten: true\n    })) {\n      if (node instanceof Text && node.textContent.trim() === \"\") {\n        node.remove();\n      }\n    }\n  }\n  if (slot.name === \"submenu\") {\n    if (this.submenuElement) {\n      __privateMethod(this, _submenuConnected, submenuConnected_fn).call(this);\n    } else {\n      __privateMethod(this, _submenuDisconnected, submenuDisconnected_fn).call(this);\n    }\n  }\n};\n_submenuConnected = new WeakSet();\nsubmenuConnected_fn = async function () {\n  this.setAttribute(\"aria-haspopup\", \"menu\");\n  this.setAttribute(\"aria-expanded\", `${!this.submenuElement.hidden}`);\n  this.submenuElement.addEventListener(\"change\", __privateGet(this, _handleMenuItem));\n  this.submenuElement.addEventListener(\"addmenuitem\", __privateGet(this, _handleMenuItem));\n  this.submenuElement.addEventListener(\"removemenuitem\", __privateGet(this, _handleMenuItem));\n  __privateGet(this, _handleMenuItem).call(this);\n};\n_submenuDisconnected = new WeakSet();\nsubmenuDisconnected_fn = function () {\n  this.removeAttribute(\"aria-haspopup\");\n  this.removeAttribute(\"aria-expanded\");\n  this.submenuElement.removeEventListener(\"change\", __privateGet(this, _handleMenuItem));\n  this.submenuElement.removeEventListener(\"addmenuitem\", __privateGet(this, _handleMenuItem));\n  this.submenuElement.removeEventListener(\"removemenuitem\", __privateGet(this, _handleMenuItem));\n  __privateGet(this, _handleMenuItem).call(this);\n};\n_handleMenuItem = new WeakMap();\n_handleKeyUp = new WeakSet();\nhandleKeyUp_fn = function (event) {\n  const {\n    key\n  } = event;\n  if (!this.keysUsed.includes(key)) {\n    this.removeEventListener(\"keyup\", __privateMethod(this, _handleKeyUp, handleKeyUp_fn));\n    return;\n  }\n  this.handleClick(event);\n};\n_handleKeyDown = new WeakSet();\nhandleKeyDown_fn = function (event) {\n  const {\n    metaKey,\n    altKey,\n    key\n  } = event;\n  if (metaKey || altKey || !this.keysUsed.includes(key)) {\n    this.removeEventListener(\"keyup\", __privateMethod(this, _handleKeyUp, handleKeyUp_fn));\n    return;\n  }\n  this.addEventListener(\"keyup\", __privateMethod(this, _handleKeyUp, handleKeyUp_fn), {\n    once: true\n  });\n};\n_reset = new WeakSet();\nreset_fn = function () {\n  var _a;\n  const items = (_a = __privateGet(this, _ownerElement)) == null ? void 0 : _a.radioGroupItems;\n  if (!items) return;\n  let checkedItem = items.filter(item => item.getAttribute(\"aria-checked\") === \"true\").pop();\n  if (!checkedItem) checkedItem = items[0];\n  for (const item of items) {\n    item.setAttribute(\"aria-checked\", \"false\");\n  }\n  checkedItem == null ? void 0 : checkedItem.setAttribute(\"aria-checked\", \"true\");\n};\nMediaChromeMenuItem.shadowRootOptions = {\n  mode: \"open\"\n};\nMediaChromeMenuItem.getTemplateHTML = getTemplateHTML;\nMediaChromeMenuItem.getSuffixSlotInnerHTML = getSuffixSlotInnerHTML;\nfunction isCheckable(item) {\n  return item.type === \"radio\" || item.type === \"checkbox\";\n}\nfunction closestMenuItemsContainer(childNode, parentNode) {\n  if (!childNode) return null;\n  const {\n    host\n  } = childNode.getRootNode();\n  if (!parentNode && host) return closestMenuItemsContainer(childNode, host);\n  if (parentNode == null ? void 0 : parentNode.items) return parentNode;\n  return closestMenuItemsContainer(parentNode, parentNode == null ? void 0 : parentNode.parentNode);\n}\nif (!globalThis.customElements.get(\"media-chrome-menu-item\")) {\n  globalThis.customElements.define(\"media-chrome-menu-item\", MediaChromeMenuItem);\n}\nvar media_chrome_menu_item_default = MediaChromeMenuItem;\nexport { Attributes, MediaChromeMenuItem, media_chrome_menu_item_default as default };","map":null,"metadata":{},"sourceType":"module"}