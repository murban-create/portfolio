{"ast":null,"code":"import { TextTrackKinds, TextTrackModes } from \"../constants.js\";\nimport { getTextTracksList, updateTracksModeTo } from \"../utils/captions.js\";\nconst getSubtitleTracks = stateOwners => {\n  return getTextTracksList(stateOwners.media, textTrack => {\n    return [TextTrackKinds.SUBTITLES, TextTrackKinds.CAPTIONS].includes(textTrack.kind);\n  }).sort((a, b) => a.kind >= b.kind ? 1 : -1);\n};\nconst getShowingSubtitleTracks = stateOwners => {\n  return getTextTracksList(stateOwners.media, textTrack => {\n    return textTrack.mode === TextTrackModes.SHOWING && [TextTrackKinds.SUBTITLES, TextTrackKinds.CAPTIONS].includes(textTrack.kind);\n  });\n};\nconst toggleSubtitleTracks = (stateOwners, force) => {\n  const tracks = getSubtitleTracks(stateOwners);\n  const showingSubitleTracks = getShowingSubtitleTracks(stateOwners);\n  const subtitlesShowing = !!showingSubitleTracks.length;\n  if (!tracks.length) return;\n  if (force === false || subtitlesShowing && force !== true) {\n    updateTracksModeTo(TextTrackModes.DISABLED, tracks, showingSubitleTracks);\n  } else if (force === true || !subtitlesShowing && force !== false) {\n    let subTrack = tracks[0];\n    const {\n      options\n    } = stateOwners;\n    if (!(options == null ? void 0 : options.noSubtitlesLangPref)) {\n      const subtitlesPref = globalThis.localStorage.getItem(\"media-chrome-pref-subtitles-lang\");\n      const userLangPrefs = subtitlesPref ? [subtitlesPref, ...globalThis.navigator.languages] : globalThis.navigator.languages;\n      const preferredAvailableSubs = tracks.filter(textTrack => {\n        return userLangPrefs.some(lang => textTrack.language.toLowerCase().startsWith(lang.split(\"-\")[0]));\n      }).sort((textTrackA, textTrackB) => {\n        const idxA = userLangPrefs.findIndex(lang => textTrackA.language.toLowerCase().startsWith(lang.split(\"-\")[0]));\n        const idxB = userLangPrefs.findIndex(lang => textTrackB.language.toLowerCase().startsWith(lang.split(\"-\")[0]));\n        return idxA - idxB;\n      });\n      if (preferredAvailableSubs[0]) {\n        subTrack = preferredAvailableSubs[0];\n      }\n    }\n    const {\n      language,\n      label,\n      kind\n    } = subTrack;\n    updateTracksModeTo(TextTrackModes.DISABLED, tracks, showingSubitleTracks);\n    updateTracksModeTo(TextTrackModes.SHOWING, tracks, [{\n      language,\n      label,\n      kind\n    }]);\n  }\n};\nconst areValuesEq = (x, y) => {\n  if (x === y) return true;\n  if (x == null || y == null) return false;\n  if (typeof x !== typeof y) return false;\n  if (typeof x === \"number\" && Number.isNaN(x) && Number.isNaN(y)) return true;\n  if (typeof x !== \"object\") return false;\n  if (Array.isArray(x)) return areArraysEq(x, y);\n  return Object.entries(x).every(\n  // NOTE: Checking key in y to disambiguate between between missing keys and keys whose value are undefined (CJP)\n  _ref => {\n    let [key, value] = _ref;\n    return key in y && areValuesEq(value, y[key]);\n  });\n};\nconst areArraysEq = (xs, ys) => {\n  const xIsArray = Array.isArray(xs);\n  const yIsArray = Array.isArray(ys);\n  if (xIsArray !== yIsArray) return false;\n  if (!(xIsArray || yIsArray)) return true;\n  if (xs.length !== ys.length) return false;\n  return xs.every((x, i) => areValuesEq(x, ys[i]));\n};\nexport { areArraysEq, areValuesEq, getShowingSubtitleTracks, getSubtitleTracks, toggleSubtitleTracks };","map":null,"metadata":{},"sourceType":"module"}