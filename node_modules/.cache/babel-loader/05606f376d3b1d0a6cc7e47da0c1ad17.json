{"ast":null,"code":"/* global chrome, cast */\nimport { privateProps, IterableWeakSet, InvalidStateError, NotSupportedError, onCastApiAvailable, castContext, currentSession, currentMedia, editTracksInfo, getMediaStatus, setCastOptions } from './castable-utils.js';\nconst remoteInstances = new IterableWeakSet();\nconst castElementRef = new WeakSet();\nlet cf;\nonCastApiAvailable(() => {\n  var _globalThis$chrome, _globalThis$chrome$ca;\n  if (!((_globalThis$chrome = globalThis.chrome) !== null && _globalThis$chrome !== void 0 && (_globalThis$chrome$ca = _globalThis$chrome.cast) !== null && _globalThis$chrome$ca !== void 0 && _globalThis$chrome$ca.isAvailable)) {\n    var _globalThis$chrome2, _globalThis$chrome2$c;\n    // Useful to see in verbose logs if this shows undefined or false.\n    console.debug('chrome.cast.isAvailable', (_globalThis$chrome2 = globalThis.chrome) === null || _globalThis$chrome2 === void 0 ? void 0 : (_globalThis$chrome2$c = _globalThis$chrome2.cast) === null || _globalThis$chrome2$c === void 0 ? void 0 : _globalThis$chrome2$c.isAvailable);\n    return;\n  }\n  if (!cf) {\n    cf = cast.framework;\n    castContext().addEventListener(cf.CastContextEventType.CAST_STATE_CHANGED, e => {\n      remoteInstances.forEach(r => {\n        var _privateProps$get$onC, _privateProps$get;\n        return (_privateProps$get$onC = (_privateProps$get = privateProps.get(r)).onCastStateChanged) === null || _privateProps$get$onC === void 0 ? void 0 : _privateProps$get$onC.call(_privateProps$get, e);\n      });\n    });\n    castContext().addEventListener(cf.CastContextEventType.SESSION_STATE_CHANGED, e => {\n      remoteInstances.forEach(r => {\n        var _privateProps$get$onS, _privateProps$get2;\n        return (_privateProps$get$onS = (_privateProps$get2 = privateProps.get(r)).onSessionStateChanged) === null || _privateProps$get$onS === void 0 ? void 0 : _privateProps$get$onS.call(_privateProps$get2, e);\n      });\n    });\n    remoteInstances.forEach(r => {\n      var _privateProps$get$ini, _privateProps$get3;\n      return (_privateProps$get$ini = (_privateProps$get3 = privateProps.get(r)).init) === null || _privateProps$get$ini === void 0 ? void 0 : _privateProps$get$ini.call(_privateProps$get3);\n    });\n  }\n});\nlet remotePlaybackCallbackIdCount = 0;\n\n/**\n * Remote Playback shim for the Google cast SDK.\n * https://w3c.github.io/remote-playback/\n */\nexport class RemotePlayback extends EventTarget {\n  #media;\n  #isInit;\n  #remotePlayer;\n  #remoteListeners;\n  #state = 'disconnected';\n  #available = false;\n  #callbacks = new Set();\n  #callbackIds = new WeakMap();\n  constructor(media) {\n    super();\n    this.#media = media;\n    remoteInstances.add(this);\n    privateProps.set(this, {\n      init: () => this.#init(),\n      onCastStateChanged: () => this.#onCastStateChanged(),\n      onSessionStateChanged: () => this.#onSessionStateChanged(),\n      getCastPlayer: () => this.#castPlayer\n    });\n    this.#init();\n  }\n  get #castPlayer() {\n    if (castElementRef.has(this.#media)) return this.#remotePlayer;\n    return undefined;\n  }\n\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/RemotePlayback/state\n   * @return {'disconnected'|'connecting'|'connected'}\n   */\n  get state() {\n    return this.#state;\n  }\n  async watchAvailability(callback) {\n    if (this.#media.disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n    this.#callbackIds.set(callback, ++remotePlaybackCallbackIdCount);\n    this.#callbacks.add(callback);\n\n    // https://w3c.github.io/remote-playback/#getting-the-remote-playback-devices-availability-information\n    queueMicrotask(() => callback(this.#hasDevicesAvailable()));\n    return remotePlaybackCallbackIdCount;\n  }\n  async cancelWatchAvailability(callback) {\n    if (this.#media.disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n    if (callback) {\n      this.#callbacks.delete(callback);\n    } else {\n      this.#callbacks.clear();\n    }\n  }\n  async prompt() {\n    var _globalThis$chrome3, _globalThis$chrome3$c, _privateProps$get4, _privateProps$get4$lo;\n    if (this.#media.disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n    if (!((_globalThis$chrome3 = globalThis.chrome) !== null && _globalThis$chrome3 !== void 0 && (_globalThis$chrome3$c = _globalThis$chrome3.cast) !== null && _globalThis$chrome3$c !== void 0 && _globalThis$chrome3$c.isAvailable)) {\n      throw new NotSupportedError('The RemotePlayback API is disabled on this platform.');\n    }\n    const willDisconnect = castElementRef.has(this.#media);\n    castElementRef.add(this.#media);\n    setCastOptions(this.#media.castOptions);\n    Object.entries(this.#remoteListeners).forEach(_ref => {\n      let [event, listener] = _ref;\n      this.#remotePlayer.controller.addEventListener(event, listener);\n    });\n    try {\n      // Open browser cast menu.\n      await castContext().requestSession();\n    } catch (err) {\n      // If there will be no disconnect, reset some state here.\n      if (!willDisconnect) {\n        castElementRef.delete(this.#media);\n      }\n\n      // Don't throw an error if disconnecting or cancelling.\n      if (err === 'cancel') {\n        return;\n      }\n      throw new Error(err);\n    }\n    (_privateProps$get4 = privateProps.get(this.#media)) === null || _privateProps$get4 === void 0 ? void 0 : (_privateProps$get4$lo = _privateProps$get4.loadOnPrompt) === null || _privateProps$get4$lo === void 0 ? void 0 : _privateProps$get4$lo.call(_privateProps$get4);\n  }\n  #disconnect() {\n    if (!castElementRef.has(this.#media)) return;\n    Object.entries(this.#remoteListeners).forEach(_ref2 => {\n      let [event, listener] = _ref2;\n      this.#remotePlayer.controller.removeEventListener(event, listener);\n    });\n    castElementRef.delete(this.#media);\n\n    // isMuted is not in savedPlayerState. should we sync this back to local?\n    this.#media.muted = this.#remotePlayer.isMuted;\n    this.#media.currentTime = this.#remotePlayer.savedPlayerState.currentTime;\n    if (this.#remotePlayer.savedPlayerState.isPaused === false) {\n      this.#media.play();\n    }\n  }\n  #hasDevicesAvailable() {\n    var _castContext;\n    // Cast state: NO_DEVICES_AVAILABLE, NOT_CONNECTED, CONNECTING, CONNECTED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.CastState\n    const castState = (_castContext = castContext()) === null || _castContext === void 0 ? void 0 : _castContext.getCastState();\n    return castState && castState !== 'NO_DEVICES_AVAILABLE';\n  }\n  #onCastStateChanged() {\n    // Cast state: NO_DEVICES_AVAILABLE, NOT_CONNECTED, CONNECTING, CONNECTED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.CastState\n    const castState = castContext().getCastState();\n    if (castElementRef.has(this.#media)) {\n      if (castState === 'CONNECTING') {\n        this.#state = 'connecting';\n        this.dispatchEvent(new Event('connecting'));\n      }\n    }\n    if (!this.#available && castState !== null && castState !== void 0 && castState.includes('CONNECT')) {\n      this.#available = true;\n      for (let callback of this.#callbacks) callback(true);\n    } else if (this.#available && (!castState || castState === 'NO_DEVICES_AVAILABLE')) {\n      this.#available = false;\n      for (let callback of this.#callbacks) callback(false);\n    }\n  }\n  async #onSessionStateChanged() {\n    // Session states: NO_SESSION, SESSION_STARTING, SESSION_STARTED, SESSION_START_FAILED,\n    //                 SESSION_ENDING, SESSION_ENDED, SESSION_RESUMED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.SessionState\n\n    const {\n      SESSION_RESUMED\n    } = cf.SessionState;\n    if (castContext().getSessionState() === SESSION_RESUMED) {\n      var _currentMedia;\n      /**\n       * Figure out if this was the video that started the resumed session.\n       * @TODO make this more specific than just checking against the video src!! (WL)\n       *\n       * If this video element can get the same unique id on each browser refresh\n       * it would be possible to pass this unique id w/ `LoadRequest.customData`\n       * and verify against currentMedia().customData below.\n       */\n      if (this.#media.castSrc === ((_currentMedia = currentMedia()) === null || _currentMedia === void 0 ? void 0 : _currentMedia.media.contentId)) {\n        castElementRef.add(this.#media);\n        Object.entries(this.#remoteListeners).forEach(_ref3 => {\n          let [event, listener] = _ref3;\n          this.#remotePlayer.controller.addEventListener(event, listener);\n        });\n\n        /**\n         * There is cast framework resume session bug when you refresh the page a few\n         * times the this.#remotePlayer.currentTime will not be in sync with the receiver :(\n         * The below status request syncs it back up.\n         */\n        try {\n          await getMediaStatus(new chrome.cast.media.GetStatusRequest());\n        } catch (error) {\n          console.error(error);\n        }\n\n        // Dispatch the play, playing events manually to sync remote playing state.\n        this.#remoteListeners[cf.RemotePlayerEventType.IS_PAUSED_CHANGED]();\n        this.#remoteListeners[cf.RemotePlayerEventType.PLAYER_STATE_CHANGED]();\n      }\n    }\n  }\n  #init() {\n    if (!cf || this.#isInit) return;\n    this.#isInit = true;\n    setCastOptions(this.#media.castOptions);\n\n    /**\n     * @TODO add listeners for addtrack, removetrack (WL)\n     * This only has an impact on <track> with a `src` because these have to be\n     * loaded manually in the load() method. This will require a new load() call\n     * for each added/removed track w/ src.\n     */\n    this.#media.textTracks.addEventListener('change', () => this.#updateRemoteTextTrack());\n    this.#onCastStateChanged();\n    this.#remotePlayer = new cf.RemotePlayer();\n    new cf.RemotePlayerController(this.#remotePlayer);\n    this.#remoteListeners = {\n      [cf.RemotePlayerEventType.IS_CONNECTED_CHANGED]: _ref4 => {\n        let {\n          value\n        } = _ref4;\n        if (value === true) {\n          this.#state = 'connected';\n          this.dispatchEvent(new Event('connect'));\n        } else {\n          this.#disconnect();\n          this.#state = 'disconnected';\n          this.dispatchEvent(new Event('disconnect'));\n        }\n      },\n      [cf.RemotePlayerEventType.DURATION_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('durationchange'));\n      },\n      [cf.RemotePlayerEventType.VOLUME_LEVEL_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('volumechange'));\n      },\n      [cf.RemotePlayerEventType.IS_MUTED_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('volumechange'));\n      },\n      [cf.RemotePlayerEventType.CURRENT_TIME_CHANGED]: () => {\n        var _this$castPlayer;\n        if (!((_this$castPlayer = this.#castPlayer) !== null && _this$castPlayer !== void 0 && _this$castPlayer.isMediaLoaded)) return;\n        this.#media.dispatchEvent(new Event('timeupdate'));\n      },\n      [cf.RemotePlayerEventType.VIDEO_INFO_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('resize'));\n      },\n      [cf.RemotePlayerEventType.IS_PAUSED_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event(this.paused ? 'pause' : 'play'));\n      },\n      [cf.RemotePlayerEventType.PLAYER_STATE_CHANGED]: () => {\n        var _this$castPlayer2, _this$castPlayer3;\n        // Player states: IDLE, PLAYING, PAUSED, BUFFERING\n        // https://developers.google.com/cast/docs/reference/web_sender/chrome.cast.media#.PlayerState\n\n        // pause event is handled above.\n        if (((_this$castPlayer2 = this.#castPlayer) === null || _this$castPlayer2 === void 0 ? void 0 : _this$castPlayer2.playerState) === chrome.cast.media.PlayerState.PAUSED) {\n          return;\n        }\n        this.#media.dispatchEvent(new Event({\n          [chrome.cast.media.PlayerState.PLAYING]: 'playing',\n          [chrome.cast.media.PlayerState.BUFFERING]: 'waiting',\n          [chrome.cast.media.PlayerState.IDLE]: 'emptied'\n        }[(_this$castPlayer3 = this.#castPlayer) === null || _this$castPlayer3 === void 0 ? void 0 : _this$castPlayer3.playerState]));\n      },\n      [cf.RemotePlayerEventType.IS_MEDIA_LOADED_CHANGED]: async () => {\n        var _this$castPlayer4;\n        if (!((_this$castPlayer4 = this.#castPlayer) !== null && _this$castPlayer4 !== void 0 && _this$castPlayer4.isMediaLoaded)) return;\n\n        // mediaInfo is not immediately available due to a bug? wait one tick\n        await Promise.resolve();\n        this.#onRemoteMediaLoaded();\n      }\n    };\n  }\n  #onRemoteMediaLoaded() {\n    this.#updateRemoteTextTrack();\n  }\n  async #updateRemoteTextTrack() {\n    var _this$remotePlayer$me, _currentSession, _currentSession$getSe;\n    if (!this.#castPlayer) return;\n\n    // Get the tracks w/ trackId's that have been loaded; manually or via a playlist like a M3U8 or MPD.\n    const remoteTracks = ((_this$remotePlayer$me = this.#remotePlayer.mediaInfo) === null || _this$remotePlayer$me === void 0 ? void 0 : _this$remotePlayer$me.tracks) ?? [];\n    const remoteSubtitles = remoteTracks.filter(_ref5 => {\n      let {\n        type\n      } = _ref5;\n      return type === chrome.cast.media.TrackType.TEXT;\n    });\n    const localSubtitles = [...this.#media.textTracks].filter(_ref6 => {\n      let {\n        kind\n      } = _ref6;\n      return kind === 'subtitles' || kind === 'captions';\n    });\n\n    // Create a new array from the local subs w/ the trackId's from the remote subs.\n    const subtitles = remoteSubtitles.map(_ref7 => {\n      let {\n        language,\n        name,\n        trackId\n      } = _ref7;\n      // Find the corresponding local text track and assign the trackId.\n      const {\n        mode\n      } = localSubtitles.find(local => local.language === language && local.label === name) ?? {};\n      if (mode) return {\n        mode,\n        trackId\n      };\n      return false;\n    }).filter(Boolean);\n    const hiddenSubtitles = subtitles.filter(_ref8 => {\n      let {\n        mode\n      } = _ref8;\n      return mode !== 'showing';\n    });\n    const hiddenTrackIds = hiddenSubtitles.map(_ref9 => {\n      let {\n        trackId\n      } = _ref9;\n      return trackId;\n    });\n    const showingSubtitle = subtitles.find(_ref10 => {\n      let {\n        mode\n      } = _ref10;\n      return mode === 'showing';\n    });\n\n    // Note this could also include audio or video tracks, diff against local state.\n    const activeTrackIds = ((_currentSession = currentSession()) === null || _currentSession === void 0 ? void 0 : (_currentSession$getSe = _currentSession.getSessionObj().media[0]) === null || _currentSession$getSe === void 0 ? void 0 : _currentSession$getSe.activeTrackIds) ?? [];\n    let requestTrackIds = activeTrackIds;\n    if (activeTrackIds.length) {\n      // Filter out all local hidden subtitle trackId's.\n      requestTrackIds = requestTrackIds.filter(id => !hiddenTrackIds.includes(id));\n    }\n    if (showingSubtitle !== null && showingSubtitle !== void 0 && showingSubtitle.trackId) {\n      requestTrackIds = [...requestTrackIds, showingSubtitle.trackId];\n    }\n\n    // Remove duplicate ids.\n    requestTrackIds = [...new Set(requestTrackIds)];\n    const arrayEquals = (a, b) => a.length === b.length && a.every(a => b.includes(a));\n    if (!arrayEquals(activeTrackIds, requestTrackIds)) {\n      try {\n        const request = new chrome.cast.media.EditTracksInfoRequest(requestTrackIds);\n        await editTracksInfo(request);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}