{"ast":null,"code":"import { document, globalThis } from \"../utils/server-safe-globals.js\";\nimport { AvailabilityStates, StreamTypes, TextTrackKinds } from \"../constants.js\";\nimport { containsComposedNode } from \"../utils/element-utils.js\";\nimport { enterFullscreen, exitFullscreen, isFullscreen } from \"../utils/fullscreen-api.js\";\nimport { airplaySupported, castSupported, fullscreenSupported, hasFullscreenSupport, hasPipSupport, hasVolumeSupportAsync, pipSupported } from \"../utils/platform-tests.js\";\nimport { getShowingSubtitleTracks, getSubtitleTracks, toggleSubtitleTracks } from \"./util.js\";\nimport { getTextTracksList } from \"../utils/captions.js\";\nimport { isValidNumber } from \"../utils/utils.js\";\nconst StreamTypeValues = Object.values(StreamTypes);\nlet volumeSupported;\nconst volumeSupportPromise = hasVolumeSupportAsync().then(supported => {\n  volumeSupported = supported;\n  return volumeSupported;\n});\nconst prepareStateOwners = async function () {\n  for (var _len = arguments.length, stateOwners = new Array(_len), _key = 0; _key < _len; _key++) {\n    stateOwners[_key] = arguments[_key];\n  }\n  await Promise.all(stateOwners.filter(x => x).map(async stateOwner => {\n    if (!(\"localName\" in stateOwner && stateOwner instanceof globalThis.HTMLElement)) {\n      return;\n    }\n    const name = stateOwner.localName;\n    if (!name.includes(\"-\")) return;\n    const classDef = globalThis.customElements.get(name);\n    if (classDef && stateOwner instanceof classDef) return;\n    await globalThis.customElements.whenDefined(name);\n    globalThis.customElements.upgrade(stateOwner);\n  }));\n};\nconst domParser = new globalThis.DOMParser();\nconst parseHtmlToText = text => text ? domParser.parseFromString(text, \"text/html\").body.textContent || text : text;\nconst stateMediator = {\n  mediaError: {\n    get(stateOwners, event) {\n      const {\n        media\n      } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\") return;\n      return media == null ? void 0 : media.error;\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaErrorCode: {\n    get(stateOwners, event) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\") return;\n      return (_a = media == null ? void 0 : media.error) == null ? void 0 : _a.code;\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaErrorMessage: {\n    get(stateOwners, event) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\") return;\n      return (_b = (_a = media == null ? void 0 : media.error) == null ? void 0 : _a.message) != null ? _b : \"\";\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaWidth: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.videoWidth) != null ? _a : 0;\n    },\n    mediaEvents: [\"resize\"]\n  },\n  mediaHeight: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.videoHeight) != null ? _a : 0;\n    },\n    mediaEvents: [\"resize\"]\n  },\n  mediaPaused: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.paused) != null ? _a : true;\n    },\n    set(value, stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (value) {\n        media.pause();\n      } else {\n        (_a = media.play()) == null ? void 0 : _a.catch(() => {});\n      }\n    },\n    mediaEvents: [\"play\", \"playing\", \"pause\", \"emptied\"]\n  },\n  mediaHasPlayed: {\n    // We want to let the user know that the media started playing at any point (`media-has-played`).\n    // Since these propagators are all called when boostrapping state, let's verify this is\n    // a real playing event by checking that 1) there's media and 2) it isn't currently paused.\n    get(stateOwners, event) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return false;\n      if (!event) return !media.paused;\n      return event.type === \"playing\";\n    },\n    mediaEvents: [\"playing\", \"emptied\"]\n  },\n  mediaEnded: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.ended) != null ? _a : false;\n    },\n    mediaEvents: [\"seeked\", \"ended\", \"emptied\"]\n  },\n  mediaPlaybackRate: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.playbackRate) != null ? _a : 1;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (!Number.isFinite(+value)) return;\n      media.playbackRate = +value;\n    },\n    mediaEvents: [\"ratechange\", \"loadstart\"]\n  },\n  mediaMuted: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.muted) != null ? _a : false;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      try {\n        globalThis.localStorage.setItem(\"media-chrome-pref-muted\", value ? \"true\" : \"false\");\n      } catch (e) {\n        console.debug(\"Error setting muted pref\", e);\n      }\n      media.muted = value;\n    },\n    mediaEvents: [\"volumechange\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      const {\n        options: {\n          noMutedPref\n        }\n      } = stateOwners;\n      const {\n        media\n      } = stateOwners;\n      if (!media || media.muted || noMutedPref) return;\n      try {\n        const mutedPref = globalThis.localStorage.getItem(\"media-chrome-pref-muted\") === \"true\";\n        stateMediator.mediaMuted.set(mutedPref, stateOwners);\n        handler(mutedPref);\n      } catch (e) {\n        console.debug(\"Error getting muted pref\", e);\n      }\n    }]\n  },\n  mediaVolume: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.volume) != null ? _a : 1;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      try {\n        if (value == null) {\n          globalThis.localStorage.removeItem(\"media-chrome-pref-volume\");\n        } else {\n          globalThis.localStorage.setItem(\"media-chrome-pref-volume\", value.toString());\n        }\n      } catch (e) {\n        console.debug(\"Error setting volume pref\", e);\n      }\n      if (!Number.isFinite(+value)) return;\n      media.volume = +value;\n    },\n    mediaEvents: [\"volumechange\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      const {\n        options: {\n          noVolumePref\n        }\n      } = stateOwners;\n      if (noVolumePref) return;\n      try {\n        const {\n          media\n        } = stateOwners;\n        if (!media) return;\n        const volumePref = globalThis.localStorage.getItem(\"media-chrome-pref-volume\");\n        if (volumePref == null) return;\n        stateMediator.mediaVolume.set(+volumePref, stateOwners);\n        handler(+volumePref);\n      } catch (e) {\n        console.debug(\"Error getting volume pref\", e);\n      }\n    }]\n  },\n  // NOTE: Keeping this roughly equivalent to prior impl to reduce number of changes,\n  // however we may want to model \"derived\" state differently from \"primary\" state\n  // (in this case, derived === mediaVolumeLevel, primary === mediaMuted, mediaVolume) (CJP)\n  mediaVolumeLevel: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (typeof (media == null ? void 0 : media.volume) == \"undefined\") return \"high\";\n      if (media.muted || media.volume === 0) return \"off\";\n      if (media.volume < 0.5) return \"low\";\n      if (media.volume < 0.75) return \"medium\";\n      return \"high\";\n    },\n    mediaEvents: [\"volumechange\"]\n  },\n  mediaCurrentTime: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.currentTime) != null ? _a : 0;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media || !isValidNumber(value)) return;\n      media.currentTime = value;\n    },\n    mediaEvents: [\"timeupdate\", \"loadedmetadata\"]\n  },\n  mediaDuration: {\n    get(stateOwners) {\n      const {\n        media,\n        options: {\n          defaultDuration\n        } = {}\n      } = stateOwners;\n      if (defaultDuration && (!media || !media.duration || Number.isNaN(media.duration) || !Number.isFinite(media.duration))) {\n        return defaultDuration;\n      }\n      return Number.isFinite(media == null ? void 0 : media.duration) ? media.duration : Number.NaN;\n    },\n    mediaEvents: [\"durationchange\", \"loadedmetadata\", \"emptied\"]\n  },\n  mediaLoading: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      return (media == null ? void 0 : media.readyState) < 3;\n    },\n    mediaEvents: [\"waiting\", \"playing\", \"emptied\"]\n  },\n  mediaSeekable: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!((_a = media == null ? void 0 : media.seekable) == null ? void 0 : _a.length)) return void 0;\n      const start = media.seekable.start(0);\n      const end = media.seekable.end(media.seekable.length - 1);\n      if (!start && !end) return void 0;\n      return [Number(start.toFixed(3)), Number(end.toFixed(3))];\n    },\n    mediaEvents: [\"loadedmetadata\", \"emptied\", \"progress\", \"seekablechange\"]\n  },\n  mediaBuffered: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      const timeRanges = (_a = media == null ? void 0 : media.buffered) != null ? _a : [];\n      return Array.from(timeRanges).map((_, i) => [Number(timeRanges.start(i).toFixed(3)), Number(timeRanges.end(i).toFixed(3))]);\n    },\n    mediaEvents: [\"progress\", \"emptied\"]\n  },\n  mediaStreamType: {\n    get(stateOwners) {\n      const {\n        media,\n        options: {\n          defaultStreamType\n        } = {}\n      } = stateOwners;\n      const usedDefaultStreamType = [StreamTypes.LIVE, StreamTypes.ON_DEMAND].includes(defaultStreamType) ? defaultStreamType : void 0;\n      if (!media) return usedDefaultStreamType;\n      const {\n        streamType\n      } = media;\n      if (StreamTypeValues.includes(streamType)) {\n        if (streamType === StreamTypes.UNKNOWN) {\n          return usedDefaultStreamType;\n        }\n        return streamType;\n      }\n      const duration = media.duration;\n      if (duration === Infinity) {\n        return StreamTypes.LIVE;\n      } else if (Number.isFinite(duration)) {\n        return StreamTypes.ON_DEMAND;\n      }\n      return usedDefaultStreamType;\n    },\n    mediaEvents: [\"emptied\", \"durationchange\", \"loadedmetadata\", \"streamtypechange\"]\n  },\n  mediaTargetLiveWindow: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return Number.NaN;\n      const {\n        targetLiveWindow\n      } = media;\n      const streamType = stateMediator.mediaStreamType.get(stateOwners);\n      if ((targetLiveWindow == null || Number.isNaN(targetLiveWindow)) && streamType === StreamTypes.LIVE) {\n        return 0;\n      }\n      return targetLiveWindow;\n    },\n    mediaEvents: [\"emptied\", \"durationchange\", \"loadedmetadata\", \"streamtypechange\", \"targetlivewindowchange\"]\n  },\n  mediaTimeIsLive: {\n    get(stateOwners) {\n      const {\n        media,\n        // Default to 10 seconds\n        options: {\n          liveEdgeOffset = 10\n        } = {}\n      } = stateOwners;\n      if (!media) return false;\n      if (typeof media.liveEdgeStart === \"number\") {\n        if (Number.isNaN(media.liveEdgeStart)) return false;\n        return media.currentTime >= media.liveEdgeStart;\n      }\n      const live = stateMediator.mediaStreamType.get(stateOwners) === StreamTypes.LIVE;\n      if (!live) return false;\n      const seekable = media.seekable;\n      if (!seekable) return true;\n      if (!seekable.length) return false;\n      const liveEdgeStart = seekable.end(seekable.length - 1) - liveEdgeOffset;\n      return media.currentTime >= liveEdgeStart;\n    },\n    mediaEvents: [\"playing\", \"timeupdate\", \"progress\", \"waiting\", \"emptied\"]\n  },\n  // Text Tracks modeling\n  mediaSubtitlesList: {\n    get(stateOwners) {\n      return getSubtitleTracks(stateOwners).map(_ref => {\n        let {\n          kind,\n          label,\n          language\n        } = _ref;\n        return {\n          kind,\n          label,\n          language\n        };\n      });\n    },\n    mediaEvents: [\"loadstart\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaSubtitlesShowing: {\n    get(stateOwners) {\n      return getShowingSubtitleTracks(stateOwners).map(_ref2 => {\n        let {\n          kind,\n          label,\n          language\n        } = _ref2;\n        return {\n          kind,\n          label,\n          language\n        };\n      });\n    },\n    mediaEvents: [\"loadstart\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\", \"change\"],\n    stateOwnersUpdateHandlers: [(_handler, stateOwners) => {\n      var _a, _b;\n      const {\n        media,\n        options\n      } = stateOwners;\n      if (!media) return;\n      const updateDefaultSubtitlesCallback = event => {\n        var _a2;\n        if (!options.defaultSubtitles) return;\n        const nonSubsEvent = event && ![TextTrackKinds.CAPTIONS, TextTrackKinds.SUBTITLES].includes(\n        // @ts-ignore\n        (_a2 = event == null ? void 0 : event.track) == null ? void 0 : _a2.kind);\n        if (nonSubsEvent) return;\n        toggleSubtitleTracks(stateOwners, true);\n      };\n      media.addEventListener(\"loadstart\", updateDefaultSubtitlesCallback);\n      (_a = media.textTracks) == null ? void 0 : _a.addEventListener(\"addtrack\", updateDefaultSubtitlesCallback);\n      (_b = media.textTracks) == null ? void 0 : _b.addEventListener(\"removetrack\", updateDefaultSubtitlesCallback);\n      return () => {\n        var _a2, _b2;\n        media.removeEventListener(\"loadstart\", updateDefaultSubtitlesCallback);\n        (_a2 = media.textTracks) == null ? void 0 : _a2.removeEventListener(\"addtrack\", updateDefaultSubtitlesCallback);\n        (_b2 = media.textTracks) == null ? void 0 : _b2.removeEventListener(\"removetrack\", updateDefaultSubtitlesCallback);\n      };\n    }]\n  },\n  mediaChaptersCues: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return [];\n      const [chaptersTrack] = getTextTracksList(media, {\n        kind: TextTrackKinds.CHAPTERS\n      });\n      return Array.from((_a = chaptersTrack == null ? void 0 : chaptersTrack.cues) != null ? _a : []).map(_ref3 => {\n        let {\n          text,\n          startTime,\n          endTime\n        } = _ref3;\n        return {\n          text: parseHtmlToText(text),\n          startTime,\n          endTime\n        };\n      });\n    },\n    mediaEvents: [\"loadstart\", \"loadedmetadata\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\", \"change\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      const chaptersTrack = media.querySelector('track[kind=\"chapters\"][default][src]');\n      const shadowChaptersTrack = (_a = media.shadowRoot) == null ? void 0 : _a.querySelector(':is(video,audio) > track[kind=\"chapters\"][default][src]');\n      chaptersTrack == null ? void 0 : chaptersTrack.addEventListener(\"load\", handler);\n      shadowChaptersTrack == null ? void 0 : shadowChaptersTrack.addEventListener(\"load\", handler);\n      return () => {\n        chaptersTrack == null ? void 0 : chaptersTrack.removeEventListener(\"load\", handler);\n        shadowChaptersTrack == null ? void 0 : shadowChaptersTrack.removeEventListener(\"load\", handler);\n      };\n    }]\n  },\n  // Modeling state tied to root node\n  mediaIsPip: {\n    get(stateOwners) {\n      var _a, _b;\n      const {\n        media,\n        documentElement\n      } = stateOwners;\n      if (!media || !documentElement) return false;\n      if (!documentElement.pictureInPictureElement) return false;\n      if (documentElement.pictureInPictureElement === media) return true;\n      if (documentElement.pictureInPictureElement instanceof HTMLMediaElement) {\n        if (!((_a = media.localName) == null ? void 0 : _a.includes(\"-\"))) return false;\n        return containsComposedNode(media, documentElement.pictureInPictureElement);\n      }\n      if (documentElement.pictureInPictureElement.localName.includes(\"-\")) {\n        let currentRoot = documentElement.pictureInPictureElement.shadowRoot;\n        while (currentRoot == null ? void 0 : currentRoot.pictureInPictureElement) {\n          if (currentRoot.pictureInPictureElement === media) return true;\n          currentRoot = (_b = currentRoot.pictureInPictureElement) == null ? void 0 : _b.shadowRoot;\n        }\n      }\n      return false;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (value) {\n        if (!document.pictureInPictureEnabled) {\n          console.warn(\"MediaChrome: Picture-in-picture is not enabled\");\n          return;\n        }\n        if (!media.requestPictureInPicture) {\n          console.warn(\"MediaChrome: The current media does not support picture-in-picture\");\n          return;\n        }\n        const warnNotReady = () => {\n          console.warn(\"MediaChrome: The media is not ready for picture-in-picture. It must have a readyState > 0.\");\n        };\n        media.requestPictureInPicture().catch(err => {\n          if (err.code === 11) {\n            if (!media.src) {\n              console.warn(\"MediaChrome: The media is not ready for picture-in-picture. It must have a src set.\");\n              return;\n            }\n            if (media.readyState === 0 && media.preload === \"none\") {\n              const cleanup = () => {\n                media.removeEventListener(\"loadedmetadata\", tryPip);\n                media.preload = \"none\";\n              };\n              const tryPip = () => {\n                media.requestPictureInPicture().catch(warnNotReady);\n                cleanup();\n              };\n              media.addEventListener(\"loadedmetadata\", tryPip);\n              media.preload = \"metadata\";\n              setTimeout(() => {\n                if (media.readyState === 0) warnNotReady();\n                cleanup();\n              }, 1e3);\n            } else {\n              throw err;\n            }\n          } else {\n            throw err;\n          }\n        });\n      } else if (document.pictureInPictureElement) {\n        document.exitPictureInPicture();\n      }\n    },\n    mediaEvents: [\"enterpictureinpicture\", \"leavepictureinpicture\"]\n  },\n  mediaRenditionList: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return [...((_a = media == null ? void 0 : media.videoRenditions) != null ? _a : [])].map(videoRendition => ({\n        ...videoRendition\n      }));\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\"]\n  },\n  /** @TODO Model this as a derived value? (CJP) */\n  mediaRenditionSelected: {\n    get(stateOwners) {\n      var _a, _b, _c;\n      const {\n        media\n      } = stateOwners;\n      return (_c = (_b = media == null ? void 0 : media.videoRenditions) == null ? void 0 : _b[(_a = media.videoRenditions) == null ? void 0 : _a.selectedIndex]) == null ? void 0 : _c.id;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.videoRenditions)) {\n        console.warn(\"MediaController: Rendition selection not supported by this media.\");\n        return;\n      }\n      const renditionId = value;\n      const index = Array.prototype.findIndex.call(media.videoRenditions, r => r.id == renditionId);\n      if (media.videoRenditions.selectedIndex != index) {\n        media.videoRenditions.selectedIndex = index;\n      }\n    },\n    mediaEvents: [\"emptied\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\", \"change\"]\n  },\n  mediaAudioTrackList: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return [...((_a = media == null ? void 0 : media.audioTracks) != null ? _a : [])];\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaAudioTrackEnabled: {\n    get(stateOwners) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      return (_b = [...((_a = media == null ? void 0 : media.audioTracks) != null ? _a : [])].find(audioTrack => audioTrack.enabled)) == null ? void 0 : _b.id;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.audioTracks)) {\n        console.warn(\"MediaChrome: Audio track selection not supported by this media.\");\n        return;\n      }\n      const audioTrackId = value;\n      for (const track of media.audioTracks) {\n        track.enabled = audioTrackId == track.id;\n      }\n    },\n    mediaEvents: [\"emptied\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\", \"change\"]\n  },\n  mediaIsFullscreen: {\n    get(stateOwners) {\n      return isFullscreen(stateOwners);\n    },\n    set(value, stateOwners) {\n      if (!value) {\n        exitFullscreen(stateOwners);\n      } else {\n        enterFullscreen(stateOwners);\n      }\n    },\n    // older Safari version may require webkit-specific events\n    rootEvents: [\"fullscreenchange\", \"webkitfullscreenchange\"],\n    // iOS requires webkit-specific events on the video.\n    mediaEvents: [\"webkitbeginfullscreen\", \"webkitendfullscreen\", \"webkitpresentationmodechanged\"]\n  },\n  mediaIsCasting: {\n    // Note this relies on a customized castable-video element.\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.remote) || ((_a = media.remote) == null ? void 0 : _a.state) === \"disconnected\") return false;\n      return !!media.remote.state;\n    },\n    set(value, stateOwners) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (value && ((_a = media.remote) == null ? void 0 : _a.state) !== \"disconnected\") return;\n      if (!value && ((_b = media.remote) == null ? void 0 : _b.state) !== \"connected\") return;\n      if (typeof media.remote.prompt !== \"function\") {\n        console.warn(\"MediaChrome: Casting is not supported in this environment\");\n        return;\n      }\n      media.remote.prompt().catch(() => {});\n    },\n    remoteEvents: [\"connect\", \"connecting\", \"disconnect\"]\n  },\n  // NOTE: Newly added state for tracking airplaying\n  mediaIsAirplaying: {\n    // NOTE: Cannot know if airplaying since Safari doesn't fully support HTMLMediaElement::remote yet (e.g. remote::state) (CJP)\n    get() {\n      return false;\n    },\n    set(_value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (!(media.webkitShowPlaybackTargetPicker && globalThis.WebKitPlaybackTargetAvailabilityEvent)) {\n        console.error(\"MediaChrome: received a request to select AirPlay but AirPlay is not supported in this environment\");\n        return;\n      }\n      media.webkitShowPlaybackTargetPicker();\n    },\n    mediaEvents: [\"webkitcurrentplaybacktargetiswirelesschanged\"]\n  },\n  mediaFullscreenUnavailable: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!fullscreenSupported || !hasFullscreenSupport(media)) return AvailabilityStates.UNSUPPORTED;\n      return void 0;\n    }\n  },\n  mediaPipUnavailable: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!pipSupported || !hasPipSupport(media)) return AvailabilityStates.UNSUPPORTED;\n    }\n  },\n  mediaVolumeUnavailable: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (volumeSupported === false || (media == null ? void 0 : media.volume) == void 0) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      return void 0;\n    },\n    // NOTE: Slightly different impl here. Added generic support for\n    // \"stateOwnersUpdateHandlers\" since the original impl had to hack around\n    // race conditions. (CJP)\n    stateOwnersUpdateHandlers: [handler => {\n      if (volumeSupported == null) {\n        volumeSupportPromise.then(supported => handler(supported ? void 0 : AvailabilityStates.UNSUPPORTED));\n      }\n    }]\n  },\n  mediaCastUnavailable: {\n    // @ts-ignore\n    get(stateOwners) {\n      let {\n        availability = \"not-available\"\n      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!castSupported || !((_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.state)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (availability == null || availability === \"available\") return void 0;\n      return AvailabilityStates.UNAVAILABLE;\n    },\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      const remotePlaybackDisabled = media.disableRemotePlayback || media.hasAttribute(\"disableremoteplayback\");\n      if (!remotePlaybackDisabled) {\n        (_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.watchAvailability(availabilityBool => {\n          const availability = availabilityBool ? \"available\" : \"not-available\";\n          handler({\n            availability\n          });\n        }).catch(error => {\n          if (error.name === \"NotSupportedError\") {\n            handler({\n              availability: null\n            });\n          } else {\n            handler({\n              availability: \"not-available\"\n            });\n          }\n        });\n      }\n      return () => {\n        var _a2;\n        (_a2 = media == null ? void 0 : media.remote) == null ? void 0 : _a2.cancelWatchAvailability().catch(() => {});\n      };\n    }]\n  },\n  mediaAirplayUnavailable: {\n    get(_stateOwners, event) {\n      if (!airplaySupported) return AvailabilityStates.UNSUPPORTED;\n      if ((event == null ? void 0 : event.availability) === \"not-available\") {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    // NOTE: Keeping this event, as it's still the documented way of monitoring\n    // for AirPlay availability from Apple.\n    // See: https://developer.apple.com/documentation/webkitjs/adding_an_airplay_button_to_your_safari_media_controls#2940021 (CJP)\n    mediaEvents: [\"webkitplaybacktargetavailabilitychanged\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      const remotePlaybackDisabled = media.disableRemotePlayback || media.hasAttribute(\"disableremoteplayback\");\n      if (!remotePlaybackDisabled) {\n        (_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.watchAvailability(availabilityBool => {\n          const availability = availabilityBool ? \"available\" : \"not-available\";\n          handler({\n            availability\n          });\n        }).catch(error => {\n          if (error.name === \"NotSupportedError\") {\n            handler({\n              availability: null\n            });\n          } else {\n            handler({\n              availability: \"not-available\"\n            });\n          }\n        });\n      }\n      return () => {\n        var _a2;\n        (_a2 = media == null ? void 0 : media.remote) == null ? void 0 : _a2.cancelWatchAvailability().catch(() => {});\n      };\n    }]\n  },\n  mediaRenditionUnavailable: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.videoRenditions)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (!((_a = media.videoRenditions) == null ? void 0 : _a.length)) {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\"]\n  },\n  mediaAudioTrackUnavailable: {\n    get(stateOwners) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.audioTracks)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (((_b = (_a = media.audioTracks) == null ? void 0 : _a.length) != null ? _b : 0) <= 1) {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\"]\n  }\n};\nexport { prepareStateOwners, stateMediator, volumeSupportPromise };","map":null,"metadata":{},"sourceType":"module"}