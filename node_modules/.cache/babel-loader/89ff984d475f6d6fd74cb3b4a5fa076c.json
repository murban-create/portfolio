{"ast":null,"code":"import { MediaChromeButton } from \"./media-chrome-button.js\";\nimport { globalThis } from \"./utils/server-safe-globals.js\";\nimport { MediaUIEvents, MediaUIAttributes } from \"./constants.js\";\nimport { t } from \"./utils/i18n.js\";\nimport { getStringAttr, setStringAttr, getBooleanAttr, setBooleanAttr } from \"./utils/element-utils.js\";\nconst airplayIcon = `<svg aria-hidden=\"true\" viewBox=\"0 0 26 24\">\n  <path d=\"M22.13 3H3.87a.87.87 0 0 0-.87.87v13.26a.87.87 0 0 0 .87.87h3.4L9 16H5V5h16v11h-4l1.72 2h3.4a.87.87 0 0 0 .87-.87V3.87a.87.87 0 0 0-.86-.87Zm-8.75 11.44a.5.5 0 0 0-.76 0l-4.91 5.73a.5.5 0 0 0 .38.83h9.82a.501.501 0 0 0 .38-.83l-4.91-5.73Z\"/>\n</svg>\n`;\nfunction getSlotTemplateHTML(_attrs) {\n  return /*html*/`\n    <style>\n      :host([${MediaUIAttributes.MEDIA_IS_AIRPLAYING}]) slot[name=icon] slot:not([name=exit]) {\n        display: none !important;\n      }\n\n      ${/* Double negative, but safer if display doesn't equal 'block' */\n  \"\"}\n      :host(:not([${MediaUIAttributes.MEDIA_IS_AIRPLAYING}])) slot[name=icon] slot:not([name=enter]) {\n        display: none !important;\n      }\n\n      :host([${MediaUIAttributes.MEDIA_IS_AIRPLAYING}]) slot[name=tooltip-enter],\n      :host(:not([${MediaUIAttributes.MEDIA_IS_AIRPLAYING}])) slot[name=tooltip-exit] {\n        display: none;\n      }\n    </style>\n\n    <slot name=\"icon\">\n      <slot name=\"enter\">${airplayIcon}</slot>\n      <slot name=\"exit\">${airplayIcon}</slot>\n    </slot>\n  `;\n}\nfunction getTooltipContentHTML() {\n  return /*html*/`\n    <slot name=\"tooltip-enter\">${t(\"start airplay\")}</slot>\n    <slot name=\"tooltip-exit\">${t(\"stop airplay\")}</slot>\n  `;\n}\nconst updateAriaLabel = el => {\n  const label = el.mediaIsAirplaying ? t(\"stop airplay\") : t(\"start airplay\");\n  el.setAttribute(\"aria-label\", label);\n};\nclass MediaAirplayButton extends MediaChromeButton {\n  static get observedAttributes() {\n    return [...super.observedAttributes, MediaUIAttributes.MEDIA_IS_AIRPLAYING, MediaUIAttributes.MEDIA_AIRPLAY_UNAVAILABLE];\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    updateAriaLabel(this);\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n    if (attrName === MediaUIAttributes.MEDIA_IS_AIRPLAYING) {\n      updateAriaLabel(this);\n    }\n  }\n  /**\n   * Are we currently airplaying\n   */\n  get mediaIsAirplaying() {\n    return getBooleanAttr(this, MediaUIAttributes.MEDIA_IS_AIRPLAYING);\n  }\n  set mediaIsAirplaying(value) {\n    setBooleanAttr(this, MediaUIAttributes.MEDIA_IS_AIRPLAYING, value);\n  }\n  /**\n   * Airplay unavailability state\n   */\n  get mediaAirplayUnavailable() {\n    return getStringAttr(this, MediaUIAttributes.MEDIA_AIRPLAY_UNAVAILABLE);\n  }\n  set mediaAirplayUnavailable(value) {\n    setStringAttr(this, MediaUIAttributes.MEDIA_AIRPLAY_UNAVAILABLE, value);\n  }\n  handleClick() {\n    const evt = new globalThis.CustomEvent(MediaUIEvents.MEDIA_AIRPLAY_REQUEST, {\n      composed: true,\n      bubbles: true\n    });\n    this.dispatchEvent(evt);\n  }\n}\nMediaAirplayButton.getSlotTemplateHTML = getSlotTemplateHTML;\nMediaAirplayButton.getTooltipContentHTML = getTooltipContentHTML;\nif (!globalThis.customElements.get(\"media-airplay-button\")) {\n  globalThis.customElements.define(\"media-airplay-button\", MediaAirplayButton);\n}\nvar media_airplay_button_default = MediaAirplayButton;\nexport { media_airplay_button_default as default };","map":null,"metadata":{},"sourceType":"module"}