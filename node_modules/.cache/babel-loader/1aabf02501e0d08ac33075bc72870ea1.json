{"ast":null,"code":"var __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _parts, _processor, _items, _value, _element, _attributeName, _namespaceURI, _list, list_get, _parentNode, _nodes;\nimport { globalThis } from \"../utils/server-safe-globals.js\";\nconst ELEMENT = 1;\nconst STRING = 0;\nconst PART = 1;\nconst defaultProcessor = {\n  processCallback(instance, parts, state) {\n    if (!state) return;\n    for (const [expression, part] of parts) {\n      if (expression in state) {\n        const value = state[expression];\n        if (typeof value === \"boolean\" && part instanceof AttrPart && typeof part.element[part.attributeName] === \"boolean\") {\n          part.booleanValue = value;\n        } else if (typeof value === \"function\" && part instanceof AttrPart) {\n          part.element[part.attributeName] = value;\n        } else {\n          part.value = value;\n        }\n      }\n    }\n  }\n};\nclass TemplateInstance extends globalThis.DocumentFragment {\n  constructor(template, state) {\n    let processor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultProcessor;\n    var _a;\n    super();\n    __privateAdd(this, _parts, void 0);\n    __privateAdd(this, _processor, void 0);\n    this.append(template.content.cloneNode(true));\n    __privateSet(this, _parts, parse(this));\n    __privateSet(this, _processor, processor);\n    (_a = processor.createCallback) == null ? void 0 : _a.call(processor, this, __privateGet(this, _parts), state);\n    processor.processCallback(this, __privateGet(this, _parts), state);\n  }\n  update(state) {\n    __privateGet(this, _processor).processCallback(this, __privateGet(this, _parts), state);\n  }\n}\n_parts = new WeakMap();\n_processor = new WeakMap();\nconst parse = function (element) {\n  let parts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let type, value;\n  for (const attr of element.attributes || []) {\n    if (attr.value.includes(\"{{\")) {\n      const list = new AttrPartList();\n      for ([type, value] of tokenize(attr.value)) {\n        if (!type) list.append(value);else {\n          const part = new AttrPart(element, attr.name, attr.namespaceURI);\n          list.append(part);\n          parts.push([value, part]);\n        }\n      }\n      attr.value = list.toString();\n    }\n  }\n  for (const node of element.childNodes) {\n    if (node.nodeType === ELEMENT && !(node instanceof HTMLTemplateElement)) {\n      parse(node, parts);\n    } else {\n      const data = node.data;\n      if (node.nodeType === ELEMENT || data.includes(\"{{\")) {\n        const items = [];\n        if (data) {\n          for ([type, value] of tokenize(data)) if (!type) items.push(new Text(value));else {\n            const part = new ChildNodePart(element);\n            items.push(part);\n            parts.push([value, part]);\n          }\n        } else if (node instanceof HTMLTemplateElement) {\n          const part = new InnerTemplatePart(element, node);\n          items.push(part);\n          parts.push([part.expression, part]);\n        }\n        node.replaceWith(...items.flatMap(part => part.replacementNodes || [part]));\n      }\n    }\n  }\n  return parts;\n};\nconst mem = {};\nconst tokenize = text => {\n  let value = \"\",\n    open = 0,\n    tokens = mem[text],\n    i = 0,\n    c;\n  if (tokens) return tokens;else tokens = [];\n  for (; c = text[i]; i++) {\n    if (c === \"{\" && text[i + 1] === \"{\" && text[i - 1] !== \"\\\\\" && text[i + 2] && ++open == 1) {\n      if (value) tokens.push([STRING, value]);\n      value = \"\";\n      i++;\n    } else if (c === \"}\" && text[i + 1] === \"}\" && text[i - 1] !== \"\\\\\" && ! --open) {\n      tokens.push([PART, value.trim()]);\n      value = \"\";\n      i++;\n    } else value += c || \"\";\n  }\n  if (value) tokens.push([STRING, (open > 0 ? \"{{\" : \"\") + value]);\n  return mem[text] = tokens;\n};\nconst FRAGMENT = 11;\nclass Part {\n  get value() {\n    return \"\";\n  }\n  set value(val) {}\n  toString() {\n    return this.value;\n  }\n}\nconst attrPartToList = /* @__PURE__ */new WeakMap();\nclass AttrPartList {\n  constructor() {\n    __privateAdd(this, _items, []);\n  }\n  [Symbol.iterator]() {\n    return __privateGet(this, _items).values();\n  }\n  get length() {\n    return __privateGet(this, _items).length;\n  }\n  item(index) {\n    return __privateGet(this, _items)[index];\n  }\n  append() {\n    for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n      items[_key] = arguments[_key];\n    }\n    for (const item of items) {\n      if (item instanceof AttrPart) {\n        attrPartToList.set(item, this);\n      }\n      __privateGet(this, _items).push(item);\n    }\n  }\n  toString() {\n    return __privateGet(this, _items).join(\"\");\n  }\n}\n_items = new WeakMap();\nclass AttrPart extends Part {\n  constructor(element, attributeName, namespaceURI) {\n    super();\n    __privateAdd(this, _list);\n    __privateAdd(this, _value, \"\");\n    __privateAdd(this, _element, void 0);\n    __privateAdd(this, _attributeName, void 0);\n    __privateAdd(this, _namespaceURI, void 0);\n    __privateSet(this, _element, element);\n    __privateSet(this, _attributeName, attributeName);\n    __privateSet(this, _namespaceURI, namespaceURI);\n  }\n  get attributeName() {\n    return __privateGet(this, _attributeName);\n  }\n  get attributeNamespace() {\n    return __privateGet(this, _namespaceURI);\n  }\n  get element() {\n    return __privateGet(this, _element);\n  }\n  get value() {\n    return __privateGet(this, _value);\n  }\n  set value(newValue) {\n    if (__privateGet(this, _value) === newValue) return;\n    __privateSet(this, _value, newValue);\n    if (!__privateGet(this, _list, list_get) || __privateGet(this, _list, list_get).length === 1) {\n      if (newValue == null) {\n        __privateGet(this, _element).removeAttributeNS(__privateGet(this, _namespaceURI), __privateGet(this, _attributeName));\n      } else {\n        __privateGet(this, _element).setAttributeNS(__privateGet(this, _namespaceURI), __privateGet(this, _attributeName), newValue);\n      }\n    } else {\n      __privateGet(this, _element).setAttributeNS(__privateGet(this, _namespaceURI), __privateGet(this, _attributeName), __privateGet(this, _list, list_get).toString());\n    }\n  }\n  get booleanValue() {\n    return __privateGet(this, _element).hasAttributeNS(__privateGet(this, _namespaceURI), __privateGet(this, _attributeName));\n  }\n  set booleanValue(value) {\n    if (!__privateGet(this, _list, list_get) || __privateGet(this, _list, list_get).length === 1) this.value = value ? \"\" : null;else throw new DOMException(\"Value is not fully templatized\");\n  }\n}\n_value = new WeakMap();\n_element = new WeakMap();\n_attributeName = new WeakMap();\n_namespaceURI = new WeakMap();\n_list = new WeakSet();\nlist_get = function () {\n  return attrPartToList.get(this);\n};\nclass ChildNodePart extends Part {\n  constructor(parentNode, nodes) {\n    super();\n    __privateAdd(this, _parentNode, void 0);\n    __privateAdd(this, _nodes, void 0);\n    __privateSet(this, _parentNode, parentNode);\n    __privateSet(this, _nodes, nodes ? [...nodes] : [new Text()]);\n  }\n  get replacementNodes() {\n    return __privateGet(this, _nodes);\n  }\n  get parentNode() {\n    return __privateGet(this, _parentNode);\n  }\n  get nextSibling() {\n    return __privateGet(this, _nodes)[__privateGet(this, _nodes).length - 1].nextSibling;\n  }\n  get previousSibling() {\n    return __privateGet(this, _nodes)[0].previousSibling;\n  }\n  // FIXME: not sure why do we need string serialization here? Just because parent class has type DOMString?\n  get value() {\n    return __privateGet(this, _nodes).map(node => node.textContent).join(\"\");\n  }\n  set value(newValue) {\n    this.replace(newValue);\n  }\n  replace() {\n    for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      nodes[_key2] = arguments[_key2];\n    }\n    const normalisedNodes = nodes.flat().flatMap(node => node == null ? [new Text()] : node.forEach ? [...node] : node.nodeType === FRAGMENT ? [...node.childNodes] : node.nodeType ? [node] : [new Text(node)]);\n    if (!normalisedNodes.length) normalisedNodes.push(new Text());\n    __privateSet(this, _nodes, swapdom(__privateGet(this, _nodes)[0].parentNode, __privateGet(this, _nodes), normalisedNodes, this.nextSibling));\n  }\n}\n_parentNode = new WeakMap();\n_nodes = new WeakMap();\nclass InnerTemplatePart extends ChildNodePart {\n  constructor(parentNode, template) {\n    const directive = template.getAttribute(\"directive\") || template.getAttribute(\"type\");\n    let expression = template.getAttribute(\"expression\") || template.getAttribute(directive) || \"\";\n    if (expression.startsWith(\"{{\")) expression = expression.trim().slice(2, -2).trim();\n    super(parentNode);\n    this.expression = expression;\n    this.template = template;\n    this.directive = directive;\n  }\n}\nfunction swapdom(parent, a, b) {\n  let end = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  let i = 0,\n    cur,\n    next,\n    bi,\n    n = b.length,\n    m = a.length;\n  while (i < n && i < m && a[i] == b[i]) i++;\n  while (i < n && i < m && b[n - 1] == a[m - 1]) end = b[--m, --n];\n  if (i == m) while (i < n) parent.insertBefore(b[i++], end);\n  if (i == n) while (i < m) parent.removeChild(a[i++]);else {\n    cur = a[i];\n    while (i < n) {\n      bi = b[i++], next = cur ? cur.nextSibling : end;\n      if (cur == bi) cur = next;else if (i < n && b[i] == next) parent.replaceChild(bi, cur), cur = next;else parent.insertBefore(bi, cur);\n    }\n    while (cur != end) next = cur.nextSibling, parent.removeChild(cur), cur = next;\n  }\n  return b;\n}\nexport { AttrPart, AttrPartList, ChildNodePart, InnerTemplatePart, Part, TemplateInstance, defaultProcessor, parse, tokenize };","map":{"version":3,"names":["__accessCheck","obj","member","msg","has","TypeError","__privateGet","getter","call","get","__privateAdd","value","WeakSet","add","set","__privateSet","setter","_parts","_processor","_items","_value","_element","_attributeName","_namespaceURI","_list","list_get","_parentNode","_nodes","globalThis","ELEMENT","STRING","PART","defaultProcessor","processCallback","instance","parts","state","expression","part","AttrPart","element","attributeName","booleanValue","TemplateInstance","DocumentFragment","constructor","template","processor","arguments","length","undefined","_a","append","content","cloneNode","parse","createCallback","update","WeakMap","type","attr","attributes","includes","list","AttrPartList","tokenize","name","namespaceURI","push","toString","node","childNodes","nodeType","HTMLTemplateElement","data","items","Text","ChildNodePart","InnerTemplatePart","replaceWith","flatMap","replacementNodes","mem","text","open","tokens","i","c","trim","FRAGMENT","Part","val","attrPartToList","Symbol","iterator","values","item","index","_len","Array","_key","join","attributeNamespace","newValue","removeAttributeNS","setAttributeNS","hasAttributeNS","DOMException","parentNode","nodes","nextSibling","previousSibling","map","textContent","replace","_len2","_key2","normalisedNodes","flat","forEach","swapdom","directive","getAttribute","startsWith","slice","parent","a","b","end","cur","next","bi","n","m","insertBefore","removeChild","replaceChild"],"sources":["/Users/monawiebkeurban/Documents/portfolio/node_modules/media-chrome/dist/utils/template-parts.js"],"sourcesContent":["var __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _parts, _processor, _items, _value, _element, _attributeName, _namespaceURI, _list, list_get, _parentNode, _nodes;\nimport { globalThis } from \"../utils/server-safe-globals.js\";\nconst ELEMENT = 1;\nconst STRING = 0;\nconst PART = 1;\nconst defaultProcessor = {\n  processCallback(instance, parts, state) {\n    if (!state)\n      return;\n    for (const [expression, part] of parts) {\n      if (expression in state) {\n        const value = state[expression];\n        if (typeof value === \"boolean\" && part instanceof AttrPart && typeof part.element[part.attributeName] === \"boolean\") {\n          part.booleanValue = value;\n        } else if (typeof value === \"function\" && part instanceof AttrPart) {\n          part.element[part.attributeName] = value;\n        } else {\n          part.value = value;\n        }\n      }\n    }\n  }\n};\nclass TemplateInstance extends globalThis.DocumentFragment {\n  constructor(template, state, processor = defaultProcessor) {\n    var _a;\n    super();\n    __privateAdd(this, _parts, void 0);\n    __privateAdd(this, _processor, void 0);\n    this.append(template.content.cloneNode(true));\n    __privateSet(this, _parts, parse(this));\n    __privateSet(this, _processor, processor);\n    (_a = processor.createCallback) == null ? void 0 : _a.call(processor, this, __privateGet(this, _parts), state);\n    processor.processCallback(this, __privateGet(this, _parts), state);\n  }\n  update(state) {\n    __privateGet(this, _processor).processCallback(this, __privateGet(this, _parts), state);\n  }\n}\n_parts = new WeakMap();\n_processor = new WeakMap();\nconst parse = (element, parts = []) => {\n  let type, value;\n  for (const attr of element.attributes || []) {\n    if (attr.value.includes(\"{{\")) {\n      const list = new AttrPartList();\n      for ([type, value] of tokenize(attr.value)) {\n        if (!type)\n          list.append(value);\n        else {\n          const part = new AttrPart(element, attr.name, attr.namespaceURI);\n          list.append(part);\n          parts.push([value, part]);\n        }\n      }\n      attr.value = list.toString();\n    }\n  }\n  for (const node of element.childNodes) {\n    if (node.nodeType === ELEMENT && !(node instanceof HTMLTemplateElement)) {\n      parse(node, parts);\n    } else {\n      const data = node.data;\n      if (node.nodeType === ELEMENT || data.includes(\"{{\")) {\n        const items = [];\n        if (data) {\n          for ([type, value] of tokenize(data))\n            if (!type)\n              items.push(new Text(value));\n            else {\n              const part = new ChildNodePart(element);\n              items.push(part);\n              parts.push([value, part]);\n            }\n        } else if (node instanceof HTMLTemplateElement) {\n          const part = new InnerTemplatePart(element, node);\n          items.push(part);\n          parts.push([part.expression, part]);\n        }\n        node.replaceWith(\n          ...items.flatMap((part) => part.replacementNodes || [part])\n        );\n      }\n    }\n  }\n  return parts;\n};\nconst mem = {};\nconst tokenize = (text) => {\n  let value = \"\", open = 0, tokens = mem[text], i = 0, c;\n  if (tokens)\n    return tokens;\n  else\n    tokens = [];\n  for (; c = text[i]; i++) {\n    if (c === \"{\" && text[i + 1] === \"{\" && text[i - 1] !== \"\\\\\" && text[i + 2] && ++open == 1) {\n      if (value)\n        tokens.push([STRING, value]);\n      value = \"\";\n      i++;\n    } else if (c === \"}\" && text[i + 1] === \"}\" && text[i - 1] !== \"\\\\\" && !--open) {\n      tokens.push([PART, value.trim()]);\n      value = \"\";\n      i++;\n    } else\n      value += c || \"\";\n  }\n  if (value)\n    tokens.push([STRING, (open > 0 ? \"{{\" : \"\") + value]);\n  return mem[text] = tokens;\n};\nconst FRAGMENT = 11;\nclass Part {\n  get value() {\n    return \"\";\n  }\n  set value(val) {\n  }\n  toString() {\n    return this.value;\n  }\n}\nconst attrPartToList = /* @__PURE__ */ new WeakMap();\nclass AttrPartList {\n  constructor() {\n    __privateAdd(this, _items, []);\n  }\n  [Symbol.iterator]() {\n    return __privateGet(this, _items).values();\n  }\n  get length() {\n    return __privateGet(this, _items).length;\n  }\n  item(index) {\n    return __privateGet(this, _items)[index];\n  }\n  append(...items) {\n    for (const item of items) {\n      if (item instanceof AttrPart) {\n        attrPartToList.set(item, this);\n      }\n      __privateGet(this, _items).push(item);\n    }\n  }\n  toString() {\n    return __privateGet(this, _items).join(\"\");\n  }\n}\n_items = new WeakMap();\nclass AttrPart extends Part {\n  constructor(element, attributeName, namespaceURI) {\n    super();\n    __privateAdd(this, _list);\n    __privateAdd(this, _value, \"\");\n    __privateAdd(this, _element, void 0);\n    __privateAdd(this, _attributeName, void 0);\n    __privateAdd(this, _namespaceURI, void 0);\n    __privateSet(this, _element, element);\n    __privateSet(this, _attributeName, attributeName);\n    __privateSet(this, _namespaceURI, namespaceURI);\n  }\n  get attributeName() {\n    return __privateGet(this, _attributeName);\n  }\n  get attributeNamespace() {\n    return __privateGet(this, _namespaceURI);\n  }\n  get element() {\n    return __privateGet(this, _element);\n  }\n  get value() {\n    return __privateGet(this, _value);\n  }\n  set value(newValue) {\n    if (__privateGet(this, _value) === newValue)\n      return;\n    __privateSet(this, _value, newValue);\n    if (!__privateGet(this, _list, list_get) || __privateGet(this, _list, list_get).length === 1) {\n      if (newValue == null) {\n        __privateGet(this, _element).removeAttributeNS(\n          __privateGet(this, _namespaceURI),\n          __privateGet(this, _attributeName)\n        );\n      } else {\n        __privateGet(this, _element).setAttributeNS(\n          __privateGet(this, _namespaceURI),\n          __privateGet(this, _attributeName),\n          newValue\n        );\n      }\n    } else {\n      __privateGet(this, _element).setAttributeNS(\n        __privateGet(this, _namespaceURI),\n        __privateGet(this, _attributeName),\n        __privateGet(this, _list, list_get).toString()\n      );\n    }\n  }\n  get booleanValue() {\n    return __privateGet(this, _element).hasAttributeNS(\n      __privateGet(this, _namespaceURI),\n      __privateGet(this, _attributeName)\n    );\n  }\n  set booleanValue(value) {\n    if (!__privateGet(this, _list, list_get) || __privateGet(this, _list, list_get).length === 1)\n      this.value = value ? \"\" : null;\n    else\n      throw new DOMException(\"Value is not fully templatized\");\n  }\n}\n_value = new WeakMap();\n_element = new WeakMap();\n_attributeName = new WeakMap();\n_namespaceURI = new WeakMap();\n_list = new WeakSet();\nlist_get = function() {\n  return attrPartToList.get(this);\n};\nclass ChildNodePart extends Part {\n  constructor(parentNode, nodes) {\n    super();\n    __privateAdd(this, _parentNode, void 0);\n    __privateAdd(this, _nodes, void 0);\n    __privateSet(this, _parentNode, parentNode);\n    __privateSet(this, _nodes, nodes ? [...nodes] : [new Text()]);\n  }\n  get replacementNodes() {\n    return __privateGet(this, _nodes);\n  }\n  get parentNode() {\n    return __privateGet(this, _parentNode);\n  }\n  get nextSibling() {\n    return __privateGet(this, _nodes)[__privateGet(this, _nodes).length - 1].nextSibling;\n  }\n  get previousSibling() {\n    return __privateGet(this, _nodes)[0].previousSibling;\n  }\n  // FIXME: not sure why do we need string serialization here? Just because parent class has type DOMString?\n  get value() {\n    return __privateGet(this, _nodes).map((node) => node.textContent).join(\"\");\n  }\n  set value(newValue) {\n    this.replace(newValue);\n  }\n  replace(...nodes) {\n    const normalisedNodes = nodes.flat().flatMap(\n      (node) => node == null ? [new Text()] : node.forEach ? [...node] : node.nodeType === FRAGMENT ? [...node.childNodes] : node.nodeType ? [node] : [new Text(node)]\n    );\n    if (!normalisedNodes.length)\n      normalisedNodes.push(new Text());\n    __privateSet(this, _nodes, swapdom(\n      __privateGet(this, _nodes)[0].parentNode,\n      __privateGet(this, _nodes),\n      normalisedNodes,\n      this.nextSibling\n    ));\n  }\n}\n_parentNode = new WeakMap();\n_nodes = new WeakMap();\nclass InnerTemplatePart extends ChildNodePart {\n  constructor(parentNode, template) {\n    const directive = template.getAttribute(\"directive\") || template.getAttribute(\"type\");\n    let expression = template.getAttribute(\"expression\") || template.getAttribute(directive) || \"\";\n    if (expression.startsWith(\"{{\"))\n      expression = expression.trim().slice(2, -2).trim();\n    super(parentNode);\n    this.expression = expression;\n    this.template = template;\n    this.directive = directive;\n  }\n}\nfunction swapdom(parent, a, b, end = null) {\n  let i = 0, cur, next, bi, n = b.length, m = a.length;\n  while (i < n && i < m && a[i] == b[i])\n    i++;\n  while (i < n && i < m && b[n - 1] == a[m - 1])\n    end = b[--m, --n];\n  if (i == m)\n    while (i < n)\n      parent.insertBefore(b[i++], end);\n  if (i == n)\n    while (i < m)\n      parent.removeChild(a[i++]);\n  else {\n    cur = a[i];\n    while (i < n) {\n      bi = b[i++], next = cur ? cur.nextSibling : end;\n      if (cur == bi)\n        cur = next;\n      else if (i < n && b[i] == next)\n        parent.replaceChild(bi, cur), cur = next;\n      else\n        parent.insertBefore(bi, cur);\n    }\n    while (cur != end)\n      next = cur.nextSibling, parent.removeChild(cur), cur = next;\n  }\n  return b;\n}\nexport {\n  AttrPart,\n  AttrPartList,\n  ChildNodePart,\n  InnerTemplatePart,\n  Part,\n  TemplateInstance,\n  defaultProcessor,\n  parse,\n  tokenize\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}