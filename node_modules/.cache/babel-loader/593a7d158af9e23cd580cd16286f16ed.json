{"ast":null,"code":"\"use client\";\n\nimport m, { useState as pe, useRef as Ee } from \"react\";\nimport { MaxResolution as Le, MinResolution as Ae, RenditionOrder as Ie, generatePlayerInitTime as Me } from \"@mux/playback-core\";\nimport { MediaError as Ke } from \"@mux/mux-player\";\nimport X from \"react\";\nvar M = parseInt(X.version) >= 19,\n  E = {\n    className: \"class\",\n    classname: \"class\",\n    htmlFor: \"for\",\n    crossOrigin: \"crossorigin\",\n    viewBox: \"viewBox\",\n    playsInline: \"playsinline\",\n    autoPlay: \"autoplay\",\n    playbackRate: \"playbackrate\"\n  },\n  B = e => e == null,\n  ee = (e, t) => B(t) ? !1 : e in t,\n  te = e => e.replace(/[A-Z]/g, t => `-${t.toLowerCase()}`),\n  ne = (e, t) => {\n    if (!(!M && typeof t == \"boolean\" && !t)) {\n      if (ee(e, E)) return E[e];\n      if (typeof t != \"undefined\") return /[A-Z]/.test(e) ? te(e) : e;\n    }\n  };\nvar ae = (e, t) => !M && typeof e == \"boolean\" ? \"\" : e,\n  P = function () {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      ref: t,\n      ...n\n    } = e;\n    return Object.entries(n).reduce((o, _ref) => {\n      let [a, l] = _ref;\n      let i = ne(a, l);\n      if (!i) return o;\n      let c = ae(l, a);\n      return o[i] = c, o;\n    }, {});\n  };\nimport * as d from \"react\";\nfunction x(e, t) {\n  if (typeof e == \"function\") return e(t);\n  e != null && (e.current = t);\n}\nfunction re() {\n  for (var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++) {\n    e[_key] = arguments[_key];\n  }\n  return t => {\n    let n = !1,\n      o = e.map(a => {\n        let l = x(a, t);\n        return !n && typeof l == \"function\" && (n = !0), l;\n      });\n    if (n) return () => {\n      for (let a = 0; a < o.length; a++) {\n        let l = o[a];\n        typeof l == \"function\" ? l() : x(e[a], null);\n      }\n    };\n  };\n}\nfunction f() {\n  for (var _len2 = arguments.length, e = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    e[_key2] = arguments[_key2];\n  }\n  return d.useCallback(re(...e), e);\n}\nimport { useEffect as le } from \"react\";\nvar oe = Object.prototype.hasOwnProperty,\n  ue = (e, t) => {\n    if (Object.is(e, t)) return !0;\n    if (typeof e != \"object\" || e === null || typeof t != \"object\" || t === null) return !1;\n    if (Array.isArray(e)) return !Array.isArray(t) || e.length !== t.length ? !1 : e.some((a, l) => t[l] === a);\n    let n = Object.keys(e),\n      o = Object.keys(t);\n    if (n.length !== o.length) return !1;\n    for (let a = 0; a < n.length; a++) if (!oe.call(t, n[a]) || !Object.is(e[n[a]], t[n[a]])) return !1;\n    return !0;\n  },\n  p = (e, t, n) => !ue(t, e[n]),\n  se = (e, t, n) => {\n    e[n] = t;\n  },\n  ie = function (e, t, n) {\n    let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : se;\n    let a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : p;\n    return le(() => {\n      let l = n == null ? void 0 : n.current;\n      l && a(l, t, e) && o(l, t, e);\n    }, [n == null ? void 0 : n.current, t]);\n  },\n  u = ie;\nvar ye = () => {\n    try {\n      return \"3.5.3\";\n    } catch {}\n    return \"UNKNOWN\";\n  },\n  me = ye(),\n  g = () => me;\nimport { useEffect as ce } from \"react\";\nvar r = (e, t, n) => ce(() => {\n  let o = t == null ? void 0 : t.current;\n  if (!o || !n) return;\n  let a = e,\n    l = n;\n  return o.addEventListener(a, l), () => {\n    o.removeEventListener(a, l);\n  };\n}, [t == null ? void 0 : t.current, n, e]);\nvar Pe = m.forwardRef((_ref2, n) => {\n    let {\n      children: e,\n      ...t\n    } = _ref2;\n    return m.createElement(\"mux-player\", {\n      suppressHydrationWarning: !0,\n      ...P(t),\n      ref: n\n    }, e);\n  }),\n  xe = (e, t) => {\n    let {\n      onAbort: n,\n      onCanPlay: o,\n      onCanPlayThrough: a,\n      onEmptied: l,\n      onLoadStart: i,\n      onLoadedData: c,\n      onLoadedMetadata: v,\n      onProgress: R,\n      onDurationChange: T,\n      onVolumeChange: h,\n      onRateChange: b,\n      onResize: C,\n      onWaiting: k,\n      onPlay: O,\n      onPlaying: S,\n      onTimeUpdate: w,\n      onPause: N,\n      onSeeking: L,\n      onSeeked: A,\n      onStalled: I,\n      onSuspend: _,\n      onEnded: K,\n      onError: H,\n      onCuePointChange: D,\n      onChapterChange: V,\n      metadata: W,\n      tokens: U,\n      paused: z,\n      playbackId: F,\n      playbackRates: G,\n      currentTime: Z,\n      themeProps: j,\n      extraSourceParams: q,\n      castCustomData: J,\n      _hlsConfig: Y,\n      ...$\n    } = t;\n    return u(\"tokens\", U, e), u(\"playbackId\", F, e), u(\"playbackRates\", G, e), u(\"metadata\", W, e), u(\"extraSourceParams\", q, e), u(\"_hlsConfig\", Y, e), u(\"themeProps\", j, e), u(\"castCustomData\", J, e), u(\"paused\", z, e, (s, y) => {\n      y != null && (y ? s.pause() : s.play());\n    }, (s, y, Q) => s.hasAttribute(\"autoplay\") && !s.hasPlayed ? !1 : p(s, y, Q)), u(\"currentTime\", Z, e, (s, y) => {\n      y != null && (s.currentTime = y);\n    }), r(\"abort\", e, n), r(\"canplay\", e, o), r(\"canplaythrough\", e, a), r(\"emptied\", e, l), r(\"loadstart\", e, i), r(\"loadeddata\", e, c), r(\"loadedmetadata\", e, v), r(\"progress\", e, R), r(\"durationchange\", e, T), r(\"volumechange\", e, h), r(\"ratechange\", e, b), r(\"resize\", e, C), r(\"waiting\", e, k), r(\"play\", e, O), r(\"playing\", e, S), r(\"timeupdate\", e, w), r(\"pause\", e, N), r(\"seeking\", e, L), r(\"seeked\", e, A), r(\"stalled\", e, I), r(\"suspend\", e, _), r(\"ended\", e, K), r(\"error\", e, H), r(\"cuepointchange\", e, D), r(\"chapterchange\", e, V), [$];\n  },\n  de = g(),\n  fe = \"mux-player-react\",\n  ge = m.forwardRef((e, t) => {\n    var i;\n    let n = Ee(null),\n      o = f(n, t),\n      [a] = xe(n, e),\n      [l] = pe((i = e.playerInitTime) != null ? i : Me());\n    return m.createElement(Pe, {\n      ref: o,\n      defaultHiddenCaptions: e.defaultHiddenCaptions,\n      playerSoftwareName: fe,\n      playerSoftwareVersion: de,\n      playerInitTime: l,\n      ...a\n    });\n  }),\n  ze = ge;\nexport { Le as MaxResolution, Ke as MediaError, Ae as MinResolution, Ie as RenditionOrder, ze as default, Me as generatePlayerInitTime, fe as playerSoftwareName, de as playerSoftwareVersion };","map":{"version":3,"mappings":"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","names":["React","useState","useRef","MaxResolution","MinResolution","RenditionOrder","generatePlayerInitTime","MediaError","IS_REACT_19_OR_NEWER","parseInt","version","ReactPropToAttrNameMap","className","classname","htmlFor","crossOrigin","viewBox","playsInline","autoPlay","playbackRate","isNil","x","isKeyOf","ee","k","o","toKebabCase","string","replace","match","toLowerCase","toNativeAttrName","ne","propName","propValue","test","toNativeAttrValue","ae","_propName","toNativeProps","props","ref","restProps","Object","entries","reduce","transformedProps","attrName","attrValue","setRef","value","current","composeRefs","refs","node","hasCleanup","cleanups","map","cleanup","i","length","useComposedRefs","d","useEffect","hasOwnProperty","prototype","shallowEqual","ue","objA","objB","is","Array","isArray","some","vVal","keysA","keys","keysB","call","defaultHasChanged","p","obj","v","defaultUpdateValue","se","useObjectPropEffect","updateValue","hasChanged","useObjectPropEffect_default","getEnvPlayerVersion","ye","player_version","getPlayerVersion","g","useEventCallbackEffect","r","type","callback","eventTarget","eventName","listener","addEventListener","removeEventListener","MuxPlayerInternal","forwardRef","children","createElement","suppressHydrationWarning","usePlayer","xe","onAbort","onCanPlay","onCanPlayThrough","onEmptied","onLoadStart","onLoadedData","onLoadedMetadata","onProgress","onDurationChange","onVolumeChange","onRateChange","onResize","onWaiting","onPlay","onPlaying","onTimeUpdate","onPause","onSeeking","onSeeked","onStalled","onSuspend","onEnded","onError","onCuePointChange","onChapterChange","metadata","tokens","paused","playbackId","playbackRates","currentTime","themeProps","extraSourceParams","castCustomData","_hlsConfig","remainingProps","playerEl","pausedVal","pause","play","hasAttribute","hasPlayed","currentTimeVal","playerSoftwareVersion","playerSoftwareName","MuxPlayer","innerPlayerRef","playerRef","playerInitTime","_a","defaultHiddenCaptions","index_default"],"sources":["/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/mux-player-react/src/index.tsx","/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/mux-player-react/src/common/utils.ts","/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/mux-player-react/src/useComposedRefs.ts","/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/mux-player-react/src/useObjectPropEffect.ts","/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/mux-player-react/src/env.ts","/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/mux-player-react/src/useEventCallbackEffect.ts"],"sourcesContent":["'use client';\nimport React, { useState, useRef } from 'react';\nimport { MaxResolution, MinResolution, RenditionOrder, generatePlayerInitTime } from '@mux/playback-core';\nimport { MediaError } from '@mux/mux-player';\nimport type MuxPlayerElement from '@mux/mux-player';\nimport type { MuxPlayerElementEventMap } from '@mux/mux-player';\nimport { toNativeProps } from './common/utils';\nimport { useComposedRefs } from './useComposedRefs';\nimport useObjectPropEffect, { defaultHasChanged } from './useObjectPropEffect';\nimport { getPlayerVersion } from './env';\nimport { useEventCallbackEffect } from './useEventCallbackEffect';\nimport type { MuxPlayerProps, MuxPlayerRefAttributes } from './types';\n\nexport { MediaError, MaxResolution, MinResolution, RenditionOrder, generatePlayerInitTime };\nexport * from './types';\n\nconst MuxPlayerInternal = React.forwardRef<MuxPlayerRefAttributes, MuxPlayerProps>(({ children, ...props }, ref) => {\n  return React.createElement(\n    'mux-player',\n    {\n      suppressHydrationWarning: true, // prevent issues with SSR / player-init-time\n      ...toNativeProps(props),\n      ref,\n    },\n    children\n  );\n});\n\nconst usePlayer = (\n  ref: // | ((instance: EventTarget | null) => void)\n  React.MutableRefObject<MuxPlayerElement | null> | null | undefined,\n  props: MuxPlayerProps\n) => {\n  const {\n    onAbort,\n    onCanPlay,\n    onCanPlayThrough,\n    onEmptied,\n    onLoadStart,\n    onLoadedData,\n    onLoadedMetadata,\n    onProgress,\n    onDurationChange,\n    onVolumeChange,\n    onRateChange,\n    onResize,\n    onWaiting,\n    onPlay,\n    onPlaying,\n    onTimeUpdate,\n    onPause,\n    onSeeking,\n    onSeeked,\n    onStalled,\n    onSuspend,\n    onEnded,\n    onError,\n    onCuePointChange,\n    onChapterChange,\n    metadata,\n    tokens,\n    paused,\n    playbackId,\n    playbackRates,\n    currentTime,\n    themeProps,\n    extraSourceParams,\n    castCustomData,\n    _hlsConfig,\n    ...remainingProps\n  } = props;\n  /**\n   * @TODO We need to have some better modeling/architecture around order effects. We should also revisit our mapping of media-request-related props\n   * all to `src` in our template code. For now, moving tokens before playbackId, as there are timing issues that happen if we set it after playbackId (CJP)\n   **/\n  useObjectPropEffect('tokens', tokens, ref);\n  // NOTE: We should set playbackId before all other props to ensure that any playback/view session-specific props are applied to the approrpiate\n  // session. \"Under the hood,\" we wait one frame before (re)initializing playback core (and thus e.g. hls.js and mux-embed data sdk), so everything\n  // should be applied as expected as a result.\n  useObjectPropEffect('playbackId', playbackId, ref);\n  useObjectPropEffect('playbackRates', playbackRates, ref);\n  useObjectPropEffect('metadata', metadata, ref);\n  useObjectPropEffect('extraSourceParams', extraSourceParams, ref);\n  useObjectPropEffect('_hlsConfig', _hlsConfig, ref);\n  useObjectPropEffect('themeProps', themeProps, ref);\n  useObjectPropEffect('castCustomData', castCustomData, ref);\n  useObjectPropEffect(\n    'paused',\n    paused,\n    ref,\n    (playerEl: HTMLMediaElement, pausedVal?: boolean) => {\n      if (pausedVal == null) return;\n      if (pausedVal) {\n        playerEl.pause();\n      } else {\n        playerEl.play();\n      }\n    },\n    (playerEl, value, propName) => {\n      if (playerEl.hasAttribute('autoplay') && !playerEl.hasPlayed) {\n        return false;\n      }\n      return defaultHasChanged(playerEl, value, propName);\n    }\n  );\n  useObjectPropEffect('currentTime', currentTime, ref, (playerEl: HTMLMediaElement, currentTimeVal?: number) => {\n    if (currentTimeVal == null) return;\n    playerEl.currentTime = currentTimeVal;\n  });\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('abort', ref, onAbort);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('canplay', ref, onCanPlay);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('canplaythrough', ref, onCanPlayThrough);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('emptied', ref, onEmptied);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('loadstart', ref, onLoadStart);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('loadeddata', ref, onLoadedData);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('loadedmetadata', ref, onLoadedMetadata);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('progress', ref, onProgress);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('durationchange', ref, onDurationChange);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('volumechange', ref, onVolumeChange);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('ratechange', ref, onRateChange);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('resize', ref, onResize);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('waiting', ref, onWaiting);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('play', ref, onPlay);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('playing', ref, onPlaying);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('timeupdate', ref, onTimeUpdate);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('pause', ref, onPause);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('seeking', ref, onSeeking);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('seeked', ref, onSeeked);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('stalled', ref, onStalled);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('suspend', ref, onSuspend);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('ended', ref, onEnded);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('error', ref, onError);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('cuepointchange', ref, onCuePointChange);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('chapterchange', ref, onChapterChange);\n  return [remainingProps];\n};\n\nexport const playerSoftwareVersion = getPlayerVersion();\nexport const playerSoftwareName = 'mux-player-react';\n\nconst MuxPlayer = React.forwardRef<\n  MuxPlayerRefAttributes,\n  Omit<MuxPlayerProps, 'playerSoftwareVersion' | 'playerSoftwareName'>\n>((props, ref) => {\n  const innerPlayerRef = useRef<MuxPlayerElement>(null);\n  const playerRef = useComposedRefs(innerPlayerRef, ref);\n  const [remainingProps] = usePlayer(innerPlayerRef, props);\n  const [playerInitTime] = useState(props.playerInitTime ?? generatePlayerInitTime());\n\n  return (\n    <MuxPlayerInternal\n      /** @TODO Fix types relationships (CJP) */\n      ref={playerRef as React.Ref<MuxPlayerElement>}\n      defaultHiddenCaptions={props.defaultHiddenCaptions}\n      playerSoftwareName={playerSoftwareName}\n      playerSoftwareVersion={playerSoftwareVersion}\n      playerInitTime={playerInitTime}\n      {...remainingProps}\n    />\n  );\n});\n\nexport default MuxPlayer;\n","import React from 'react';\n\n// React 19 supports custom elements and setting properties directly on them,\n// older React versions converted all props to attributes on custom elments.\n// Boolean `true` values should not be converted to empty strings in React 19+\n// because that would result in a `false` value if it was set via a property.\n// React 19+ handles primitive values correctly but we still need to convert\n// the camelCase prop names to kebab-case attribute names for mux-player. (WL)\n\nconst IS_REACT_19_OR_NEWER = parseInt(React.version) >= 19;\n\n// NOTE: As a forward-looking implementation, we may want to assume\n// prop names -> attribute names is always a simple name.toLowerCase()\n// and provide a mechanism for passing in per-component overrides for\n// e.g. kebab cases, as that's the way React/Preact handles these. (CJP)\nconst ReactPropToAttrNameMap = {\n  className: 'class',\n  classname: 'class',\n  htmlFor: 'for',\n  crossOrigin: 'crossorigin',\n  viewBox: 'viewBox',\n  playsInline: 'playsinline',\n  autoPlay: 'autoplay',\n  playbackRate: 'playbackrate',\n};\n\ntype KeyTypes = string | number | symbol;\ntype Maybe<T> = T | null | undefined;\n\nexport const isNil = (x: unknown): x is null | undefined => x == undefined;\n\n// Type Guard to determine if a given key is actually a key of some object of type T\nexport const isKeyOf = <T extends object = any>(k: KeyTypes, o: Maybe<T>): k is keyof T => {\n  if (isNil(o)) return false;\n  return k in o;\n};\n\nconst toKebabCase = (string: string) => string.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);\n\nexport const toNativeAttrName = (propName: string, propValue: any): string | undefined => {\n  if (!IS_REACT_19_OR_NEWER && typeof propValue === 'boolean' && !propValue) return undefined;\n  if (isKeyOf(propName, ReactPropToAttrNameMap)) return ReactPropToAttrNameMap[propName];\n  if (typeof propValue === 'undefined') return undefined;\n  if (/[A-Z]/.test(propName)) return toKebabCase(propName);\n  return propName;\n};\nexport const toStyleAttr = <T>(x: T) => x;\n\nexport const toNativeAttrValue = (propValue: any, _propName: string) => {\n  if (!IS_REACT_19_OR_NEWER && typeof propValue === 'boolean') return '';\n  return propValue;\n};\n\nexport const toNativeProps = (props: { ref?: any; [key: string]: any } = {}) => {\n  const { ref, ...restProps } = props;\n  return Object.entries(restProps).reduce<{ [k: string]: string }>((transformedProps, [propName, propValue]) => {\n    const attrName = toNativeAttrName(propName, propValue);\n\n    // prop was stripped. Don't add.\n    if (!attrName) {\n      return transformedProps;\n    }\n\n    const attrValue = toNativeAttrValue(propValue, propName);\n    transformedProps[attrName] = attrValue;\n    return transformedProps;\n  }, {});\n};\n","import * as React from 'react';\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T): (() => void) | void | undefined {\n  if (typeof ref === 'function') {\n    return ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    (ref as React.MutableRefObject<T>).current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup == 'function') {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup == 'function') {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n","import { useEffect } from 'react';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Slightly modified version of React's shallowEqual, with optimizations for Arrays\n * so we may treat them specifically as unequal if they are not a) both arrays\n * or b) don't contain the same (shallowly compared) elements.\n */\nconst shallowEqual = (objA: any, objB: any): boolean => {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  if (Array.isArray(objA)) {\n    // Early \"cheap\" array compares\n    if (!Array.isArray(objB) || objA.length !== objB.length) return false;\n    // Shallow compare for arrays\n    return objA.some((vVal, i) => objB[i] === vVal);\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (let i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexport const defaultHasChanged = (obj: any, v: any, k: string) => {\n  return !shallowEqual(v, obj[k]);\n};\n\nconst defaultUpdateValue = (obj: any, v: any, k: string) => {\n  obj[k] = v;\n};\n\nexport const useObjectPropEffect = <T extends { [k: string]: any }, V>(\n  propName: string,\n  propValue: V | null | undefined,\n  ref: React.MutableRefObject<T | null> | null | undefined,\n  updateValue = defaultUpdateValue,\n  hasChanged = defaultHasChanged\n) => {\n  return useEffect(() => {\n    const obj = ref?.current;\n    if (!obj) return;\n    if (!hasChanged(obj, propValue, propName)) return;\n    updateValue(obj, propValue, propName);\n  }, [ref?.current, propValue]);\n};\n\nexport default useObjectPropEffect;\n","const getEnvPlayerVersion = () => {\n  try {\n    // @ts-ignore\n    return PLAYER_VERSION as string;\n  } catch {}\n  return 'UNKNOWN';\n};\n\nconst player_version: string = getEnvPlayerVersion();\n\nexport const getPlayerVersion = () => player_version;\n","import React, { useEffect } from 'react';\nimport type { GenericEventListener } from './index';\n\nexport const useEventCallbackEffect = <\n  TElement extends EventTarget = EventTarget,\n  TEventMap extends Record<string, Event> = Record<string, Event>,\n  K extends keyof TEventMap = keyof TEventMap,\n>(\n  type: K,\n  ref: // | ((instance: EventTarget | null) => void)\n  React.MutableRefObject<TElement | null> | null | undefined,\n  callback: GenericEventListener<TEventMap[K]> | undefined\n) => {\n  return useEffect(() => {\n    const eventTarget = ref?.current;\n    if (!eventTarget || !callback) return;\n\n    // Type assertion needed because TypeScript can't infer the exact event type\n    const eventName = type as string;\n    const listener = callback as EventListener;\n\n    eventTarget.addEventListener(eventName, listener);\n    return () => {\n      eventTarget.removeEventListener(eventName, listener);\n    };\n  }, [ref?.current, callback, type]);\n};\n"]},"metadata":{},"sourceType":"module"}