{"ast":null,"code":"const Events = [\"abort\", \"canplay\", \"canplaythrough\", \"durationchange\", \"emptied\", \"encrypted\", \"ended\", \"error\", \"loadeddata\", \"loadedmetadata\", \"loadstart\", \"pause\", \"play\", \"playing\", \"progress\", \"ratechange\", \"seeked\", \"seeking\", \"stalled\", \"suspend\", \"timeupdate\", \"volumechange\", \"waiting\", \"waitingforkey\", \"resize\", \"enterpictureinpicture\", \"leavepictureinpicture\", \"webkitbeginfullscreen\", \"webkitendfullscreen\", \"webkitpresentationmodechanged\"];\nconst Attributes = [\"autopictureinpicture\", \"disablepictureinpicture\", \"disableremoteplayback\", \"autoplay\", \"controls\", \"controlslist\", \"crossorigin\", \"loop\", \"muted\", \"playsinline\", \"poster\", \"preload\", \"src\"];\nfunction getAudioTemplateHTML(attrs) {\n  return /*html*/`\n    <style>\n      :host {\n        display: inline-flex;\n        line-height: 0;\n        flex-direction: column;\n        justify-content: end;\n      }\n\n      audio {\n        width: 100%;\n      }\n    </style>\n    <slot name=\"media\">\n      <audio${serializeAttributes(attrs)}></audio>\n    </slot>\n    <slot></slot>\n  `;\n}\nfunction getVideoTemplateHTML(attrs) {\n  return /*html*/`\n    <style>\n      :host {\n        display: inline-block;\n        line-height: 0;\n      }\n\n      video {\n        max-width: 100%;\n        max-height: 100%;\n        min-width: 100%;\n        min-height: 100%;\n        object-fit: var(--media-object-fit, contain);\n        object-position: var(--media-object-position, 50% 50%);\n      }\n\n      video::-webkit-media-text-track-container {\n        transform: var(--media-webkit-text-track-transform);\n        transition: var(--media-webkit-text-track-transition);\n      }\n    </style>\n    <slot name=\"media\">\n      <video${serializeAttributes(attrs)}></video>\n    </slot>\n    <slot></slot>\n  `;\n}\nfunction CustomMediaMixin(superclass, _ref) {\n  var _globalThis$document, _globalThis$document$;\n  let {\n    tag,\n    is\n  } = _ref;\n  const nativeElTest = (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : (_globalThis$document$ = _globalThis$document.createElement) === null || _globalThis$document$ === void 0 ? void 0 : _globalThis$document$.call(_globalThis$document, tag, {\n    is\n  });\n  const nativeElProps = nativeElTest ? getNativeElProps(nativeElTest) : [];\n  return class CustomMedia extends superclass {\n    static getTemplateHTML = tag.endsWith(\"audio\") ? getAudioTemplateHTML : getVideoTemplateHTML;\n    static shadowRootOptions = {\n      mode: \"open\"\n    };\n    static Events = Events;\n    static #isDefined = false;\n    static get observedAttributes() {\n      var _nativeElTest$constru;\n      CustomMedia.#define();\n      const natAttrs = (nativeElTest === null || nativeElTest === void 0 ? void 0 : (_nativeElTest$constru = nativeElTest.constructor) === null || _nativeElTest$constru === void 0 ? void 0 : _nativeElTest$constru.observedAttributes) ?? [];\n      return [...natAttrs, ...Attributes];\n    }\n    static #define() {\n      if (this.#isDefined) return;\n      this.#isDefined = true;\n      const propsToAttrs = new Set(this.observedAttributes);\n      propsToAttrs.delete(\"muted\");\n      for (const prop of nativeElProps) {\n        if (prop in this.prototype) continue;\n        if (typeof nativeElTest[prop] === \"function\") {\n          this.prototype[prop] = function () {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n            this.#init();\n            const fn = () => {\n              var _this$nativeEl;\n              if (this.call) return this.call(prop, ...args);\n              const nativeFn = (_this$nativeEl = this.nativeEl) === null || _this$nativeEl === void 0 ? void 0 : _this$nativeEl[prop];\n              return nativeFn === null || nativeFn === void 0 ? void 0 : nativeFn.apply(this.nativeEl, args);\n            };\n            return fn();\n          };\n        } else {\n          const config = {\n            get() {\n              var _this$get, _this$nativeEl2;\n              this.#init();\n              const attr = prop.toLowerCase();\n              if (propsToAttrs.has(attr)) {\n                const val = this.getAttribute(attr);\n                return val === null ? false : val === \"\" ? true : val;\n              }\n              return ((_this$get = this.get) === null || _this$get === void 0 ? void 0 : _this$get.call(this, prop)) ?? ((_this$nativeEl2 = this.nativeEl) === null || _this$nativeEl2 === void 0 ? void 0 : _this$nativeEl2[prop]);\n            }\n          };\n          if (prop !== prop.toUpperCase()) {\n            config.set = function (val) {\n              this.#init();\n              const attr = prop.toLowerCase();\n              if (propsToAttrs.has(attr)) {\n                if (val === true || val === false || val == null) {\n                  this.toggleAttribute(attr, Boolean(val));\n                } else {\n                  this.setAttribute(attr, val);\n                }\n                return;\n              }\n              if (this.set) {\n                this.set(prop, val);\n                return;\n              }\n              if (this.nativeEl) {\n                this.nativeEl[prop] = val;\n              }\n            };\n          }\n          Object.defineProperty(this.prototype, prop, config);\n        }\n      }\n    }\n    // Private fields\n    #isInit = false;\n    #nativeEl = null;\n    #childMap = /* @__PURE__ */new Map();\n    #childObserver;\n    get;\n    set;\n    call;\n    // If the custom element is defined before the custom element's HTML is parsed\n    // no attributes will be available in the constructor (construction process).\n    // Wait until initializing in the attributeChangedCallback or\n    // connectedCallback or accessing any properties.\n    get nativeEl() {\n      var _this$shadowRoot;\n      this.#init();\n      return this.#nativeEl ?? this.querySelector(\":scope > [slot=media]\") ?? this.querySelector(tag) ?? ((_this$shadowRoot = this.shadowRoot) === null || _this$shadowRoot === void 0 ? void 0 : _this$shadowRoot.querySelector(tag)) ?? null;\n    }\n    set nativeEl(val) {\n      this.#nativeEl = val;\n    }\n    get defaultMuted() {\n      return this.hasAttribute(\"muted\");\n    }\n    set defaultMuted(val) {\n      this.toggleAttribute(\"muted\", val);\n    }\n    get src() {\n      return this.getAttribute(\"src\");\n    }\n    set src(val) {\n      this.setAttribute(\"src\", `${val}`);\n    }\n    get preload() {\n      var _this$nativeEl3;\n      return this.getAttribute(\"preload\") ?? ((_this$nativeEl3 = this.nativeEl) === null || _this$nativeEl3 === void 0 ? void 0 : _this$nativeEl3.preload);\n    }\n    set preload(val) {\n      this.setAttribute(\"preload\", `${val}`);\n    }\n    #init() {\n      if (this.#isInit) return;\n      this.#isInit = true;\n      this.init();\n    }\n    init() {\n      if (!this.shadowRoot) {\n        this.attachShadow({\n          mode: \"open\"\n        });\n        const attrs = namedNodeMapToObject(this.attributes);\n        if (is) attrs.is = is;\n        if (tag) attrs.part = tag;\n        this.shadowRoot.innerHTML = this.constructor.getTemplateHTML(attrs);\n      }\n      this.nativeEl.muted = this.hasAttribute(\"muted\");\n      for (const prop of nativeElProps) {\n        this.#upgradeProperty(prop);\n      }\n      this.#childObserver = new MutationObserver(this.#syncMediaChildAttribute.bind(this));\n      this.shadowRoot.addEventListener(\"slotchange\", () => this.#syncMediaChildren());\n      this.#syncMediaChildren();\n      for (const type of this.constructor.Events) {\n        this.shadowRoot.addEventListener(type, this, true);\n      }\n    }\n    handleEvent(event) {\n      if (event.target === this.nativeEl) {\n        this.dispatchEvent(new CustomEvent(event.type, {\n          detail: event.detail\n        }));\n      }\n    }\n    #syncMediaChildren() {\n      var _this$shadowRoot2;\n      const removeNativeChildren = new Map(this.#childMap);\n      const defaultSlot = (_this$shadowRoot2 = this.shadowRoot) === null || _this$shadowRoot2 === void 0 ? void 0 : _this$shadowRoot2.querySelector(\"slot:not([name])\");\n      const mediaChildren = defaultSlot === null || defaultSlot === void 0 ? void 0 : defaultSlot.assignedElements({\n        flatten: true\n      }).filter(el => [\"track\", \"source\"].includes(el.localName));\n      mediaChildren.forEach(el => {\n        var _this$nativeEl4;\n        removeNativeChildren.delete(el);\n        let clone = this.#childMap.get(el);\n        if (!clone) {\n          var _this$childObserver;\n          clone = el.cloneNode();\n          this.#childMap.set(el, clone);\n          (_this$childObserver = this.#childObserver) === null || _this$childObserver === void 0 ? void 0 : _this$childObserver.observe(el, {\n            attributes: true\n          });\n        }\n        (_this$nativeEl4 = this.nativeEl) === null || _this$nativeEl4 === void 0 ? void 0 : _this$nativeEl4.append(clone);\n        this.#enableDefaultTrack(clone);\n      });\n      removeNativeChildren.forEach((clone, el) => {\n        clone.remove();\n        this.#childMap.delete(el);\n      });\n    }\n    #syncMediaChildAttribute(mutations) {\n      for (const mutation of mutations) {\n        if (mutation.type === \"attributes\") {\n          const {\n            target,\n            attributeName\n          } = mutation;\n          const clone = this.#childMap.get(target);\n          if (clone && attributeName) {\n            clone.setAttribute(attributeName, target.getAttribute(attributeName) ?? \"\");\n            this.#enableDefaultTrack(clone);\n          }\n        }\n      }\n    }\n    #enableDefaultTrack(trackEl) {\n      if (trackEl && trackEl.localName === \"track\" && trackEl.default && (trackEl.kind === \"chapters\" || trackEl.kind === \"metadata\") && trackEl.track.mode === \"disabled\") {\n        trackEl.track.mode = \"hidden\";\n      }\n    }\n    #upgradeProperty(prop) {\n      if (Object.prototype.hasOwnProperty.call(this, prop)) {\n        const value = this[prop];\n        delete this[prop];\n        this[prop] = value;\n      }\n    }\n    attributeChangedCallback(attrName, oldValue, newValue) {\n      this.#init();\n      this.#forwardAttribute(attrName, oldValue, newValue);\n    }\n    #forwardAttribute(attrName, _oldValue, newValue) {\n      var _this$nativeEl6;\n      if ([\"id\", \"class\"].includes(attrName)) return;\n      if (!CustomMedia.observedAttributes.includes(attrName) && this.constructor.observedAttributes.includes(attrName)) {\n        return;\n      }\n      if (newValue === null) {\n        var _this$nativeEl5;\n        (_this$nativeEl5 = this.nativeEl) === null || _this$nativeEl5 === void 0 ? void 0 : _this$nativeEl5.removeAttribute(attrName);\n      } else if (((_this$nativeEl6 = this.nativeEl) === null || _this$nativeEl6 === void 0 ? void 0 : _this$nativeEl6.getAttribute(attrName)) !== newValue) {\n        var _this$nativeEl7;\n        (_this$nativeEl7 = this.nativeEl) === null || _this$nativeEl7 === void 0 ? void 0 : _this$nativeEl7.setAttribute(attrName, newValue);\n      }\n    }\n    connectedCallback() {\n      this.#init();\n    }\n  };\n}\nfunction getNativeElProps(nativeElTest) {\n  const nativeElProps = [];\n  for (let proto = Object.getPrototypeOf(nativeElTest); proto && proto !== HTMLElement.prototype; proto = Object.getPrototypeOf(proto)) {\n    const props = Object.getOwnPropertyNames(proto);\n    nativeElProps.push(...props);\n  }\n  return nativeElProps;\n}\nfunction serializeAttributes(attrs) {\n  let html = \"\";\n  for (const key in attrs) {\n    if (!Attributes.includes(key)) continue;\n    const value = attrs[key];\n    if (value === \"\") html += ` ${key}`;else html += ` ${key}=\"${value}\"`;\n  }\n  return html;\n}\nfunction namedNodeMapToObject(namedNodeMap) {\n  const obj = {};\n  for (const attr of namedNodeMap) {\n    obj[attr.name] = attr.value;\n  }\n  return obj;\n}\nconst CustomVideoElement = CustomMediaMixin(globalThis.HTMLElement ?? class {}, {\n  tag: \"video\"\n});\nconst CustomAudioElement = CustomMediaMixin(globalThis.HTMLElement ?? class {}, {\n  tag: \"audio\"\n});\nexport { Attributes, CustomAudioElement, CustomMediaMixin, CustomVideoElement, Events };","map":null,"metadata":{},"sourceType":"module"}