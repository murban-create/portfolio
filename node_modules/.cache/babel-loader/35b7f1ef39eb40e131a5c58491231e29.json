{"ast":null,"code":"/* global chrome */\nimport { RemotePlayback } from './castable-remote-playback.js';\nimport { privateProps, requiresCastFramework, loadCastFramework, currentSession, getDefaultCastOptions, isHls, getPlaylistSegmentFormat } from './castable-utils.js';\n\n/**\n * CastableMediaMixin\n *\n * This mixin function provides a way to compose multiple classes.\n * @see https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/\n *\n * @param  {HTMLMediaElement} superclass - HTMLMediaElement or an extended class of it.\n * @return {CastableMedia}\n */\nexport const CastableMediaMixin = superclass => class CastableMedia extends superclass {\n  static observedAttributes = [...(superclass.observedAttributes ?? []), 'cast-src', 'cast-content-type', 'cast-stream-type', 'cast-receiver'];\n  #localState = {\n    paused: false\n  };\n  #castOptions = getDefaultCastOptions();\n  #castCustomData;\n  #remote;\n  get remote() {\n    if (this.#remote) return this.#remote;\n    if (requiresCastFramework()) {\n      // No need to load the Cast framework if it's disabled.\n      if (!this.disableRemotePlayback) {\n        loadCastFramework();\n      }\n      privateProps.set(this, {\n        loadOnPrompt: () => this.#loadOnPrompt()\n      });\n      return this.#remote = new RemotePlayback(this);\n    }\n    return super.remote;\n  }\n  get #castPlayer() {\n    var _privateProps$get, _privateProps$get$get;\n    return (_privateProps$get = privateProps.get(this.remote)) === null || _privateProps$get === void 0 ? void 0 : (_privateProps$get$get = _privateProps$get.getCastPlayer) === null || _privateProps$get$get === void 0 ? void 0 : _privateProps$get$get.call(_privateProps$get);\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n    if (attrName === 'cast-receiver' && newValue) {\n      this.#castOptions.receiverApplicationId = newValue;\n      return;\n    }\n    if (!this.#castPlayer) return;\n    switch (attrName) {\n      case 'cast-stream-type':\n      case 'cast-src':\n        this.load();\n        break;\n    }\n  }\n  async #loadOnPrompt() {\n    // Pause locally when the session is created.\n    this.#localState.paused = super.paused;\n    super.pause();\n\n    // Sync over the muted state but not volume, 100% is different on TV's :P\n    this.muted = super.muted;\n    try {\n      await this.load();\n    } catch (err) {\n      console.error(err);\n    }\n  }\n  async load() {\n    var _currentSession;\n    if (!this.#castPlayer) return super.load();\n    const mediaInfo = new chrome.cast.media.MediaInfo(this.castSrc, this.castContentType);\n    mediaInfo.customData = this.castCustomData;\n\n    // Manually add text tracks with a `src` attribute.\n    // M3U8's load text tracks in the receiver, handle these in the media loaded event.\n    const subtitles = [...this.querySelectorAll('track')].filter(_ref => {\n      let {\n        kind,\n        src\n      } = _ref;\n      return src && (kind === 'subtitles' || kind === 'captions');\n    });\n    const activeTrackIds = [];\n    let textTrackIdCount = 0;\n    if (subtitles.length) {\n      mediaInfo.tracks = subtitles.map(trackEl => {\n        const trackId = ++textTrackIdCount;\n        // only activate 1 subtitle text track.\n        if (activeTrackIds.length === 0 && trackEl.track.mode === 'showing') {\n          activeTrackIds.push(trackId);\n        }\n        const track = new chrome.cast.media.Track(trackId, chrome.cast.media.TrackType.TEXT);\n        track.trackContentId = trackEl.src;\n        track.trackContentType = 'text/vtt';\n        track.subtype = trackEl.kind === 'captions' ? chrome.cast.media.TextTrackType.CAPTIONS : chrome.cast.media.TextTrackType.SUBTITLES;\n        track.name = trackEl.label;\n        track.language = trackEl.srclang;\n        return track;\n      });\n    }\n    if (this.castStreamType === 'live') {\n      mediaInfo.streamType = chrome.cast.media.StreamType.LIVE;\n    } else {\n      mediaInfo.streamType = chrome.cast.media.StreamType.BUFFERED;\n    }\n    mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();\n    mediaInfo.metadata.title = this.title;\n    mediaInfo.metadata.images = [{\n      url: this.poster\n    }];\n    if (isHls(this.castSrc)) {\n      const segmentFormat = await getPlaylistSegmentFormat(this.castSrc);\n      const isFragmentedMP4 = (segmentFormat === null || segmentFormat === void 0 ? void 0 : segmentFormat.includes('m4s')) || (segmentFormat === null || segmentFormat === void 0 ? void 0 : segmentFormat.includes('mp4'));\n      if (isFragmentedMP4) {\n        mediaInfo.hlsSegmentFormat = chrome.cast.media.HlsSegmentFormat.FMP4;\n        mediaInfo.hlsVideoSegmentFormat = chrome.cast.media.HlsVideoSegmentFormat.FMP4;\n      }\n    }\n    const request = new chrome.cast.media.LoadRequest(mediaInfo);\n    request.currentTime = super.currentTime ?? 0;\n    request.autoplay = !this.#localState.paused;\n    request.activeTrackIds = activeTrackIds;\n    await ((_currentSession = currentSession()) === null || _currentSession === void 0 ? void 0 : _currentSession.loadMedia(request));\n    this.dispatchEvent(new Event('volumechange'));\n  }\n  play() {\n    if (this.#castPlayer) {\n      if (this.#castPlayer.isPaused) {\n        var _this$castPlayer$cont;\n        (_this$castPlayer$cont = this.#castPlayer.controller) === null || _this$castPlayer$cont === void 0 ? void 0 : _this$castPlayer$cont.playOrPause();\n      }\n      return;\n    }\n    return super.play();\n  }\n  pause() {\n    if (this.#castPlayer) {\n      if (!this.#castPlayer.isPaused) {\n        var _this$castPlayer$cont2;\n        (_this$castPlayer$cont2 = this.#castPlayer.controller) === null || _this$castPlayer$cont2 === void 0 ? void 0 : _this$castPlayer$cont2.playOrPause();\n      }\n      return;\n    }\n    super.pause();\n  }\n\n  /**\n   * @see https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastOptions\n   * @readonly\n   *\n   * @typedef {Object} CastOptions\n   * @property {string} [receiverApplicationId='CC1AD845'] - The app id of the cast receiver.\n   * @property {string} [autoJoinPolicy='origin_scoped'] - The auto join policy.\n   * @property {string} [language='en-US'] - The language to use for the cast receiver.\n   * @property {boolean} [androidReceiverCompatible=false] - Whether to use the Cast Connect.\n   * @property {boolean} [resumeSavedSession=true] - Whether to resume the last session.\n   *\n   * @return {CastOptions}\n   */\n  get castOptions() {\n    return this.#castOptions;\n  }\n  get castReceiver() {\n    return this.getAttribute('cast-receiver') ?? undefined;\n  }\n  set castReceiver(val) {\n    if (this.castReceiver == val) return;\n    this.setAttribute('cast-receiver', `${val}`);\n  }\n\n  // Allow the cast source url to be different than <video src>, could be a blob.\n  get castSrc() {\n    var _this$querySelector;\n    // Try the first <source src> for usage with even more native markup.\n    return this.getAttribute('cast-src') ?? ((_this$querySelector = this.querySelector('source')) === null || _this$querySelector === void 0 ? void 0 : _this$querySelector.src) ?? this.currentSrc;\n  }\n  set castSrc(val) {\n    if (this.castSrc == val) return;\n    this.setAttribute('cast-src', `${val}`);\n  }\n  get castContentType() {\n    return this.getAttribute('cast-content-type') ?? undefined;\n  }\n  set castContentType(val) {\n    this.setAttribute('cast-content-type', `${val}`);\n  }\n  get castStreamType() {\n    // NOTE: Per https://github.com/video-dev/media-ui-extensions/issues/3 `streamType` may yield `\"unknown\"`\n    return this.getAttribute('cast-stream-type') ?? this.streamType ?? undefined;\n  }\n  set castStreamType(val) {\n    this.setAttribute('cast-stream-type', `${val}`);\n  }\n  get castCustomData() {\n    return this.#castCustomData;\n  }\n  set castCustomData(val) {\n    const valType = typeof val;\n    if (!['object', 'undefined'].includes(valType)) {\n      console.error(`castCustomData must be nullish or an object but value was of type ${valType}`);\n      return;\n    }\n    this.#castCustomData = val;\n  }\n  get readyState() {\n    if (this.#castPlayer) {\n      switch (this.#castPlayer.playerState) {\n        case chrome.cast.media.PlayerState.IDLE:\n          return 0;\n        case chrome.cast.media.PlayerState.BUFFERING:\n          return 2;\n        default:\n          return 3;\n      }\n    }\n    return super.readyState;\n  }\n  get paused() {\n    if (this.#castPlayer) return this.#castPlayer.isPaused;\n    return super.paused;\n  }\n  get muted() {\n    var _this$castPlayer;\n    if (this.#castPlayer) return (_this$castPlayer = this.#castPlayer) === null || _this$castPlayer === void 0 ? void 0 : _this$castPlayer.isMuted;\n    return super.muted;\n  }\n  set muted(val) {\n    if (this.#castPlayer) {\n      if (val && !this.#castPlayer.isMuted || !val && this.#castPlayer.isMuted) {\n        var _this$castPlayer$cont3;\n        (_this$castPlayer$cont3 = this.#castPlayer.controller) === null || _this$castPlayer$cont3 === void 0 ? void 0 : _this$castPlayer$cont3.muteOrUnmute();\n      }\n      return;\n    }\n    super.muted = val;\n  }\n  get volume() {\n    var _this$castPlayer2;\n    if (this.#castPlayer) return ((_this$castPlayer2 = this.#castPlayer) === null || _this$castPlayer2 === void 0 ? void 0 : _this$castPlayer2.volumeLevel) ?? 1;\n    return super.volume;\n  }\n  set volume(val) {\n    if (this.#castPlayer) {\n      var _this$castPlayer$cont4;\n      this.#castPlayer.volumeLevel = +val;\n      (_this$castPlayer$cont4 = this.#castPlayer.controller) === null || _this$castPlayer$cont4 === void 0 ? void 0 : _this$castPlayer$cont4.setVolumeLevel();\n      return;\n    }\n    super.volume = val;\n  }\n  get duration() {\n    var _this$castPlayer3;\n    // castPlayer duration returns `0` when no media is loaded.\n    if (this.#castPlayer && (_this$castPlayer3 = this.#castPlayer) !== null && _this$castPlayer3 !== void 0 && _this$castPlayer3.isMediaLoaded) {\n      var _this$castPlayer4;\n      return ((_this$castPlayer4 = this.#castPlayer) === null || _this$castPlayer4 === void 0 ? void 0 : _this$castPlayer4.duration) ?? NaN;\n    }\n    return super.duration;\n  }\n  get currentTime() {\n    var _this$castPlayer5;\n    if (this.#castPlayer && (_this$castPlayer5 = this.#castPlayer) !== null && _this$castPlayer5 !== void 0 && _this$castPlayer5.isMediaLoaded) {\n      var _this$castPlayer6;\n      return ((_this$castPlayer6 = this.#castPlayer) === null || _this$castPlayer6 === void 0 ? void 0 : _this$castPlayer6.currentTime) ?? 0;\n    }\n    return super.currentTime;\n  }\n  set currentTime(val) {\n    if (this.#castPlayer) {\n      var _this$castPlayer$cont5;\n      this.#castPlayer.currentTime = val;\n      (_this$castPlayer$cont5 = this.#castPlayer.controller) === null || _this$castPlayer$cont5 === void 0 ? void 0 : _this$castPlayer$cont5.seek();\n      return;\n    }\n    super.currentTime = val;\n  }\n};\nexport const CastableVideoMixin = CastableMediaMixin;","map":null,"metadata":{},"sourceType":"module"}