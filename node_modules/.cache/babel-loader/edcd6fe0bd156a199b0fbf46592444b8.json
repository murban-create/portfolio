{"ast":null,"code":"/* global chrome */\nimport { RemotePlayback } from './castable-remote-playback.js';\nimport { privateProps, requiresCastFramework, loadCastFramework, currentSession, getDefaultCastOptions, isHls, getPlaylistSegmentFormat } from './castable-utils.js';\n\n/**\n * CastableMediaMixin\n *\n * This mixin function provides a way to compose multiple classes.\n * @see https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/\n *\n * @param  {HTMLMediaElement} superclass - HTMLMediaElement or an extended class of it.\n * @return {CastableMedia}\n */\nexport const CastableMediaMixin = superclass => class CastableMedia extends superclass {\n  static observedAttributes = [...(superclass.observedAttributes ?? []), 'cast-src', 'cast-content-type', 'cast-stream-type', 'cast-receiver'];\n  #localState = {\n    paused: false\n  };\n  #castOptions = getDefaultCastOptions();\n  #castCustomData;\n  #remote;\n  get remote() {\n    if (this.#remote) return this.#remote;\n    if (requiresCastFramework()) {\n      // No need to load the Cast framework if it's disabled.\n      if (!this.disableRemotePlayback) {\n        loadCastFramework();\n      }\n      privateProps.set(this, {\n        loadOnPrompt: () => this.#loadOnPrompt()\n      });\n      return this.#remote = new RemotePlayback(this);\n    }\n    return super.remote;\n  }\n  get #castPlayer() {\n    var _privateProps$get, _privateProps$get$get;\n    return (_privateProps$get = privateProps.get(this.remote)) === null || _privateProps$get === void 0 ? void 0 : (_privateProps$get$get = _privateProps$get.getCastPlayer) === null || _privateProps$get$get === void 0 ? void 0 : _privateProps$get$get.call(_privateProps$get);\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n    if (attrName === 'cast-receiver' && newValue) {\n      this.#castOptions.receiverApplicationId = newValue;\n      return;\n    }\n    if (!this.#castPlayer) return;\n    switch (attrName) {\n      case 'cast-stream-type':\n      case 'cast-src':\n        this.load();\n        break;\n    }\n  }\n  async #loadOnPrompt() {\n    // Pause locally when the session is created.\n    this.#localState.paused = super.paused;\n    super.pause();\n\n    // Sync over the muted state but not volume, 100% is different on TV's :P\n    this.muted = super.muted;\n    try {\n      await this.load();\n    } catch (err) {\n      console.error(err);\n    }\n  }\n  async load() {\n    var _currentSession;\n    if (!this.#castPlayer) return super.load();\n    const mediaInfo = new chrome.cast.media.MediaInfo(this.castSrc, this.castContentType);\n    mediaInfo.customData = this.castCustomData;\n\n    // Manually add text tracks with a `src` attribute.\n    // M3U8's load text tracks in the receiver, handle these in the media loaded event.\n    const subtitles = [...this.querySelectorAll('track')].filter(_ref => {\n      let {\n        kind,\n        src\n      } = _ref;\n      return src && (kind === 'subtitles' || kind === 'captions');\n    });\n    const activeTrackIds = [];\n    let textTrackIdCount = 0;\n    if (subtitles.length) {\n      mediaInfo.tracks = subtitles.map(trackEl => {\n        const trackId = ++textTrackIdCount;\n        // only activate 1 subtitle text track.\n        if (activeTrackIds.length === 0 && trackEl.track.mode === 'showing') {\n          activeTrackIds.push(trackId);\n        }\n        const track = new chrome.cast.media.Track(trackId, chrome.cast.media.TrackType.TEXT);\n        track.trackContentId = trackEl.src;\n        track.trackContentType = 'text/vtt';\n        track.subtype = trackEl.kind === 'captions' ? chrome.cast.media.TextTrackType.CAPTIONS : chrome.cast.media.TextTrackType.SUBTITLES;\n        track.name = trackEl.label;\n        track.language = trackEl.srclang;\n        return track;\n      });\n    }\n    if (this.castStreamType === 'live') {\n      mediaInfo.streamType = chrome.cast.media.StreamType.LIVE;\n    } else {\n      mediaInfo.streamType = chrome.cast.media.StreamType.BUFFERED;\n    }\n    mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();\n    mediaInfo.metadata.title = this.title;\n    mediaInfo.metadata.images = [{\n      url: this.poster\n    }];\n    if (isHls(this.castSrc)) {\n      const segmentFormat = await getPlaylistSegmentFormat(this.castSrc);\n      const isFragmentedMP4 = (segmentFormat === null || segmentFormat === void 0 ? void 0 : segmentFormat.includes('m4s')) || (segmentFormat === null || segmentFormat === void 0 ? void 0 : segmentFormat.includes('mp4'));\n      if (isFragmentedMP4) {\n        mediaInfo.hlsSegmentFormat = chrome.cast.media.HlsSegmentFormat.FMP4;\n        mediaInfo.hlsVideoSegmentFormat = chrome.cast.media.HlsVideoSegmentFormat.FMP4;\n      }\n    }\n    const request = new chrome.cast.media.LoadRequest(mediaInfo);\n    request.currentTime = super.currentTime ?? 0;\n    request.autoplay = !this.#localState.paused;\n    request.activeTrackIds = activeTrackIds;\n    await ((_currentSession = currentSession()) === null || _currentSession === void 0 ? void 0 : _currentSession.loadMedia(request));\n    this.dispatchEvent(new Event('volumechange'));\n  }\n  play() {\n    if (this.#castPlayer) {\n      if (this.#castPlayer.isPaused) {\n        var _this$castPlayer$cont;\n        (_this$castPlayer$cont = this.#castPlayer.controller) === null || _this$castPlayer$cont === void 0 ? void 0 : _this$castPlayer$cont.playOrPause();\n      }\n      return;\n    }\n    return super.play();\n  }\n  pause() {\n    if (this.#castPlayer) {\n      if (!this.#castPlayer.isPaused) {\n        var _this$castPlayer$cont2;\n        (_this$castPlayer$cont2 = this.#castPlayer.controller) === null || _this$castPlayer$cont2 === void 0 ? void 0 : _this$castPlayer$cont2.playOrPause();\n      }\n      return;\n    }\n    super.pause();\n  }\n\n  /**\n   * @see https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastOptions\n   * @readonly\n   *\n   * @typedef {Object} CastOptions\n   * @property {string} [receiverApplicationId='CC1AD845'] - The app id of the cast receiver.\n   * @property {string} [autoJoinPolicy='origin_scoped'] - The auto join policy.\n   * @property {string} [language='en-US'] - The language to use for the cast receiver.\n   * @property {boolean} [androidReceiverCompatible=false] - Whether to use the Cast Connect.\n   * @property {boolean} [resumeSavedSession=true] - Whether to resume the last session.\n   *\n   * @return {CastOptions}\n   */\n  get castOptions() {\n    return this.#castOptions;\n  }\n  get castReceiver() {\n    return this.getAttribute('cast-receiver') ?? undefined;\n  }\n  set castReceiver(val) {\n    if (this.castReceiver == val) return;\n    this.setAttribute('cast-receiver', `${val}`);\n  }\n\n  // Allow the cast source url to be different than <video src>, could be a blob.\n  get castSrc() {\n    var _this$querySelector;\n    // Try the first <source src> for usage with even more native markup.\n    return this.getAttribute('cast-src') ?? ((_this$querySelector = this.querySelector('source')) === null || _this$querySelector === void 0 ? void 0 : _this$querySelector.src) ?? this.currentSrc;\n  }\n  set castSrc(val) {\n    if (this.castSrc == val) return;\n    this.setAttribute('cast-src', `${val}`);\n  }\n  get castContentType() {\n    return this.getAttribute('cast-content-type') ?? undefined;\n  }\n  set castContentType(val) {\n    this.setAttribute('cast-content-type', `${val}`);\n  }\n  get castStreamType() {\n    // NOTE: Per https://github.com/video-dev/media-ui-extensions/issues/3 `streamType` may yield `\"unknown\"`\n    return this.getAttribute('cast-stream-type') ?? this.streamType ?? undefined;\n  }\n  set castStreamType(val) {\n    this.setAttribute('cast-stream-type', `${val}`);\n  }\n  get castCustomData() {\n    return this.#castCustomData;\n  }\n  set castCustomData(val) {\n    const valType = typeof val;\n    if (!['object', 'undefined'].includes(valType)) {\n      console.error(`castCustomData must be nullish or an object but value was of type ${valType}`);\n      return;\n    }\n    this.#castCustomData = val;\n  }\n  get readyState() {\n    if (this.#castPlayer) {\n      switch (this.#castPlayer.playerState) {\n        case chrome.cast.media.PlayerState.IDLE:\n          return 0;\n        case chrome.cast.media.PlayerState.BUFFERING:\n          return 2;\n        default:\n          return 3;\n      }\n    }\n    return super.readyState;\n  }\n  get paused() {\n    if (this.#castPlayer) return this.#castPlayer.isPaused;\n    return super.paused;\n  }\n  get muted() {\n    var _this$castPlayer;\n    if (this.#castPlayer) return (_this$castPlayer = this.#castPlayer) === null || _this$castPlayer === void 0 ? void 0 : _this$castPlayer.isMuted;\n    return super.muted;\n  }\n  set muted(val) {\n    if (this.#castPlayer) {\n      if (val && !this.#castPlayer.isMuted || !val && this.#castPlayer.isMuted) {\n        var _this$castPlayer$cont3;\n        (_this$castPlayer$cont3 = this.#castPlayer.controller) === null || _this$castPlayer$cont3 === void 0 ? void 0 : _this$castPlayer$cont3.muteOrUnmute();\n      }\n      return;\n    }\n    super.muted = val;\n  }\n  get volume() {\n    var _this$castPlayer2;\n    if (this.#castPlayer) return ((_this$castPlayer2 = this.#castPlayer) === null || _this$castPlayer2 === void 0 ? void 0 : _this$castPlayer2.volumeLevel) ?? 1;\n    return super.volume;\n  }\n  set volume(val) {\n    if (this.#castPlayer) {\n      var _this$castPlayer$cont4;\n      this.#castPlayer.volumeLevel = +val;\n      (_this$castPlayer$cont4 = this.#castPlayer.controller) === null || _this$castPlayer$cont4 === void 0 ? void 0 : _this$castPlayer$cont4.setVolumeLevel();\n      return;\n    }\n    super.volume = val;\n  }\n  get duration() {\n    var _this$castPlayer3;\n    // castPlayer duration returns `0` when no media is loaded.\n    if (this.#castPlayer && (_this$castPlayer3 = this.#castPlayer) !== null && _this$castPlayer3 !== void 0 && _this$castPlayer3.isMediaLoaded) {\n      var _this$castPlayer4;\n      return ((_this$castPlayer4 = this.#castPlayer) === null || _this$castPlayer4 === void 0 ? void 0 : _this$castPlayer4.duration) ?? NaN;\n    }\n    return super.duration;\n  }\n  get currentTime() {\n    var _this$castPlayer5;\n    if (this.#castPlayer && (_this$castPlayer5 = this.#castPlayer) !== null && _this$castPlayer5 !== void 0 && _this$castPlayer5.isMediaLoaded) {\n      var _this$castPlayer6;\n      return ((_this$castPlayer6 = this.#castPlayer) === null || _this$castPlayer6 === void 0 ? void 0 : _this$castPlayer6.currentTime) ?? 0;\n    }\n    return super.currentTime;\n  }\n  set currentTime(val) {\n    if (this.#castPlayer) {\n      var _this$castPlayer$cont5;\n      this.#castPlayer.currentTime = val;\n      (_this$castPlayer$cont5 = this.#castPlayer.controller) === null || _this$castPlayer$cont5 === void 0 ? void 0 : _this$castPlayer$cont5.seek();\n      return;\n    }\n    super.currentTime = val;\n  }\n};\nexport const CastableVideoMixin = CastableMediaMixin;","map":{"version":3,"names":["RemotePlayback","privateProps","requiresCastFramework","loadCastFramework","currentSession","getDefaultCastOptions","isHls","getPlaylistSegmentFormat","CastableMediaMixin","superclass","CastableMedia","observedAttributes","localState","paused","castOptions","castCustomData","remote","disableRemotePlayback","set","loadOnPrompt","castPlayer","#castPlayer","_privateProps$get","_privateProps$get$get","get","getCastPlayer","call","attributeChangedCallback","attrName","oldValue","newValue","receiverApplicationId","load","#loadOnPrompt","pause","muted","err","console","error","_currentSession","mediaInfo","chrome","cast","media","MediaInfo","castSrc","castContentType","customData","subtitles","querySelectorAll","filter","_ref","kind","src","activeTrackIds","textTrackIdCount","length","tracks","map","trackEl","trackId","track","mode","push","Track","TrackType","TEXT","trackContentId","trackContentType","subtype","TextTrackType","CAPTIONS","SUBTITLES","name","label","language","srclang","castStreamType","streamType","StreamType","LIVE","BUFFERED","metadata","GenericMediaMetadata","title","images","url","poster","segmentFormat","isFragmentedMP4","includes","hlsSegmentFormat","HlsSegmentFormat","FMP4","hlsVideoSegmentFormat","HlsVideoSegmentFormat","request","LoadRequest","currentTime","autoplay","loadMedia","dispatchEvent","Event","play","isPaused","_this$castPlayer$cont","controller","playOrPause","_this$castPlayer$cont2","castReceiver","getAttribute","undefined","val","setAttribute","_this$querySelector","querySelector","currentSrc","valType","readyState","playerState","PlayerState","IDLE","BUFFERING","_this$castPlayer","isMuted","_this$castPlayer$cont3","muteOrUnmute","volume","_this$castPlayer2","volumeLevel","_this$castPlayer$cont4","setVolumeLevel","duration","_this$castPlayer3","isMediaLoaded","_this$castPlayer4","NaN","_this$castPlayer5","_this$castPlayer6","_this$castPlayer$cont5","seek","CastableVideoMixin"],"sources":["/Users/monawiebkeurban/Documents/portfolio/node_modules/castable-video/castable-mixin.js"],"sourcesContent":["/* global chrome */\nimport { RemotePlayback } from './castable-remote-playback.js';\nimport {\n  privateProps,\n  requiresCastFramework,\n  loadCastFramework,\n  currentSession,\n  getDefaultCastOptions,\n  isHls,\n  getPlaylistSegmentFormat\n} from './castable-utils.js';\n\n/**\n * CastableMediaMixin\n *\n * This mixin function provides a way to compose multiple classes.\n * @see https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/\n *\n * @param  {HTMLMediaElement} superclass - HTMLMediaElement or an extended class of it.\n * @return {CastableMedia}\n */\nexport const CastableMediaMixin = (superclass) =>\n  class CastableMedia extends superclass {\n\n    static observedAttributes = [\n      ...(superclass.observedAttributes ?? []),\n      'cast-src',\n      'cast-content-type',\n      'cast-stream-type',\n      'cast-receiver',\n    ];\n\n    #localState = { paused: false };\n    #castOptions = getDefaultCastOptions();\n    #castCustomData;\n    #remote;\n\n    get remote() {\n      if (this.#remote) return this.#remote;\n\n      if (requiresCastFramework()) {\n        // No need to load the Cast framework if it's disabled.\n        if (!this.disableRemotePlayback) {\n          loadCastFramework();\n        }\n\n        privateProps.set(this, {\n          loadOnPrompt: () => this.#loadOnPrompt()\n        });\n\n        return (this.#remote = new RemotePlayback(this));\n      }\n\n      return super.remote;\n    }\n\n    get #castPlayer() {\n      return privateProps.get(this.remote)?.getCastPlayer?.();\n    }\n\n    attributeChangedCallback(attrName, oldValue, newValue) {\n      super.attributeChangedCallback(attrName, oldValue, newValue);\n\n      if (attrName === 'cast-receiver' && newValue) {\n        this.#castOptions.receiverApplicationId = newValue;\n        return;\n      }\n\n      if (!this.#castPlayer) return;\n\n      switch (attrName) {\n        case 'cast-stream-type':\n        case 'cast-src':\n          this.load();\n          break;\n      }\n    }\n\n    async #loadOnPrompt() {\n      // Pause locally when the session is created.\n      this.#localState.paused = super.paused;\n      super.pause();\n\n      // Sync over the muted state but not volume, 100% is different on TV's :P\n      this.muted = super.muted;\n\n      try {\n        await this.load();\n      } catch (err) {\n        console.error(err);\n      }\n    }\n\n    async load() {\n      if (!this.#castPlayer) return super.load();\n\n      const mediaInfo = new chrome.cast.media.MediaInfo(this.castSrc, this.castContentType);\n      mediaInfo.customData = this.castCustomData;\n\n      // Manually add text tracks with a `src` attribute.\n      // M3U8's load text tracks in the receiver, handle these in the media loaded event.\n      const subtitles = [...this.querySelectorAll('track')].filter(\n        ({ kind, src }) => src && (kind === 'subtitles' || kind === 'captions')\n      );\n\n      const activeTrackIds = [];\n      let textTrackIdCount = 0;\n\n      if (subtitles.length) {\n        mediaInfo.tracks = subtitles.map((trackEl) => {\n          const trackId = ++textTrackIdCount;\n          // only activate 1 subtitle text track.\n          if (activeTrackIds.length === 0 && trackEl.track.mode === 'showing') {\n            activeTrackIds.push(trackId);\n          }\n\n          const track = new chrome.cast.media.Track(\n            trackId,\n            chrome.cast.media.TrackType.TEXT\n          );\n          track.trackContentId = trackEl.src;\n          track.trackContentType = 'text/vtt';\n          track.subtype =\n            trackEl.kind === 'captions'\n              ? chrome.cast.media.TextTrackType.CAPTIONS\n              : chrome.cast.media.TextTrackType.SUBTITLES;\n          track.name = trackEl.label;\n          track.language = trackEl.srclang;\n          return track;\n        });\n      }\n\n      if (this.castStreamType === 'live') {\n        mediaInfo.streamType = chrome.cast.media.StreamType.LIVE;\n      } else {\n        mediaInfo.streamType = chrome.cast.media.StreamType.BUFFERED;\n      }\n\n      mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();\n      mediaInfo.metadata.title = this.title;\n      mediaInfo.metadata.images = [{ url: this.poster }];\n\n      if (isHls(this.castSrc)) {\n        const segmentFormat = await getPlaylistSegmentFormat(this.castSrc);\n        const isFragmentedMP4 = segmentFormat?.includes('m4s') || segmentFormat?.includes('mp4');\n        if (isFragmentedMP4) {\n          mediaInfo.hlsSegmentFormat = chrome.cast.media.HlsSegmentFormat.FMP4;\n          mediaInfo.hlsVideoSegmentFormat = chrome.cast.media.HlsVideoSegmentFormat.FMP4;\n        }\n      }\n\n      const request = new chrome.cast.media.LoadRequest(mediaInfo);\n      request.currentTime = super.currentTime ?? 0;\n      request.autoplay = !this.#localState.paused;\n      request.activeTrackIds = activeTrackIds;\n\n      await currentSession()?.loadMedia(request);\n\n      this.dispatchEvent(new Event('volumechange'));\n    }\n\n    play() {\n      if (this.#castPlayer) {\n        if (this.#castPlayer.isPaused) {\n          this.#castPlayer.controller?.playOrPause();\n        }\n        return;\n      }\n      return super.play();\n    }\n\n    pause() {\n      if (this.#castPlayer) {\n        if (!this.#castPlayer.isPaused) {\n          this.#castPlayer.controller?.playOrPause();\n        }\n        return;\n      }\n      super.pause();\n    }\n\n    /**\n     * @see https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastOptions\n     * @readonly\n     *\n     * @typedef {Object} CastOptions\n     * @property {string} [receiverApplicationId='CC1AD845'] - The app id of the cast receiver.\n     * @property {string} [autoJoinPolicy='origin_scoped'] - The auto join policy.\n     * @property {string} [language='en-US'] - The language to use for the cast receiver.\n     * @property {boolean} [androidReceiverCompatible=false] - Whether to use the Cast Connect.\n     * @property {boolean} [resumeSavedSession=true] - Whether to resume the last session.\n     *\n     * @return {CastOptions}\n     */\n    get castOptions() {\n      return this.#castOptions;\n    }\n\n    get castReceiver() {\n      return this.getAttribute('cast-receiver') ?? undefined;\n    }\n\n    set castReceiver(val) {\n      if (this.castReceiver == val) return;\n      this.setAttribute('cast-receiver', `${val}`);\n    }\n\n    // Allow the cast source url to be different than <video src>, could be a blob.\n    get castSrc() {\n      // Try the first <source src> for usage with even more native markup.\n      return (\n        this.getAttribute('cast-src') ??\n        this.querySelector('source')?.src ??\n        this.currentSrc\n      );\n    }\n\n    set castSrc(val) {\n      if (this.castSrc == val) return;\n      this.setAttribute('cast-src', `${val}`);\n    }\n\n    get castContentType() {\n      return this.getAttribute('cast-content-type') ?? undefined;\n    }\n\n    set castContentType(val) {\n      this.setAttribute('cast-content-type', `${val}`);\n    }\n\n    get castStreamType() {\n      // NOTE: Per https://github.com/video-dev/media-ui-extensions/issues/3 `streamType` may yield `\"unknown\"`\n      return this.getAttribute('cast-stream-type') ?? this.streamType ?? undefined;\n    }\n\n    set castStreamType(val) {\n      this.setAttribute('cast-stream-type', `${val}`);\n    }\n\n    get castCustomData() {\n      return this.#castCustomData;\n    }\n\n    set castCustomData(val) {\n      const valType = typeof val;\n      if (!['object', 'undefined'].includes(valType)) {\n        console.error(`castCustomData must be nullish or an object but value was of type ${valType}`);\n        return;\n      }\n\n      this.#castCustomData = val;\n    }\n\n    get readyState() {\n      if (this.#castPlayer) {\n        switch (this.#castPlayer.playerState) {\n          case chrome.cast.media.PlayerState.IDLE:\n            return 0;\n          case chrome.cast.media.PlayerState.BUFFERING:\n            return 2;\n          default:\n            return 3;\n        }\n      }\n      return super.readyState;\n    }\n\n    get paused() {\n      if (this.#castPlayer) return this.#castPlayer.isPaused;\n      return super.paused;\n    }\n\n    get muted() {\n      if (this.#castPlayer) return this.#castPlayer?.isMuted;\n      return super.muted;\n    }\n\n    set muted(val) {\n      if (this.#castPlayer) {\n        if (\n          (val && !this.#castPlayer.isMuted) ||\n          (!val && this.#castPlayer.isMuted)\n        ) {\n          this.#castPlayer.controller?.muteOrUnmute();\n        }\n        return;\n      }\n      super.muted = val;\n    }\n\n    get volume() {\n      if (this.#castPlayer) return this.#castPlayer?.volumeLevel ?? 1;\n      return super.volume;\n    }\n\n    set volume(val) {\n      if (this.#castPlayer) {\n        this.#castPlayer.volumeLevel = +val;\n        this.#castPlayer.controller?.setVolumeLevel();\n        return;\n      }\n      super.volume = val;\n    }\n\n    get duration() {\n      // castPlayer duration returns `0` when no media is loaded.\n      if (this.#castPlayer && this.#castPlayer?.isMediaLoaded) {\n        return this.#castPlayer?.duration ?? NaN;\n      }\n      return super.duration;\n    }\n\n    get currentTime() {\n      if (this.#castPlayer && this.#castPlayer?.isMediaLoaded) {\n        return this.#castPlayer?.currentTime ?? 0;\n      }\n      return super.currentTime;\n    }\n\n    set currentTime(val) {\n      if (this.#castPlayer) {\n        this.#castPlayer.currentTime = val;\n        this.#castPlayer.controller?.seek();\n        return;\n      }\n      super.currentTime = val;\n    }\n  };\n\nexport const CastableVideoMixin = CastableMediaMixin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}