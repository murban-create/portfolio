{"ast":null,"code":"import ue from \"mux-embed\";\nimport Ze from \"hls.js\";\nvar g = Ze;\nvar C = {\n    VIDEO: \"video\",\n    THUMBNAIL: \"thumbnail\",\n    STORYBOARD: \"storyboard\",\n    DRM: \"drm\"\n  },\n  D = {\n    NOT_AN_ERROR: 0,\n    NETWORK_OFFLINE: 2000002,\n    NETWORK_UNKNOWN_ERROR: 2e6,\n    NETWORK_NO_STATUS: 2000001,\n    NETWORK_INVALID_URL: 24e5,\n    NETWORK_NOT_FOUND: 2404e3,\n    NETWORK_NOT_READY: 2412e3,\n    NETWORK_GENERIC_SERVER_FAIL: 25e5,\n    NETWORK_TOKEN_MISSING: 2403201,\n    NETWORK_TOKEN_MALFORMED: 2412202,\n    NETWORK_TOKEN_EXPIRED: 2403210,\n    NETWORK_TOKEN_AUD_MISSING: 2403221,\n    NETWORK_TOKEN_AUD_MISMATCH: 2403222,\n    NETWORK_TOKEN_SUB_MISMATCH: 2403232,\n    ENCRYPTED_ERROR: 5e6,\n    ENCRYPTED_UNSUPPORTED_KEY_SYSTEM: 5000001,\n    ENCRYPTED_GENERATE_REQUEST_FAILED: 5000002,\n    ENCRYPTED_UPDATE_LICENSE_FAILED: 5000003,\n    ENCRYPTED_UPDATE_SERVER_CERT_FAILED: 5000004,\n    ENCRYPTED_CDM_ERROR: 5000005,\n    ENCRYPTED_OUTPUT_RESTRICTED: 5000006,\n    ENCRYPTED_MISSING_TOKEN: 5000002\n  },\n  V = e => e === C.VIDEO ? \"playback\" : e,\n  L = class L extends Error {\n    constructor(t) {\n      let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : L.MEDIA_ERR_CUSTOM;\n      let n = arguments.length > 2 ? arguments[2] : undefined;\n      let o = arguments.length > 3 ? arguments[3] : undefined;\n      var a;\n      super(t), this.name = \"MediaError\", this.code = r, this.context = o, this.fatal = n != null ? n : r >= L.MEDIA_ERR_NETWORK && r <= L.MEDIA_ERR_ENCRYPTED, this.message || (this.message = (a = L.defaultMessages[this.code]) != null ? a : \"\");\n    }\n  };\nL.MEDIA_ERR_ABORTED = 1, L.MEDIA_ERR_NETWORK = 2, L.MEDIA_ERR_DECODE = 3, L.MEDIA_ERR_SRC_NOT_SUPPORTED = 4, L.MEDIA_ERR_ENCRYPTED = 5, L.MEDIA_ERR_CUSTOM = 100, L.defaultMessages = {\n  1: \"You aborted the media playback\",\n  2: \"A network error caused the media download to fail.\",\n  3: \"A media error caused playback to be aborted. The media could be corrupt or your browser does not support this format.\",\n  4: \"An unsupported error occurred. The server or network failed, or your browser does not support this format.\",\n  5: \"The media is encrypted and there are no keys to decrypt it.\"\n};\nvar f = L;\nvar et = e => e == null,\n  O = (e, t) => et(t) ? !1 : e in t,\n  K = {\n    ANY: \"any\",\n    MUTED: \"muted\"\n  },\n  _ = {\n    ON_DEMAND: \"on-demand\",\n    LIVE: \"live\",\n    UNKNOWN: \"unknown\"\n  },\n  X = {\n    MSE: \"mse\",\n    NATIVE: \"native\"\n  },\n  S = {\n    HEADER: \"header\",\n    QUERY: \"query\",\n    NONE: \"none\"\n  },\n  jt = Object.values(S),\n  A = {\n    M3U8: \"application/vnd.apple.mpegurl\",\n    MP4: \"video/mp4\"\n  },\n  W = {\n    HLS: A.M3U8\n  },\n  Jt = Object.keys(W),\n  qt = [...Object.values(A), \"hls\", \"HLS\"],\n  Gt = {\n    upTo720p: \"720p\",\n    upTo1080p: \"1080p\",\n    upTo1440p: \"1440p\",\n    upTo2160p: \"2160p\"\n  },\n  Xt = {\n    noLessThan480p: \"480p\",\n    noLessThan540p: \"540p\",\n    noLessThan720p: \"720p\",\n    noLessThan1080p: \"1080p\",\n    noLessThan1440p: \"1440p\",\n    noLessThan2160p: \"2160p\"\n  },\n  zt = {\n    DESCENDING: \"desc\"\n  };\nvar tt = \"en\",\n  Y = {\n    code: tt\n  };\nvar v = function (e, t, r, n) {\n  let o = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : e;\n  o.addEventListener(t, r, n), e.addEventListener(\"teardown\", () => {\n    o.removeEventListener(t, r);\n  }, {\n    once: !0\n  });\n};\nfunction fe(e, t, r) {\n  t && r > t && (r = t);\n  for (let n = 0; n < e.length; n++) if (e.start(n) <= r && e.end(n) >= r) return !0;\n  return !1;\n}\nvar F = e => {\n    let t = e.indexOf(\"?\");\n    if (t < 0) return [e];\n    let r = e.slice(0, t),\n      n = e.slice(t);\n    return [r, n];\n  },\n  U = e => {\n    let {\n      type: t\n    } = e;\n    if (t) {\n      let r = t.toUpperCase();\n      return O(r, W) ? W[r] : t;\n    }\n    return rt(e);\n  },\n  Q = e => e === \"VOD\" ? _.ON_DEMAND : _.LIVE,\n  Z = e => e === \"EVENT\" ? Number.POSITIVE_INFINITY : e === \"VOD\" ? Number.NaN : 0,\n  rt = e => {\n    let {\n      src: t\n    } = e;\n    if (!t) return \"\";\n    let r = \"\";\n    try {\n      r = new URL(t).pathname;\n    } catch {\n      console.error(\"invalid url\");\n    }\n    let n = r.lastIndexOf(\".\");\n    if (n < 0) return ot(e) ? A.M3U8 : \"\";\n    let a = r.slice(n + 1).toUpperCase();\n    return O(a, A) ? A[a] : \"\";\n  },\n  nt = \"mux.com\",\n  ot = _ref => {\n    let {\n      src: e,\n      customDomain: t = nt\n    } = _ref;\n    let r;\n    try {\n      r = new URL(`${e}`);\n    } catch {\n      return !1;\n    }\n    let n = r.protocol === \"https:\",\n      o = r.hostname === `stream.${t}`.toLowerCase(),\n      a = r.pathname.split(\"/\"),\n      i = a.length === 2,\n      c = !(a != null && a[1].includes(\".\"));\n    return n && o && i && c;\n  },\n  ee = e => {\n    let t = (e != null ? e : \"\").split(\".\")[1];\n    if (t) try {\n      let r = t.replace(/-/g, \"+\").replace(/_/g, \"/\"),\n        n = decodeURIComponent(atob(r).split(\"\").map(function (o) {\n          return \"%\" + (\"00\" + o.charCodeAt(0).toString(16)).slice(-2);\n        }).join(\"\"));\n      return JSON.parse(n);\n    } catch {\n      return;\n    }\n  },\n  Te = function (_ref2) {\n    let {\n      exp: e\n    } = _ref2;\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Date.now();\n    return !e || e * 1e3 < t;\n  },\n  ye = (_ref3, t) => {\n    let {\n      sub: e\n    } = _ref3;\n    return e !== t;\n  },\n  me = (_ref4, t) => {\n    let {\n      aud: e\n    } = _ref4;\n    return !e;\n  },\n  Ee = (_ref5, t) => {\n    let {\n      aud: e\n    } = _ref5;\n    return e !== t;\n  },\n  ge = \"en\";\nfunction x(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n  var o, a;\n  let r = t && (a = (o = Y) == null ? void 0 : o[e]) != null ? a : e,\n    n = t ? Y.code : ge;\n  return new z(r, n);\n}\nvar z = class {\n  constructor(t) {\n    let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n => (n = Y) != null ? n : ge)();\n    this.message = t, this.locale = r;\n  }\n  format(t) {\n    return this.message.replace(/\\{(\\w+)\\}/g, (r, n) => {\n      var o;\n      return (o = t[n]) != null ? o : \"\";\n    });\n  }\n  toString() {\n    return this.message;\n  }\n};\nvar at = Object.values(K),\n  Me = e => typeof e == \"boolean\" || typeof e == \"string\" && at.includes(e),\n  xe = (e, t, r) => {\n    let {\n        autoplay: n\n      } = e,\n      o = !1,\n      a = !1,\n      i = Me(n) ? n : !!n,\n      c = () => {\n        o || v(t, \"playing\", () => {\n          o = !0;\n        }, {\n          once: !0\n        });\n      };\n    if (c(), v(t, \"loadstart\", () => {\n      o = !1, c(), te(t, i);\n    }, {\n      once: !0\n    }), v(t, \"loadstart\", () => {\n      r || (e.streamType && e.streamType !== _.UNKNOWN ? a = e.streamType === _.LIVE : a = !Number.isFinite(t.duration)), te(t, i);\n    }, {\n      once: !0\n    }), r && r.once(g.Events.LEVEL_LOADED, (u, s) => {\n      var p;\n      e.streamType && e.streamType !== _.UNKNOWN ? a = e.streamType === _.LIVE : a = (p = s.details.live) != null ? p : !1;\n    }), !i) {\n      let u = () => {\n        !a || Number.isFinite(e.startTime) || (r != null && r.liveSyncPosition ? t.currentTime = r.liveSyncPosition : Number.isFinite(t.seekable.end(0)) && (t.currentTime = t.seekable.end(0)));\n      };\n      r && v(t, \"play\", () => {\n        t.preload === \"metadata\" ? r.once(g.Events.LEVEL_UPDATED, u) : u();\n      }, {\n        once: !0\n      });\n    }\n    return u => {\n      o || (i = Me(u) ? u : !!u, te(t, i));\n    };\n  },\n  te = (e, t) => {\n    if (!t) return;\n    let r = e.muted,\n      n = () => e.muted = r;\n    switch (t) {\n      case K.ANY:\n        e.play().catch(() => {\n          e.muted = !0, e.play().catch(n);\n        });\n        break;\n      case K.MUTED:\n        e.muted = !0, e.play().catch(n);\n        break;\n      default:\n        e.play().catch(() => {});\n        break;\n    }\n  };\nvar Re = (_ref6, r, n) => {\n  let {\n    preload: e,\n    src: t\n  } = _ref6;\n  let o = p => {\n    p != null && [\"\", \"none\", \"metadata\", \"auto\"].includes(p) ? r.setAttribute(\"preload\", p) : r.removeAttribute(\"preload\");\n  };\n  if (!n) return o(e), o;\n  let a = !1,\n    i = !1,\n    c = n.config.maxBufferLength,\n    d = n.config.maxBufferSize,\n    u = p => {\n      o(p);\n      let l = p != null ? p : r.preload;\n      i || l === \"none\" || (l === \"metadata\" ? (n.config.maxBufferLength = 1, n.config.maxBufferSize = 1) : (n.config.maxBufferLength = c, n.config.maxBufferSize = d), s());\n    },\n    s = () => {\n      !a && t && (a = !0, n.loadSource(t));\n    };\n  return v(r, \"play\", () => {\n    i = !0, n.config.maxBufferLength = c, n.config.maxBufferSize = d, s();\n  }, {\n    once: !0\n  }), u(e), u;\n};\nfunction De(e, t) {\n  var c;\n  if (!(\"videoTracks\" in e)) return;\n  let r = new WeakMap();\n  t.on(g.Events.MANIFEST_PARSED, function (d, u) {\n    i();\n    let s = e.addVideoTrack(\"main\");\n    s.selected = !0;\n    for (let [p, l] of u.levels.entries()) {\n      let T = s.addRendition(l.url[0], l.width, l.height, l.videoCodec, l.bitrate);\n      r.set(l, `${p}`), T.id = `${p}`;\n    }\n  }), t.on(g.Events.AUDIO_TRACKS_UPDATED, function (d, u) {\n    a();\n    for (let s of u.audioTracks) {\n      let p = s.default ? \"main\" : \"alternative\",\n        l = e.addAudioTrack(p, s.name, s.lang);\n      l.id = `${s.id}`, s.default && (l.enabled = !0);\n    }\n  }), e.audioTracks.addEventListener(\"change\", () => {\n    var s;\n    let d = +((s = [...e.audioTracks].find(p => p.enabled)) == null ? void 0 : s.id),\n      u = t.audioTracks.map(p => p.id);\n    d != t.audioTrack && u.includes(d) && (t.audioTrack = d);\n  }), t.on(g.Events.LEVELS_UPDATED, function (d, u) {\n    var l;\n    let s = e.videoTracks[(l = e.videoTracks.selectedIndex) != null ? l : 0];\n    if (!s) return;\n    let p = u.levels.map(T => r.get(T));\n    for (let T of e.videoRenditions) T.id && !p.includes(T.id) && s.removeRendition(T);\n  });\n  let n = d => {\n    let u = d.target.selectedIndex;\n    u != t.nextLevel && (t.nextLevel = u);\n  };\n  (c = e.videoRenditions) == null || c.addEventListener(\"change\", n);\n  let o = () => {\n      for (let d of e.videoTracks) e.removeVideoTrack(d);\n    },\n    a = () => {\n      for (let d of e.audioTracks) e.removeAudioTrack(d);\n    },\n    i = () => {\n      o(), a();\n    };\n  t.once(g.Events.DESTROYING, i);\n}\nvar re = e => \"time\" in e ? e.time : e.startTime;\nfunction be(e, t) {\n  t.on(g.Events.NON_NATIVE_TEXT_TRACKS_FOUND, (o, _ref7) => {\n    let {\n      tracks: a\n    } = _ref7;\n    a.forEach(i => {\n      var s, p;\n      let c = (s = i.subtitleTrack) != null ? s : i.closedCaptions,\n        d = t.subtitleTracks.findIndex(_ref8 => {\n          let {\n            lang: l,\n            name: T,\n            type: m\n          } = _ref8;\n          return l == (c == null ? void 0 : c.lang) && T === i.label && m.toLowerCase() === i.kind;\n        }),\n        u = ((p = i._id) != null ? p : i.default) ? \"default\" : `${i.kind}${d}`;\n      ne(e, i.kind, i.label, c == null ? void 0 : c.lang, u, i.default);\n    });\n  });\n  let r = () => {\n    if (!t.subtitleTracks.length) return;\n    let o = Array.from(e.textTracks).find(c => c.id && c.mode === \"showing\" && [\"subtitles\", \"captions\"].includes(c.kind));\n    if (!o) return;\n    let a = t.subtitleTracks[t.subtitleTrack],\n      i = a ? a.default ? \"default\" : `${t.subtitleTracks[t.subtitleTrack].type.toLowerCase()}${t.subtitleTrack}` : void 0;\n    if (t.subtitleTrack < 0 || (o == null ? void 0 : o.id) !== i) {\n      let c = t.subtitleTracks.findIndex(_ref9 => {\n        let {\n          lang: d,\n          name: u,\n          type: s,\n          default: p\n        } = _ref9;\n        return o.id === \"default\" && p || d == o.language && u === o.label && s.toLowerCase() === o.kind;\n      });\n      t.subtitleTrack = c;\n    }\n    (o == null ? void 0 : o.id) === i && o.cues && Array.from(o.cues).forEach(c => {\n      o.addCue(c);\n    });\n  };\n  e.textTracks.addEventListener(\"change\", r), t.on(g.Events.CUES_PARSED, (o, _ref10) => {\n    let {\n      track: a,\n      cues: i\n    } = _ref10;\n    let c = e.textTracks.getTrackById(a);\n    if (!c) return;\n    let d = c.mode === \"disabled\";\n    d && (c.mode = \"hidden\"), i.forEach(u => {\n      var s;\n      (s = c.cues) != null && s.getCueById(u.id) || c.addCue(u);\n    }), d && (c.mode = \"disabled\");\n  }), t.once(g.Events.DESTROYING, () => {\n    e.textTracks.removeEventListener(\"change\", r), e.querySelectorAll(\"track[data-removeondestroy]\").forEach(a => {\n      a.remove();\n    });\n  });\n  let n = () => {\n    Array.from(e.textTracks).forEach(o => {\n      var a, i;\n      if (![\"subtitles\", \"caption\"].includes(o.kind) && (o.label === \"thumbnails\" || o.kind === \"chapters\")) {\n        if (!((a = o.cues) != null && a.length)) {\n          let c = \"track\";\n          o.kind && (c += `[kind=\"${o.kind}\"]`), o.label && (c += `[label=\"${o.label}\"]`);\n          let d = e.querySelector(c),\n            u = (i = d == null ? void 0 : d.getAttribute(\"src\")) != null ? i : \"\";\n          d == null || d.removeAttribute(\"src\"), setTimeout(() => {\n            d == null || d.setAttribute(\"src\", u);\n          }, 0);\n        }\n        o.mode !== \"hidden\" && (o.mode = \"hidden\");\n      }\n    });\n  };\n  t.once(g.Events.MANIFEST_LOADED, n), t.once(g.Events.MEDIA_ATTACHED, n);\n}\nfunction ne(e, t, r, n, o, a) {\n  let i = document.createElement(\"track\");\n  return i.kind = t, i.label = r, n && (i.srclang = n), o && (i.id = o), a && (i.default = !0), i.track.mode = [\"subtitles\", \"captions\"].includes(t) ? \"disabled\" : \"hidden\", i.setAttribute(\"data-removeondestroy\", \"\"), e.append(i), i.track;\n}\nfunction st(e, t) {\n  let r = Array.prototype.find.call(e.querySelectorAll(\"track\"), n => n.track === t);\n  r == null || r.remove();\n}\nfunction w(e, t, r) {\n  var n;\n  return (n = Array.from(e.querySelectorAll(\"track\")).find(o => o.track.label === t && o.track.kind === r)) == null ? void 0 : n.track;\n}\nasync function Ce(e, t, r, n) {\n  let o = w(e, r, n);\n  return o || (o = ne(e, n, r), o.mode = \"hidden\", await new Promise(a => setTimeout(() => a(void 0), 0))), o.mode !== \"hidden\" && (o.mode = \"hidden\"), [...t].sort((a, i) => re(i) - re(a)).forEach(a => {\n    var d, u;\n    let i = a.value,\n      c = re(a);\n    if (\"endTime\" in a && a.endTime != null) o == null || o.addCue(new VTTCue(c, a.endTime, n === \"chapters\" ? i : JSON.stringify(i != null ? i : null)));else {\n      let s = Array.prototype.findIndex.call(o == null ? void 0 : o.cues, m => m.startTime >= c),\n        p = (d = o == null ? void 0 : o.cues) == null ? void 0 : d[s],\n        l = p ? p.startTime : Number.isFinite(e.duration) ? e.duration : Number.MAX_SAFE_INTEGER,\n        T = (u = o == null ? void 0 : o.cues) == null ? void 0 : u[s - 1];\n      T && (T.endTime = c), o == null || o.addCue(new VTTCue(c, l, n === \"chapters\" ? i : JSON.stringify(i != null ? i : null)));\n    }\n  }), e.textTracks.dispatchEvent(new Event(\"change\", {\n    bubbles: !0,\n    composed: !0\n  })), o;\n}\nvar oe = \"cuepoints\",\n  ve = Object.freeze({\n    label: oe\n  });\nasync function Pe(e, t) {\n  let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ve;\n  return Ce(e, t, r.label, \"metadata\");\n}\nvar $ = e => ({\n  time: e.startTime,\n  value: JSON.parse(e.text)\n});\nfunction it(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    label: oe\n  };\n  let r = w(e, t.label, \"metadata\");\n  return r != null && r.cues ? Array.from(r.cues, n => $(n)) : [];\n}\nfunction _e(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    label: oe\n  };\n  var a, i;\n  let r = w(e, t.label, \"metadata\");\n  if (!((a = r == null ? void 0 : r.activeCues) != null && a.length)) return;\n  if (r.activeCues.length === 1) return $(r.activeCues[0]);\n  let {\n      currentTime: n\n    } = e,\n    o = Array.prototype.find.call((i = r.activeCues) != null ? i : [], _ref11 => {\n      let {\n        startTime: c,\n        endTime: d\n      } = _ref11;\n      return c <= n && d > n;\n    });\n  return $(o || r.activeCues[0]);\n}\nasync function ke(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ve;\n  return new Promise(r => {\n    v(e, \"loadstart\", async () => {\n      let n = await Pe(e, [], t);\n      v(e, \"cuechange\", () => {\n        let o = _e(e);\n        if (o) {\n          let a = new CustomEvent(\"cuepointchange\", {\n            composed: !0,\n            bubbles: !0,\n            detail: o\n          });\n          e.dispatchEvent(a);\n        }\n      }, {}, n), r(n);\n    });\n  });\n}\nvar ae = \"chapters\",\n  he = Object.freeze({\n    label: ae\n  }),\n  B = e => ({\n    startTime: e.startTime,\n    endTime: e.endTime,\n    value: e.text\n  });\nasync function Le(e, t) {\n  let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : he;\n  return Ce(e, t, r.label, \"chapters\");\n}\nfunction ct(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    label: ae\n  };\n  var n;\n  let r = w(e, t.label, \"chapters\");\n  return (n = r == null ? void 0 : r.cues) != null && n.length ? Array.from(r.cues, o => B(o)) : [];\n}\nfunction Ne(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    label: ae\n  };\n  var a, i;\n  let r = w(e, t.label, \"chapters\");\n  if (!((a = r == null ? void 0 : r.activeCues) != null && a.length)) return;\n  if (r.activeCues.length === 1) return B(r.activeCues[0]);\n  let {\n      currentTime: n\n    } = e,\n    o = Array.prototype.find.call((i = r.activeCues) != null ? i : [], _ref12 => {\n      let {\n        startTime: c,\n        endTime: d\n      } = _ref12;\n      return c <= n && d > n;\n    });\n  return B(o || r.activeCues[0]);\n}\nasync function Ae(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : he;\n  return new Promise(r => {\n    v(e, \"loadstart\", async () => {\n      let n = await Le(e, [], t);\n      v(e, \"cuechange\", () => {\n        let o = Ne(e);\n        if (o) {\n          let a = new CustomEvent(\"chapterchange\", {\n            composed: !0,\n            bubbles: !0,\n            detail: o\n          });\n          e.dispatchEvent(a);\n        }\n      }, {}, n), r(n);\n    });\n  });\n}\nfunction ut(e, t) {\n  if (t) {\n    let r = t.playingDate;\n    if (r != null) return new Date(r.getTime() - e.currentTime * 1e3);\n  }\n  return typeof e.getStartDate == \"function\" ? e.getStartDate() : new Date(NaN);\n}\nfunction dt(e, t) {\n  if (t && t.playingDate) return t.playingDate;\n  if (typeof e.getStartDate == \"function\") {\n    let r = e.getStartDate();\n    return new Date(r.getTime() + e.currentTime * 1e3);\n  }\n  return new Date(NaN);\n}\nvar se = {\n    VIDEO: \"v\",\n    THUMBNAIL: \"t\",\n    STORYBOARD: \"s\",\n    DRM: \"d\"\n  },\n  lt = e => {\n    if (e === C.VIDEO) return se.VIDEO;\n    if (e === C.DRM) return se.DRM;\n  },\n  pt = (e, t) => {\n    var o, a;\n    let r = V(e),\n      n = `${r}Token`;\n    return (o = t.tokens) != null && o[r] ? (a = t.tokens) == null ? void 0 : a[r] : O(n, t) ? t[n] : void 0;\n  },\n  H = function (e, t, r, n) {\n    let o = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;\n    let a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !(i => (i = globalThis.navigator) == null ? void 0 : i.onLine)();\n    var M, h;\n    if (a) {\n      let E = x(\"Your device appears to be offline\", o),\n        b = void 0,\n        y = f.MEDIA_ERR_NETWORK,\n        k = new f(E, y, !1, b);\n      return k.errorCategory = t, k.muxCode = D.NETWORK_OFFLINE, k.data = e, k;\n    }\n    let c = \"status\" in e ? e.status : e.code,\n      d = Date.now(),\n      u = f.MEDIA_ERR_NETWORK;\n    if (c === 200) return;\n    let s = V(t),\n      p = pt(t, r),\n      l = lt(t),\n      [T] = F((M = r.playbackId) != null ? M : \"\");\n    if (!c || !T) return;\n    let m = ee(p);\n    if (p && !m) {\n      let E = x(\"The {tokenNamePrefix}-token provided is invalid or malformed.\", o).format({\n          tokenNamePrefix: s\n        }),\n        b = x(\"Compact JWT string: {token}\", o).format({\n          token: p\n        }),\n        y = new f(E, u, !0, b);\n      return y.errorCategory = t, y.muxCode = D.NETWORK_TOKEN_MALFORMED, y.data = e, y;\n    }\n    if (c >= 500) {\n      let E = new f(\"\", u, n != null ? n : !0);\n      return E.errorCategory = t, E.muxCode = D.NETWORK_UNKNOWN_ERROR, E;\n    }\n    if (c === 403) if (m) {\n      if (Te(m, d)) {\n        let E = {\n            timeStyle: \"medium\",\n            dateStyle: \"medium\"\n          },\n          b = x(\"The video\\u2019s secured {tokenNamePrefix}-token has expired.\", o).format({\n            tokenNamePrefix: s\n          }),\n          y = x(\"Expired at: {expiredDate}. Current time: {currentDate}.\", o).format({\n            expiredDate: new Intl.DateTimeFormat(\"en\", E).format((h = m.exp) != null ? h : 0 * 1e3),\n            currentDate: new Intl.DateTimeFormat(\"en\", E).format(d)\n          }),\n          k = new f(b, u, !0, y);\n        return k.errorCategory = t, k.muxCode = D.NETWORK_TOKEN_EXPIRED, k.data = e, k;\n      }\n      if (ye(m, T)) {\n        let E = x(\"The video\\u2019s playback ID does not match the one encoded in the {tokenNamePrefix}-token.\", o).format({\n            tokenNamePrefix: s\n          }),\n          b = x(\"Specified playback ID: {playbackId} and the playback ID encoded in the {tokenNamePrefix}-token: {tokenPlaybackId}\", o).format({\n            tokenNamePrefix: s,\n            playbackId: T,\n            tokenPlaybackId: m.sub\n          }),\n          y = new f(E, u, !0, b);\n        return y.errorCategory = t, y.muxCode = D.NETWORK_TOKEN_SUB_MISMATCH, y.data = e, y;\n      }\n      if (me(m, l)) {\n        let E = x(\"The {tokenNamePrefix}-token is formatted with incorrect information.\", o).format({\n            tokenNamePrefix: s\n          }),\n          b = x(\"The {tokenNamePrefix}-token has no aud value. aud value should be {expectedAud}.\", o).format({\n            tokenNamePrefix: s,\n            expectedAud: l\n          }),\n          y = new f(E, u, !0, b);\n        return y.errorCategory = t, y.muxCode = D.NETWORK_TOKEN_AUD_MISSING, y.data = e, y;\n      }\n      if (Ee(m, l)) {\n        let E = x(\"The {tokenNamePrefix}-token is formatted with incorrect information.\", o).format({\n            tokenNamePrefix: s\n          }),\n          b = x(\"The {tokenNamePrefix}-token has an incorrect aud value: {aud}. aud value should be {expectedAud}.\", o).format({\n            tokenNamePrefix: s,\n            expectedAud: l,\n            aud: m.aud\n          }),\n          y = new f(E, u, !0, b);\n        return y.errorCategory = t, y.muxCode = D.NETWORK_TOKEN_AUD_MISMATCH, y.data = e, y;\n      }\n    } else {\n      let E = x(\"Authorization error trying to access this {category} URL. If this is a signed URL, you might need to provide a {tokenNamePrefix}-token.\", o).format({\n          tokenNamePrefix: s,\n          category: t\n        }),\n        b = x(\"Specified playback ID: {playbackId}\", o).format({\n          playbackId: T\n        }),\n        y = new f(E, u, n != null ? n : !0, b);\n      return y.errorCategory = t, y.muxCode = D.NETWORK_TOKEN_MISSING, y.data = e, y;\n    }\n    if (c === 412) {\n      let E = x(\"This playback-id may belong to a live stream that is not currently active or an asset that is not ready.\", o),\n        b = x(\"Specified playback ID: {playbackId}\", o).format({\n          playbackId: T\n        }),\n        y = new f(E, u, n != null ? n : !0, b);\n      return y.errorCategory = t, y.muxCode = D.NETWORK_NOT_READY, y.streamType = r.streamType === _.LIVE ? \"live\" : r.streamType === _.ON_DEMAND ? \"on-demand\" : \"unknown\", y.data = e, y;\n    }\n    if (c === 404) {\n      let E = x(\"This URL or playback-id does not exist. You may have used an Asset ID or an ID from a different resource.\", o),\n        b = x(\"Specified playback ID: {playbackId}\", o).format({\n          playbackId: T\n        }),\n        y = new f(E, u, n != null ? n : !0, b);\n      return y.errorCategory = t, y.muxCode = D.NETWORK_NOT_FOUND, y.data = e, y;\n    }\n    if (c === 400) {\n      let E = x(\"The URL or playback-id was invalid. You may have used an invalid value as a playback-id.\"),\n        b = x(\"Specified playback ID: {playbackId}\", o).format({\n          playbackId: T\n        }),\n        y = new f(E, u, n != null ? n : !0, b);\n      return y.errorCategory = t, y.muxCode = D.NETWORK_INVALID_URL, y.data = e, y;\n    }\n    let R = new f(\"\", u, n != null ? n : !0);\n    return R.errorCategory = t, R.muxCode = D.NETWORK_UNKNOWN_ERROR, R.data = e, R;\n  };\nvar Ie = g.DefaultConfig.capLevelController,\n  j = class j extends Ie {\n    constructor(t) {\n      super(t);\n    }\n    get levels() {\n      var t;\n      return (t = this.hls.levels) != null ? t : [];\n    }\n    getValidLevels(t) {\n      return this.levels.filter((r, n) => this.isLevelAllowed(r) && n <= t);\n    }\n    getMaxLevel(t) {\n      let r = super.getMaxLevel(t),\n        n = this.getValidLevels(t);\n      if (!n[r]) return r;\n      let o = Math.min(n[r].width, n[r].height),\n        a = j.minMaxResolution;\n      return o >= a ? r : Ie.getMaxLevelByMediaSize(n, a * (16 / 9), a);\n    }\n  };\nj.minMaxResolution = 720;\nvar ie = j,\n  Se = ie;\nvar J = {\n    FAIRPLAY: \"fairplay\",\n    PLAYREADY: \"playready\",\n    WIDEVINE: \"widevine\"\n  },\n  ft = e => {\n    if (e.includes(\"fps\")) return J.FAIRPLAY;\n    if (e.includes(\"playready\")) return J.PLAYREADY;\n    if (e.includes(\"widevine\")) return J.WIDEVINE;\n  },\n  Tt = e => {\n    let t = e.split(`\n`).find((r, n, o) => n && o[n - 1].startsWith(\"#EXT-X-STREAM-INF\"));\n    return fetch(t).then(r => r.status !== 200 ? Promise.reject(r) : r.text());\n  },\n  yt = e => {\n    let t = e.split(`\n`).filter(n => n.startsWith(\"#EXT-X-SESSION-DATA\"));\n    if (!t.length) return {};\n    let r = {};\n    for (let n of t) {\n      let o = Et(n),\n        a = o[\"DATA-ID\"];\n      a && (r[a] = {\n        ...o\n      });\n    }\n    return {\n      sessionData: r\n    };\n  },\n  mt = /([A-Z0-9-]+)=\"?(.*?)\"?(?:,|$)/g;\nfunction Et(e) {\n  let t = [...e.matchAll(mt)];\n  return Object.fromEntries(t.map(_ref13 => {\n    let [, r, n] = _ref13;\n    return [r, n];\n  }));\n}\nvar gt = e => {\n    var c, d, u;\n    let t = e.split(`\n`),\n      n = (d = ((c = t.find(s => s.startsWith(\"#EXT-X-PLAYLIST-TYPE\"))) != null ? c : \"\").split(\":\")[1]) == null ? void 0 : d.trim(),\n      o = Q(n),\n      a = Z(n),\n      i;\n    if (o === _.LIVE) {\n      let s = t.find(l => l.startsWith(\"#EXT-X-PART-INF\"));\n      if (!!s) i = +s.split(\":\")[1].split(\"=\")[1] * 2;else {\n        let l = t.find(R => R.startsWith(\"#EXT-X-TARGETDURATION\")),\n          T = (u = l == null ? void 0 : l.split(\":\")) == null ? void 0 : u[1];\n        i = +(T != null ? T : 6) * 3;\n      }\n    }\n    return {\n      streamType: o,\n      targetLiveWindow: a,\n      liveEdgeStartOffset: i\n    };\n  },\n  Mt = async (e, t) => {\n    if (t === A.MP4) return {\n      streamType: _.ON_DEMAND,\n      targetLiveWindow: Number.NaN,\n      liveEdgeStartOffset: void 0,\n      sessionData: void 0\n    };\n    if (t === A.M3U8) {\n      let r = await fetch(e);\n      if (!r.ok) return Promise.reject(r);\n      let n = await r.text(),\n        o = await Tt(n);\n      return {\n        ...yt(n),\n        ...gt(o)\n      };\n    }\n    return console.error(`Media type ${t} is an unrecognized or unsupported type for src ${e}.`), {\n      streamType: void 0,\n      targetLiveWindow: void 0,\n      liveEdgeStartOffset: void 0,\n      sessionData: void 0\n    };\n  },\n  xt = async function (e, t) {\n    let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : U({\n      src: e\n    });\n    var d, u, s, p;\n    let {\n        streamType: n,\n        targetLiveWindow: o,\n        liveEdgeStartOffset: a,\n        sessionData: i\n      } = await Mt(e, r),\n      c = i == null ? void 0 : i[\"com.apple.hls.chapters\"];\n    (c != null && c.URI || c != null && c.VALUE.toLocaleLowerCase().startsWith(\"http\")) && de((d = c.URI) != null ? d : c.VALUE, t), ((u = P.get(t)) != null ? u : {}).liveEdgeStartOffset = a, ((s = P.get(t)) != null ? s : {}).targetLiveWindow = o, t.dispatchEvent(new CustomEvent(\"targetlivewindowchange\", {\n      composed: !0,\n      bubbles: !0\n    })), ((p = P.get(t)) != null ? p : {}).streamType = n, t.dispatchEvent(new CustomEvent(\"streamtypechange\", {\n      composed: !0,\n      bubbles: !0\n    }));\n  },\n  de = async (e, t) => {\n    var r, n;\n    try {\n      let o = await fetch(e);\n      if (!o.ok) throw new Error(`Failed to fetch Mux metadata: ${o.status} ${o.statusText}`);\n      let a = await o.json(),\n        i = {};\n      if (!((r = a == null ? void 0 : a[0]) != null && r.metadata)) return;\n      for (let d of a[0].metadata) d.key && d.value && (i[d.key] = d.value);\n      ((n = P.get(t)) != null ? n : {}).metadata = i;\n      let c = new CustomEvent(\"muxmetadata\");\n      t.dispatchEvent(c);\n    } catch (o) {\n      console.error(o);\n    }\n  },\n  Rt = e => {\n    var i;\n    let t = e.type,\n      r = Q(t),\n      n = Z(t),\n      o,\n      a = !!((i = e.partList) != null && i.length);\n    return r === _.LIVE && (o = a ? e.partTarget * 2 : e.targetduration * 3), {\n      streamType: r,\n      targetLiveWindow: n,\n      liveEdgeStartOffset: o,\n      lowLatency: a\n    };\n  },\n  Dt = (e, t, r) => {\n    var c, d, u, s, p, l, T, m;\n    let {\n      streamType: n,\n      targetLiveWindow: o,\n      liveEdgeStartOffset: a,\n      lowLatency: i\n    } = Rt(e);\n    if (n === _.LIVE) {\n      i ? (r.config.backBufferLength = (c = r.userConfig.backBufferLength) != null ? c : 4, r.config.maxFragLookUpTolerance = (d = r.userConfig.maxFragLookUpTolerance) != null ? d : .001, r.config.abrBandWidthUpFactor = (u = r.userConfig.abrBandWidthUpFactor) != null ? u : r.config.abrBandWidthFactor) : r.config.backBufferLength = (s = r.userConfig.backBufferLength) != null ? s : 8;\n      let R = Object.freeze({\n        get length() {\n          return t.seekable.length;\n        },\n        start(M) {\n          return t.seekable.start(M);\n        },\n        end(M) {\n          var h;\n          return M > this.length || M < 0 || Number.isFinite(t.duration) ? t.seekable.end(M) : (h = r.liveSyncPosition) != null ? h : t.seekable.end(M);\n        }\n      });\n      ((p = P.get(t)) != null ? p : {}).seekable = R;\n    }\n    ((l = P.get(t)) != null ? l : {}).liveEdgeStartOffset = a, ((T = P.get(t)) != null ? T : {}).targetLiveWindow = o, t.dispatchEvent(new CustomEvent(\"targetlivewindowchange\", {\n      composed: !0,\n      bubbles: !0\n    })), ((m = P.get(t)) != null ? m : {}).streamType = n, t.dispatchEvent(new CustomEvent(\"streamtypechange\", {\n      composed: !0,\n      bubbles: !0\n    }));\n  },\n  Oe,\n  Ue,\n  bt = (Ue = (Oe = globalThis == null ? void 0 : globalThis.navigator) == null ? void 0 : Oe.userAgent) != null ? Ue : \"\",\n  He,\n  Ve,\n  Ke,\n  Ct = (Ke = (Ve = (He = globalThis == null ? void 0 : globalThis.navigator) == null ? void 0 : He.userAgentData) == null ? void 0 : Ve.platform) != null ? Ke : \"\",\n  vt = bt.toLowerCase().includes(\"android\") || [\"x11\", \"android\"].some(e => Ct.toLowerCase().includes(e)),\n  P = new WeakMap(),\n  I = \"mux.com\",\n  We,\n  Ye,\n  Fe = (Ye = (We = g).isSupported) == null ? void 0 : Ye.call(We),\n  Pt = vt,\n  Wr = () => ue.utils.now(),\n  _t = ue.utils.generateUUID,\n  Yr = function () {\n    let {\n      playbackId: e,\n      customDomain: t = I,\n      maxResolution: r,\n      minResolution: n,\n      renditionOrder: o,\n      programStartTime: a,\n      programEndTime: i,\n      assetStartTime: c,\n      assetEndTime: d,\n      playbackToken: u,\n      tokens: {\n        playback: s = u\n      } = {},\n      extraSourceParams: p = {}\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!e) return;\n    let [l, T = \"\"] = F(e),\n      m = new URL(`https://stream.${t}/${l}.m3u8${T}`);\n    return s || m.searchParams.has(\"token\") ? (m.searchParams.forEach((R, M) => {\n      M != \"token\" && m.searchParams.delete(M);\n    }), s && m.searchParams.set(\"token\", s)) : (r && m.searchParams.set(\"max_resolution\", r), n && (m.searchParams.set(\"min_resolution\", n), r && +r.slice(0, -1) < +n.slice(0, -1) && console.error(\"minResolution must be <= maxResolution\", \"minResolution\", n, \"maxResolution\", r)), o && m.searchParams.set(\"rendition_order\", o), a && m.searchParams.set(\"program_start_time\", `${a}`), i && m.searchParams.set(\"program_end_time\", `${i}`), c && m.searchParams.set(\"asset_start_time\", `${c}`), d && m.searchParams.set(\"asset_end_time\", `${d}`), Object.entries(p).forEach(_ref14 => {\n      let [R, M] = _ref14;\n      M != null && m.searchParams.set(R, M);\n    })), m.toString();\n  },\n  G = e => {\n    if (!e) return;\n    let [t] = e.split(\"?\");\n    return t || void 0;\n  },\n  $e = e => {\n    if (!e || !e.startsWith(\"https://stream.\")) return;\n    let [t] = new URL(e).pathname.slice(1).split(/\\.m3u8|\\//);\n    return t || void 0;\n  },\n  kt = e => {\n    var t, r, n;\n    return (t = e == null ? void 0 : e.metadata) != null && t.video_id ? e.metadata.video_id : Xe(e) && (n = (r = G(e.playbackId)) != null ? r : $e(e.src)) != null ? n : e.src;\n  },\n  ht = e => {\n    var t;\n    return (t = P.get(e)) == null ? void 0 : t.error;\n  },\n  Fr = e => {\n    var t;\n    return (t = P.get(e)) == null ? void 0 : t.metadata;\n  },\n  we = e => {\n    var t, r;\n    return (r = (t = P.get(e)) == null ? void 0 : t.streamType) != null ? r : _.UNKNOWN;\n  },\n  $r = e => {\n    var t, r;\n    return (r = (t = P.get(e)) == null ? void 0 : t.targetLiveWindow) != null ? r : Number.NaN;\n  },\n  Be = e => {\n    var t, r;\n    return (r = (t = P.get(e)) == null ? void 0 : t.seekable) != null ? r : e.seekable;\n  },\n  Br = e => {\n    var n;\n    let t = (n = P.get(e)) == null ? void 0 : n.liveEdgeStartOffset;\n    if (typeof t != \"number\") return Number.NaN;\n    let r = Be(e);\n    return r.length ? r.end(r.length - 1) - t : Number.NaN;\n  },\n  le = .034,\n  Lt = function (e, t) {\n    let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : le;\n    return Math.abs(e - t) <= r;\n  },\n  je = function (e, t) {\n    let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : le;\n    return e > t || Lt(e, t, r);\n  },\n  Nt = function (e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : le;\n    return e.paused && je(e.currentTime, e.duration, t);\n  },\n  Je = (e, t) => {\n    var u, s, p;\n    if (!t || !e.buffered.length) return;\n    if (e.readyState > 2) return !1;\n    let r = t.currentLevel >= 0 ? (s = (u = t.levels) == null ? void 0 : u[t.currentLevel]) == null ? void 0 : s.details : (p = t.levels.find(l => !!l.details)) == null ? void 0 : p.details;\n    if (!r || r.live) return;\n    let {\n      fragments: n\n    } = r;\n    if (!(n != null && n.length)) return;\n    if (e.currentTime < e.duration - (r.targetduration + .5)) return !1;\n    let o = n[n.length - 1];\n    if (e.currentTime <= o.start) return !1;\n    let a = o.start + o.duration / 2,\n      i = e.buffered.start(e.buffered.length - 1),\n      c = e.buffered.end(e.buffered.length - 1);\n    return a > i && a < c;\n  },\n  At = (e, t) => e.ended || e.loop ? e.ended : t && Je(e, t) ? !0 : Nt(e),\n  jr = (e, t, r) => {\n    It(t, r, e);\n    let {\n        metadata: n = {}\n      } = e,\n      {\n        view_session_id: o = _t()\n      } = n,\n      a = kt(e);\n    n.view_session_id = o, n.video_id = a, e.metadata = n;\n    let i = s => {\n      var p;\n      (p = t.mux) == null || p.emit(\"hb\", {\n        view_drm_type: s\n      });\n    };\n    e.drmTypeCb = i, P.set(t, {\n      retryCount: 0\n    });\n    let c = St(e, t),\n      d = Re(e, t, c);\n    e != null && e.muxDataKeepSession && t != null && t.mux && !t.mux.deleted ? c && t.mux.addHLSJS({\n      hlsjs: c,\n      Hls: c ? g : void 0\n    }) : Kt(e, t, c), Wt(e, t, c), ke(t), Ae(t);\n    let u = xe(e, t, c);\n    return {\n      engine: c,\n      setAutoplay: u,\n      setPreload: d\n    };\n  },\n  It = (e, t, r) => {\n    let n = t == null ? void 0 : t.engine;\n    e != null && e.mux && !e.mux.deleted && (r != null && r.muxDataKeepSession ? n && e.mux.removeHLSJS() : (e.mux.destroy(), delete e.mux)), n && (n.detachMedia(), n.destroy()), e && (e.hasAttribute(\"src\") && (e.removeAttribute(\"src\"), e.load()), e.removeEventListener(\"error\", Qe), e.removeEventListener(\"error\", ce), e.removeEventListener(\"durationchange\", ze), P.delete(e), e.dispatchEvent(new Event(\"teardown\")));\n  };\nfunction qe(e, t) {\n  var u;\n  let r = U(e);\n  if (!(r === A.M3U8)) return !0;\n  let o = !r || ((u = t.canPlayType(r)) != null ? u : !0),\n    {\n      preferPlayback: a\n    } = e,\n    i = a === X.MSE,\n    c = a === X.NATIVE;\n  return o && (c || !(Fe && (i || Pt)));\n}\nvar St = (e, t) => {\n    let {\n        debug: r,\n        streamType: n,\n        startTime: o = -1,\n        metadata: a,\n        preferCmcd: i,\n        _hlsConfig: c = {}\n      } = e,\n      u = U(e) === A.M3U8,\n      s = qe(e, t);\n    if (u && !s && Fe) {\n      let p = {\n          backBufferLength: 30,\n          renderTextTracksNatively: !1,\n          liveDurationInfinity: !0,\n          capLevelToPlayerSize: !0,\n          capLevelOnFPSDrop: !0\n        },\n        l = wt(n),\n        T = Ot(e),\n        m = [S.QUERY, S.HEADER].includes(i) ? {\n          useHeaders: i === S.HEADER,\n          sessionId: a == null ? void 0 : a.view_session_id,\n          contentId: a == null ? void 0 : a.video_id\n        } : void 0,\n        R = new g({\n          debug: r,\n          startPosition: o,\n          cmcd: m,\n          xhrSetup: (M, h) => {\n            var y, k;\n            if (i && i !== S.QUERY) return;\n            let E = new URL(h);\n            if (!E.searchParams.has(\"CMCD\")) return;\n            let b = ((k = (y = E.searchParams.get(\"CMCD\")) == null ? void 0 : y.split(\",\")) != null ? k : []).filter(pe => pe.startsWith(\"sid\") || pe.startsWith(\"cid\")).join(\",\");\n            E.searchParams.set(\"CMCD\", b), M.open(\"GET\", E);\n          },\n          capLevelController: Se,\n          ...p,\n          ...l,\n          ...T,\n          ...c\n        });\n      return R.on(g.Events.MANIFEST_PARSED, async function (M, h) {\n        var b, y;\n        let E = (b = h.sessionData) == null ? void 0 : b[\"com.apple.hls.chapters\"];\n        (E != null && E.URI || E != null && E.VALUE.toLocaleLowerCase().startsWith(\"http\")) && de((y = E == null ? void 0 : E.URI) != null ? y : E == null ? void 0 : E.VALUE, t);\n      }), R;\n    }\n  },\n  wt = e => e === _.LIVE ? {\n    backBufferLength: 8\n  } : {},\n  Ot = e => {\n    let {\n        tokens: {\n          drm: t\n        } = {},\n        playbackId: r,\n        drmTypeCb: n\n      } = e,\n      o = G(r);\n    return !t || !o ? {} : {\n      emeEnabled: !0,\n      drmSystems: {\n        \"com.apple.fps\": {\n          licenseUrl: q(e, \"fairplay\"),\n          serverCertificateUrl: Ge(e, \"fairplay\")\n        },\n        \"com.widevine.alpha\": {\n          licenseUrl: q(e, \"widevine\")\n        },\n        \"com.microsoft.playready\": {\n          licenseUrl: q(e, \"playready\")\n        }\n      },\n      requestMediaKeySystemAccessFunc: (a, i) => (a === \"com.widevine.alpha\" && (i = [...i.map(c => {\n        var u;\n        let d = (u = c.videoCapabilities) == null ? void 0 : u.map(s => ({\n          ...s,\n          robustness: \"HW_SECURE_ALL\"\n        }));\n        return {\n          ...c,\n          videoCapabilities: d\n        };\n      }), ...i]), navigator.requestMediaKeySystemAccess(a, i).then(c => {\n        let d = ft(a);\n        return n == null || n(d), c;\n      }))\n    };\n  },\n  Ut = async e => {\n    let t = await fetch(e);\n    return t.status !== 200 ? Promise.reject(t) : await t.arrayBuffer();\n  },\n  Ht = async (e, t) => {\n    let r = await fetch(t, {\n      method: \"POST\",\n      headers: {\n        \"Content-type\": \"application/octet-stream\"\n      },\n      body: e\n    });\n    if (r.status !== 200) return Promise.reject(r);\n    let n = await r.arrayBuffer();\n    return new Uint8Array(n);\n  },\n  Vt = (e, t) => {\n    v(t, \"encrypted\", async n => {\n      try {\n        let o = n.initDataType;\n        if (o !== \"skd\") {\n          console.error(`Received unexpected initialization data type \"${o}\"`);\n          return;\n        }\n        if (!t.mediaKeys) {\n          let u = await navigator.requestMediaKeySystemAccess(\"com.apple.fps\", [{\n            initDataTypes: [o],\n            videoCapabilities: [{\n              contentType: \"application/vnd.apple.mpegurl\",\n              robustness: \"\"\n            }],\n            distinctiveIdentifier: \"not-allowed\",\n            persistentState: \"not-allowed\",\n            sessionTypes: [\"temporary\"]\n          }]).then(p => {\n            var l;\n            return (l = e.drmTypeCb) == null || l.call(e, J.FAIRPLAY), p;\n          }).catch(() => {\n            let p = x(\"Cannot play DRM-protected content with current security configuration on this browser. Try playing in another browser.\"),\n              l = new f(p, f.MEDIA_ERR_ENCRYPTED, !0);\n            l.errorCategory = C.DRM, l.muxCode = D.ENCRYPTED_UNSUPPORTED_KEY_SYSTEM, N(t, l);\n          });\n          if (!u) return;\n          let s = await u.createMediaKeys();\n          try {\n            let p = await Ut(Ge(e, \"fairplay\")).catch(l => {\n              if (l instanceof Response) {\n                let T = H(l, C.DRM, e);\n                return console.error(\"mediaError\", T == null ? void 0 : T.message, T == null ? void 0 : T.context), T ? Promise.reject(T) : Promise.reject(new Error(\"Unexpected error in app cert request\"));\n              }\n              return Promise.reject(l);\n            });\n            await s.setServerCertificate(p).catch(() => {\n              let l = x(\"Your server certificate failed when attempting to set it. This may be an issue with a no longer valid certificate.\"),\n                T = new f(l, f.MEDIA_ERR_ENCRYPTED, !0);\n              return T.errorCategory = C.DRM, T.muxCode = D.ENCRYPTED_UPDATE_SERVER_CERT_FAILED, Promise.reject(T);\n            });\n          } catch (p) {\n            N(t, p);\n            return;\n          }\n          await t.setMediaKeys(s);\n        }\n        let a = n.initData;\n        if (a == null) {\n          console.error(`Could not start encrypted playback due to missing initData in ${n.type} event`);\n          return;\n        }\n        let i = t.mediaKeys.createSession();\n        i.addEventListener(\"keystatuseschange\", () => {\n          i.keyStatuses.forEach(u => {\n            let s;\n            if (u === \"internal-error\") {\n              let p = x(\"The DRM Content Decryption Module system had an internal failure. Try reloading the page, upading your browser, or playing in another browser.\");\n              s = new f(p, f.MEDIA_ERR_ENCRYPTED, !0), s.errorCategory = C.DRM, s.muxCode = D.ENCRYPTED_CDM_ERROR;\n            } else if (u === \"output-restricted\" || u === \"output-downscaled\") {\n              let p = x(\"DRM playback is being attempted in an environment that is not sufficiently secure. User may see black screen.\");\n              s = new f(p, f.MEDIA_ERR_ENCRYPTED, !1), s.errorCategory = C.DRM, s.muxCode = D.ENCRYPTED_OUTPUT_RESTRICTED;\n            }\n            s && N(t, s);\n          });\n        });\n        let c = await Promise.all([i.generateRequest(o, a).catch(() => {\n            let u = x(\"Failed to generate a DRM license request. This may be an issue with the player or your protected content.\"),\n              s = new f(u, f.MEDIA_ERR_ENCRYPTED, !0);\n            s.errorCategory = C.DRM, s.muxCode = D.ENCRYPTED_GENERATE_REQUEST_FAILED, N(t, s);\n          }), new Promise(u => {\n            i.addEventListener(\"message\", s => {\n              u(s.message);\n            }, {\n              once: !0\n            });\n          })]).then(_ref15 => {\n            let [, u] = _ref15;\n            return u;\n          }),\n          d = await Ht(c, q(e, \"fairplay\")).catch(u => {\n            if (u instanceof Response) {\n              let s = H(u, C.DRM, e);\n              return console.error(\"mediaError\", s == null ? void 0 : s.message, s == null ? void 0 : s.context), s ? Promise.reject(s) : Promise.reject(new Error(\"Unexpected error in license key request\"));\n            }\n            return Promise.reject(u);\n          });\n        await i.update(d).catch(() => {\n          let u = x(\"Failed to update DRM license. This may be an issue with the player or your protected content.\"),\n            s = new f(u, f.MEDIA_ERR_ENCRYPTED, !0);\n          return s.errorCategory = C.DRM, s.muxCode = D.ENCRYPTED_UPDATE_LICENSE_FAILED, Promise.reject(s);\n        });\n      } catch (o) {\n        N(t, o);\n        return;\n      }\n    });\n  },\n  q = (_ref16, n) => {\n    let {\n      playbackId: e,\n      tokens: {\n        drm: t\n      } = {},\n      customDomain: r = I\n    } = _ref16;\n    let o = G(e);\n    return `https://license.${r.toLocaleLowerCase().endsWith(I) ? r : I}/license/${n}/${o}?token=${t}`;\n  },\n  Ge = (_ref17, n) => {\n    let {\n      playbackId: e,\n      tokens: {\n        drm: t\n      } = {},\n      customDomain: r = I\n    } = _ref17;\n    let o = G(e);\n    return `https://license.${r.toLocaleLowerCase().endsWith(I) ? r : I}/appcert/${n}/${o}?token=${t}`;\n  },\n  Xe = _ref18 => {\n    let {\n      playbackId: e,\n      src: t,\n      customDomain: r\n    } = _ref18;\n    if (e) return !0;\n    if (typeof t != \"string\") return !1;\n    let n = window == null ? void 0 : window.location.href,\n      o = new URL(t, n).hostname.toLocaleLowerCase();\n    return o.includes(I) || !!r && o.includes(r.toLocaleLowerCase());\n  },\n  Kt = (e, t, r) => {\n    var d;\n    let {\n        envKey: n,\n        disableTracking: o,\n        muxDataSDK: a = ue,\n        muxDataSDKOptions: i = {}\n      } = e,\n      c = Xe(e);\n    if (!o && (n || c)) {\n      let {\n          playerInitTime: u,\n          playerSoftwareName: s,\n          playerSoftwareVersion: p,\n          beaconCollectionDomain: l,\n          debug: T,\n          disableCookies: m\n        } = e,\n        R = {\n          ...e.metadata,\n          video_title: ((d = e == null ? void 0 : e.metadata) == null ? void 0 : d.video_title) || void 0\n        },\n        M = h => typeof h.player_error_code == \"string\" ? !1 : typeof e.errorTranslator == \"function\" ? e.errorTranslator(h) : h;\n      a.monitor(t, {\n        debug: T,\n        beaconCollectionDomain: l,\n        hlsjs: r,\n        Hls: r ? g : void 0,\n        automaticErrorTracking: !1,\n        errorTranslator: M,\n        disableCookies: m,\n        ...i,\n        data: {\n          ...(n ? {\n            env_key: n\n          } : {}),\n          player_software_name: s,\n          player_software: s,\n          player_software_version: p,\n          player_init_time: u,\n          ...R\n        }\n      });\n    }\n  },\n  Wt = (e, t, r) => {\n    var s, p;\n    let n = qe(e, t),\n      {\n        src: o,\n        customDomain: a = I\n      } = e,\n      i = () => {\n        t.ended || !At(t, r) || (Je(t, r) ? t.currentTime = t.buffered.end(t.buffered.length - 1) : t.dispatchEvent(new Event(\"ended\")));\n      },\n      c,\n      d,\n      u = () => {\n        let l = Be(t),\n          T,\n          m;\n        l.length > 0 && (T = l.start(0), m = l.end(0)), (d !== m || c !== T) && t.dispatchEvent(new CustomEvent(\"seekablechange\", {\n          composed: !0\n        })), c = T, d = m;\n      };\n    if (v(t, \"durationchange\", u), t && n) {\n      let l = U(e);\n      if (typeof o == \"string\") {\n        if (o.endsWith(\".mp4\") && o.includes(a)) {\n          let R = $e(o),\n            M = new URL(`https://stream.${a}/${R}/metadata.json`);\n          de(M.toString(), t);\n        }\n        let T = () => {\n            if (we(t) !== _.LIVE || Number.isFinite(t.duration)) return;\n            let R = setInterval(u, 1e3);\n            t.addEventListener(\"teardown\", () => {\n              clearInterval(R);\n            }, {\n              once: !0\n            }), v(t, \"durationchange\", () => {\n              Number.isFinite(t.duration) && clearInterval(R);\n            });\n          },\n          m = async () => xt(o, t, l).then(T).catch(R => {\n            if (R instanceof Response) {\n              let M = H(R, C.VIDEO, e);\n              if (M) {\n                N(t, M);\n                return;\n              }\n            } else R instanceof Error;\n          });\n        if (t.preload === \"none\") {\n          let R = () => {\n              m(), t.removeEventListener(\"loadedmetadata\", M);\n            },\n            M = () => {\n              m(), t.removeEventListener(\"play\", R);\n            };\n          v(t, \"play\", R, {\n            once: !0\n          }), v(t, \"loadedmetadata\", M, {\n            once: !0\n          });\n        } else m();\n        (s = e.tokens) != null && s.drm ? Vt(e, t) : v(t, \"encrypted\", () => {\n          let R = x(\"Attempting to play DRM-protected content without providing a DRM token.\"),\n            M = new f(R, f.MEDIA_ERR_ENCRYPTED, !0);\n          M.errorCategory = C.DRM, M.muxCode = D.ENCRYPTED_MISSING_TOKEN, N(t, M);\n        }, {\n          once: !0\n        }), t.setAttribute(\"src\", o), e.startTime && (((p = P.get(t)) != null ? p : {}).startTime = e.startTime, t.addEventListener(\"durationchange\", ze, {\n          once: !0\n        }));\n      } else t.removeAttribute(\"src\");\n      t.addEventListener(\"error\", Qe), t.addEventListener(\"error\", ce), t.addEventListener(\"emptied\", () => {\n        t.querySelectorAll(\"track[data-removeondestroy]\").forEach(m => {\n          m.remove();\n        });\n      }, {\n        once: !0\n      }), v(t, \"pause\", i), v(t, \"seeked\", i), v(t, \"play\", () => {\n        t.ended || je(t.currentTime, t.duration) && (t.currentTime = t.seekable.length ? t.seekable.start(0) : 0);\n      });\n    } else r && o ? (r.once(g.Events.LEVEL_LOADED, (l, T) => {\n      Dt(T.details, t, r), u(), we(t) === _.LIVE && !Number.isFinite(t.duration) && (r.on(g.Events.LEVEL_UPDATED, u), v(t, \"durationchange\", () => {\n        Number.isFinite(t.duration) && r.off(g.Events.LEVELS_UPDATED, u);\n      }));\n    }), r.on(g.Events.ERROR, (l, T) => {\n      var R, M;\n      let m = Yt(T, e);\n      if (m.muxCode === D.NETWORK_NOT_READY) {\n        let E = (R = P.get(t)) != null ? R : {},\n          b = (M = E.retryCount) != null ? M : 0;\n        if (b < 6) {\n          let y = b === 0 ? 5e3 : 6e4,\n            k = new f(`Retrying in ${y / 1e3} seconds...`, m.code, m.fatal);\n          Object.assign(k, m), N(t, k), setTimeout(() => {\n            E.retryCount = b + 1, T.details === \"manifestLoadError\" && T.url && r.loadSource(T.url);\n          }, y);\n          return;\n        } else {\n          E.retryCount = 0;\n          let y = new f('Try again later or <a href=\"#\" onclick=\"window.location.reload(); return false;\" style=\"color: #4a90e2;\">click here to retry</a>', m.code, m.fatal);\n          Object.assign(y, m), N(t, y);\n          return;\n        }\n      }\n      N(t, m);\n    }), r.on(g.Events.MANIFEST_LOADED, () => {\n      let l = P.get(t);\n      l && l.error && (l.error = null, l.retryCount = 0, t.dispatchEvent(new Event(\"emptied\")), t.dispatchEvent(new Event(\"loadstart\")));\n    }), t.addEventListener(\"error\", ce), v(t, \"waiting\", i), De(e, r), be(t, r), r.attachMedia(t)) : console.error(\"It looks like the video you're trying to play will not work on this system! If possible, try upgrading to the newest versions of your browser or software.\");\n  };\nfunction ze(e) {\n  var n;\n  let t = e.target,\n    r = (n = P.get(t)) == null ? void 0 : n.startTime;\n  if (r && fe(t.seekable, t.duration, r)) {\n    let o = t.preload === \"auto\";\n    o && (t.preload = \"none\"), t.currentTime = r, o && (t.preload = \"auto\");\n  }\n}\nasync function Qe(e) {\n  if (!e.isTrusted) return;\n  e.stopImmediatePropagation();\n  let t = e.target;\n  if (!(t != null && t.error)) return;\n  let {\n      message: r,\n      code: n\n    } = t.error,\n    o = new f(r, n);\n  if (t.src && n === f.MEDIA_ERR_SRC_NOT_SUPPORTED && t.readyState === HTMLMediaElement.HAVE_NOTHING) {\n    setTimeout(() => {\n      var i;\n      let a = (i = ht(t)) != null ? i : t.error;\n      (a == null ? void 0 : a.code) === f.MEDIA_ERR_SRC_NOT_SUPPORTED && N(t, o);\n    }, 500);\n    return;\n  }\n  if (t.src && (n !== f.MEDIA_ERR_DECODE || n !== void 0)) try {\n    let {\n      status: a\n    } = await fetch(t.src);\n    o.data = {\n      response: {\n        code: a\n      }\n    };\n  } catch {}\n  N(t, o);\n}\nfunction N(e, t) {\n  var r;\n  t.fatal && (((r = P.get(e)) != null ? r : {}).error = t, e.dispatchEvent(new CustomEvent(\"error\", {\n    detail: t\n  })));\n}\nfunction ce(e) {\n  var n, o;\n  if (!(e instanceof CustomEvent) || !(e.detail instanceof f)) return;\n  let t = e.target,\n    r = e.detail;\n  !r || !r.fatal || (((n = P.get(t)) != null ? n : {}).error = r, (o = t.mux) == null || o.emit(\"error\", {\n    player_error_code: r.code,\n    player_error_message: r.message,\n    player_error_context: r.context\n  }));\n}\nvar Yt = (e, t) => {\n  var c, d, u;\n  console.error(\"getErrorFromHlsErrorData()\", e);\n  let r = {\n      [g.ErrorTypes.NETWORK_ERROR]: f.MEDIA_ERR_NETWORK,\n      [g.ErrorTypes.MEDIA_ERROR]: f.MEDIA_ERR_DECODE,\n      [g.ErrorTypes.KEY_SYSTEM_ERROR]: f.MEDIA_ERR_ENCRYPTED\n    },\n    n = s => [g.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED, g.ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED].includes(s.details) ? f.MEDIA_ERR_NETWORK : r[s.type],\n    o = s => {\n      if (s.type === g.ErrorTypes.KEY_SYSTEM_ERROR) return C.DRM;\n      if (s.type === g.ErrorTypes.NETWORK_ERROR) return C.VIDEO;\n    },\n    a,\n    i = n(e);\n  if (i === f.MEDIA_ERR_NETWORK && e.response) {\n    let s = (c = o(e)) != null ? c : C.VIDEO;\n    a = (d = H(e.response, s, t, e.fatal)) != null ? d : new f(\"\", i, e.fatal);\n  } else if (i === f.MEDIA_ERR_ENCRYPTED) {\n    if (e.details === g.ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE) {\n      let s = x(\"Attempting to play DRM-protected content without providing a DRM token.\");\n      a = new f(s, f.MEDIA_ERR_ENCRYPTED, e.fatal), a.errorCategory = C.DRM, a.muxCode = D.ENCRYPTED_MISSING_TOKEN;\n    } else if (e.details === g.ErrorDetails.KEY_SYSTEM_NO_ACCESS) {\n      let s = x(\"Cannot play DRM-protected content with current security configuration on this browser. Try playing in another browser.\");\n      a = new f(s, f.MEDIA_ERR_ENCRYPTED, e.fatal), a.errorCategory = C.DRM, a.muxCode = D.ENCRYPTED_UNSUPPORTED_KEY_SYSTEM;\n    } else if (e.details === g.ErrorDetails.KEY_SYSTEM_NO_SESSION) {\n      let s = x(\"Failed to generate a DRM license request. This may be an issue with the player or your protected content.\");\n      a = new f(s, f.MEDIA_ERR_ENCRYPTED, !0), a.errorCategory = C.DRM, a.muxCode = D.ENCRYPTED_GENERATE_REQUEST_FAILED;\n    } else if (e.details === g.ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED) {\n      let s = x(\"Failed to update DRM license. This may be an issue with the player or your protected content.\");\n      a = new f(s, f.MEDIA_ERR_ENCRYPTED, e.fatal), a.errorCategory = C.DRM, a.muxCode = D.ENCRYPTED_UPDATE_LICENSE_FAILED;\n    } else if (e.details === g.ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED) {\n      let s = x(\"Your server certificate failed when attempting to set it. This may be an issue with a no longer valid certificate.\");\n      a = new f(s, f.MEDIA_ERR_ENCRYPTED, e.fatal), a.errorCategory = C.DRM, a.muxCode = D.ENCRYPTED_UPDATE_SERVER_CERT_FAILED;\n    } else if (e.details === g.ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR) {\n      let s = x(\"The DRM Content Decryption Module system had an internal failure. Try reloading the page, upading your browser, or playing in another browser.\");\n      a = new f(s, f.MEDIA_ERR_ENCRYPTED, e.fatal), a.errorCategory = C.DRM, a.muxCode = D.ENCRYPTED_CDM_ERROR;\n    } else if (e.details === g.ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED) {\n      let s = x(\"DRM playback is being attempted in an environment that is not sufficiently secure. User may see black screen.\");\n      a = new f(s, f.MEDIA_ERR_ENCRYPTED, !1), a.errorCategory = C.DRM, a.muxCode = D.ENCRYPTED_OUTPUT_RESTRICTED;\n    } else a = new f(e.error.message, f.MEDIA_ERR_ENCRYPTED, e.fatal), a.errorCategory = C.DRM, a.muxCode = D.ENCRYPTED_ERROR;\n  } else a = new f(\"\", i, e.fatal);\n  return a.context || (a.context = `${e.url ? `url: ${e.url}\n` : \"\"}${e.response && (e.response.code || e.response.text) ? `response: ${e.response.code}, ${e.response.text}\n` : \"\"}${e.reason ? `failure reason: ${e.reason}\n` : \"\"}${e.level ? `level: ${e.level}\n` : \"\"}${e.parent ? `parent stream controller: ${e.parent}\n` : \"\"}${e.buffer ? `buffer length: ${e.buffer}\n` : \"\"}${e.error ? `error: ${e.error}\n` : \"\"}${e.event ? `event: ${e.event}\n` : \"\"}${e.err ? `error message: ${(u = e.err) == null ? void 0 : u.message}\n` : \"\"}`), a.data = e, a;\n};\nexport { K as AutoplayTypes, jt as CmcdTypeValues, S as CmcdTypes, A as ExtensionMimeTypeMap, g as Hls, Gt as MaxResolution, f as MediaError, W as MimeTypeShorthandMap, Xt as MinResolution, C as MuxErrorCategory, D as MuxErrorCode, se as MuxJWTAud, X as PlaybackTypes, zt as RenditionOrder, _ as StreamTypes, Le as addChapters, Pe as addCuePoints, ne as addTextTrack, qt as allMediaTypes, V as errorCategoryToTokenNameOrPrefix, de as fetchAndDispatchMuxMetadata, Wr as generatePlayerInitTime, _t as generateUUID, Ne as getActiveChapter, _e as getActiveCuePoint, Ut as getAppCertificate, ct as getChapters, it as getCuePoints, dt as getCurrentPdt, Ot as getDRMConfig, At as getEnded, ht as getError, Ht as getLicenseKey, Br as getLiveEdgeStart, Tt as getMediaPlaylistFromMultivariantPlaylist, Fr as getMetadata, yt as getMultivariantPlaylistSessionData, Be as getSeekable, ut as getStartDate, Rt as getStreamInfoFromHlsjsLevelDetails, gt as getStreamInfoFromPlaylist, Mt as getStreamInfoFromSrcAndType, we as getStreamType, wt as getStreamTypeConfig, $r as getTargetLiveWindow, w as getTextTrack, x as i18n, jr as initialize, O as isKeyOf, Xe as isMuxVideoSrc, Nt as isPseudoEnded, Je as isStuckOnLastFragment, Wt as loadMedia, ue as mux, P as muxMediaState, ee as parseJwt, Et as parseTagAttributes, st as removeTextTrack, Ae as setupChapters, ke as setupCuePoints, St as setupHls, Kt as setupMux, Vt as setupNativeFairplayDRM, Jt as shorthandKeys, It as teardown, Ge as toAppCertURL, ft as toDRMTypeFromKeySystem, q as toLicenseKeyURL, Yr as toMuxVideoURL, $e as toPlaybackIdFromSrc, F as toPlaybackIdParts, Dt as updateStreamInfoFromHlsjsLevelDetails, xt as updateStreamInfoFromSrc };","map":null,"metadata":{},"sourceType":"module"}