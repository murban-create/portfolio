{"ast":null,"code":"var __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _slot;\nimport { MediaTextDisplay } from \"./media-text-display.js\";\nimport { getBooleanAttr, getNumericAttr, getOrInsertCSSRule, setBooleanAttr, setNumericAttr } from \"./utils/element-utils.js\";\nimport { globalThis } from \"./utils/server-safe-globals.js\";\nimport { formatAsTimePhrase, formatTime } from \"./utils/time.js\";\nimport { MediaUIAttributes } from \"./constants.js\";\nimport { t } from \"./utils/i18n.js\";\nconst Attributes = {\n  REMAINING: \"remaining\",\n  SHOW_DURATION: \"showduration\",\n  NO_TOGGLE: \"notoggle\"\n};\nconst CombinedAttributes = [...Object.values(Attributes), MediaUIAttributes.MEDIA_CURRENT_TIME, MediaUIAttributes.MEDIA_DURATION, MediaUIAttributes.MEDIA_SEEKABLE];\nconst ButtonPressedKeys = [\"Enter\", \" \"];\nconst DEFAULT_TIMES_SEP = \"&nbsp;/&nbsp;\";\nconst formatTimesLabel = function (el) {\n  let {\n    timesSep = DEFAULT_TIMES_SEP\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a, _b;\n  const currentTime = (_a = el.mediaCurrentTime) != null ? _a : 0;\n  const [, seekableEnd] = (_b = el.mediaSeekable) != null ? _b : [];\n  let endTime = 0;\n  if (Number.isFinite(el.mediaDuration)) {\n    endTime = el.mediaDuration;\n  } else if (Number.isFinite(seekableEnd)) {\n    endTime = seekableEnd;\n  }\n  const timeLabel = el.remaining ? formatTime(0 - (endTime - currentTime)) : formatTime(currentTime);\n  if (!el.showDuration) return timeLabel;\n  return `${timeLabel}${timesSep}${formatTime(endTime)}`;\n};\nconst DEFAULT_MISSING_TIME_PHRASE = \"video not loaded, unknown time.\";\nconst updateAriaValueText = el => {\n  var _a;\n  const currentTime = el.mediaCurrentTime;\n  const [, seekableEnd] = (_a = el.mediaSeekable) != null ? _a : [];\n  let endTime = null;\n  if (Number.isFinite(el.mediaDuration)) {\n    endTime = el.mediaDuration;\n  } else if (Number.isFinite(seekableEnd)) {\n    endTime = seekableEnd;\n  }\n  if (currentTime == null || endTime === null) {\n    el.setAttribute(\"aria-valuetext\", DEFAULT_MISSING_TIME_PHRASE);\n    return;\n  }\n  const currentTimePhrase = el.remaining ? formatAsTimePhrase(0 - (endTime - currentTime)) : formatAsTimePhrase(currentTime);\n  if (!el.showDuration) {\n    el.setAttribute(\"aria-valuetext\", currentTimePhrase);\n    return;\n  }\n  const totalTimePhrase = formatAsTimePhrase(endTime);\n  const fullPhrase = `${currentTimePhrase} of ${totalTimePhrase}`;\n  el.setAttribute(\"aria-valuetext\", fullPhrase);\n};\nfunction getSlotTemplateHTML(_attrs, props) {\n  return /*html*/`\n    <slot>${formatTimesLabel(props)}</slot>\n  `;\n}\nclass MediaTimeDisplay extends MediaTextDisplay {\n  constructor() {\n    super();\n    __privateAdd(this, _slot, void 0);\n    __privateSet(this, _slot, this.shadowRoot.querySelector(\"slot\"));\n    __privateGet(this, _slot).innerHTML = `${formatTimesLabel(this)}`;\n  }\n  static get observedAttributes() {\n    return [...super.observedAttributes, ...CombinedAttributes, \"disabled\"];\n  }\n  connectedCallback() {\n    const {\n      style\n    } = getOrInsertCSSRule(this.shadowRoot, \":host(:hover:not([notoggle]))\");\n    style.setProperty(\"cursor\", \"var(--media-cursor, pointer)\");\n    style.setProperty(\"background\", \"var(--media-control-hover-background, rgba(50 50 70 / .7))\");\n    if (!this.hasAttribute(\"disabled\")) {\n      this.enable();\n    }\n    this.setAttribute(\"role\", \"progressbar\");\n    this.setAttribute(\"aria-label\", t(\"playback time\"));\n    const keyUpHandler = evt => {\n      const {\n        key\n      } = evt;\n      if (!ButtonPressedKeys.includes(key)) {\n        this.removeEventListener(\"keyup\", keyUpHandler);\n        return;\n      }\n      this.toggleTimeDisplay();\n    };\n    this.addEventListener(\"keydown\", evt => {\n      const {\n        metaKey,\n        altKey,\n        key\n      } = evt;\n      if (metaKey || altKey || !ButtonPressedKeys.includes(key)) {\n        this.removeEventListener(\"keyup\", keyUpHandler);\n        return;\n      }\n      this.addEventListener(\"keyup\", keyUpHandler);\n    });\n    this.addEventListener(\"click\", this.toggleTimeDisplay);\n    super.connectedCallback();\n  }\n  toggleTimeDisplay() {\n    if (this.noToggle) {\n      return;\n    }\n    if (this.hasAttribute(\"remaining\")) {\n      this.removeAttribute(\"remaining\");\n    } else {\n      this.setAttribute(\"remaining\", \"\");\n    }\n  }\n  disconnectedCallback() {\n    this.disable();\n    super.disconnectedCallback();\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (CombinedAttributes.includes(attrName)) {\n      this.update();\n    } else if (attrName === \"disabled\" && newValue !== oldValue) {\n      if (newValue == null) {\n        this.enable();\n      } else {\n        this.disable();\n      }\n    }\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n  }\n  enable() {\n    this.tabIndex = 0;\n  }\n  disable() {\n    this.tabIndex = -1;\n  }\n  // Own props\n  /**\n   * Whether to show the remaining time\n   */\n  get remaining() {\n    return getBooleanAttr(this, Attributes.REMAINING);\n  }\n  set remaining(show) {\n    setBooleanAttr(this, Attributes.REMAINING, show);\n  }\n  /**\n   * Whether to show the duration\n   */\n  get showDuration() {\n    return getBooleanAttr(this, Attributes.SHOW_DURATION);\n  }\n  set showDuration(show) {\n    setBooleanAttr(this, Attributes.SHOW_DURATION, show);\n  }\n  /**\n   * Disable the default behavior that toggles between current and remaining time\n   */\n  get noToggle() {\n    return getBooleanAttr(this, Attributes.NO_TOGGLE);\n  }\n  set noToggle(noToggle) {\n    setBooleanAttr(this, Attributes.NO_TOGGLE, noToggle);\n  }\n  // Props derived from media UI attributes\n  /**\n   * Get the duration\n   */\n  get mediaDuration() {\n    return getNumericAttr(this, MediaUIAttributes.MEDIA_DURATION);\n  }\n  set mediaDuration(time) {\n    setNumericAttr(this, MediaUIAttributes.MEDIA_DURATION, time);\n  }\n  /**\n   * The current time in seconds\n   */\n  get mediaCurrentTime() {\n    return getNumericAttr(this, MediaUIAttributes.MEDIA_CURRENT_TIME);\n  }\n  set mediaCurrentTime(time) {\n    setNumericAttr(this, MediaUIAttributes.MEDIA_CURRENT_TIME, time);\n  }\n  /**\n   * Range of values that can be seeked to.\n   * An array of two numbers [start, end]\n   */\n  get mediaSeekable() {\n    const seekable = this.getAttribute(MediaUIAttributes.MEDIA_SEEKABLE);\n    if (!seekable) return void 0;\n    return seekable.split(\":\").map(time => +time);\n  }\n  set mediaSeekable(range) {\n    if (range == null) {\n      this.removeAttribute(MediaUIAttributes.MEDIA_SEEKABLE);\n      return;\n    }\n    this.setAttribute(MediaUIAttributes.MEDIA_SEEKABLE, range.join(\":\"));\n  }\n  update() {\n    const timesLabel = formatTimesLabel(this);\n    updateAriaValueText(this);\n    if (timesLabel !== __privateGet(this, _slot).innerHTML) {\n      __privateGet(this, _slot).innerHTML = timesLabel;\n    }\n  }\n}\n_slot = new WeakMap();\nMediaTimeDisplay.getSlotTemplateHTML = getSlotTemplateHTML;\nif (!globalThis.customElements.get(\"media-time-display\")) {\n  globalThis.customElements.define(\"media-time-display\", MediaTimeDisplay);\n}\nvar media_time_display_default = MediaTimeDisplay;\nexport { Attributes, media_time_display_default as default };","map":null,"metadata":{},"sourceType":"module"}