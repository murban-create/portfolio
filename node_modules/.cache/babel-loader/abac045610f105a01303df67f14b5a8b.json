{"ast":null,"code":"var _globalThis$document;\n/**\n * Super Media Element\n * Based on https://github.com/muxinc/custom-video-element - Mux - MIT License\n *\n * The goal is to create an element that works just like the video element\n * but can be extended/sub-classed, because native elements cannot be\n * extended today across browsers. Support for extending async loaded video\n * like API's. e.g. video players.\n */\n\n// The onevent like props are weirdly set on the HTMLElement prototype with other\n// generic events making it impossible to pick these specific to HTMLMediaElement.\nexport const Events = ['abort', 'canplay', 'canplaythrough', 'durationchange', 'emptied', 'encrypted', 'ended', 'error', 'loadeddata', 'loadedmetadata', 'loadstart', 'pause', 'play', 'playing', 'progress', 'ratechange', 'seeked', 'seeking', 'stalled', 'suspend', 'timeupdate', 'volumechange', 'waiting', 'waitingforkey', 'resize', 'enterpictureinpicture', 'leavepictureinpicture', 'webkitbeginfullscreen', 'webkitendfullscreen', 'webkitpresentationmodechanged'];\nexport const template = (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.createElement('template');\nif (template) {\n  template.innerHTML = /*html*/`\n    <style>\n      :host {\n        display: inline-block;\n        line-height: 0;\n      }\n\n      video,\n      audio {\n        max-width: 100%;\n        max-height: 100%;\n        min-width: 100%;\n        min-height: 100%;\n      }\n    </style>\n    <slot></slot>\n  `;\n}\n\n/**\n * @see https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/\n */\nexport const SuperMediaMixin = (superclass, _ref) => {\n  var _globalThis$document2;\n  let {\n    tag,\n    is\n  } = _ref;\n  const nativeElTest = (_globalThis$document2 = globalThis.document) === null || _globalThis$document2 === void 0 ? void 0 : _globalThis$document2.createElement(tag, {\n    is\n  });\n  const nativeElProps = nativeElTest ? getNativeElProps(nativeElTest) : [];\n  return class SuperMedia extends superclass {\n    static Events = Events;\n    static template = template;\n    static skipAttributes = [];\n    static #isDefined;\n    static get observedAttributes() {\n      var _nativeElTest$constru;\n      SuperMedia.#define();\n\n      // Include any attributes from the custom built-in.\n      const natAttrs = (nativeElTest === null || nativeElTest === void 0 ? void 0 : (_nativeElTest$constru = nativeElTest.constructor) === null || _nativeElTest$constru === void 0 ? void 0 : _nativeElTest$constru.observedAttributes) ?? [];\n      return [...natAttrs, 'autopictureinpicture', 'disablepictureinpicture', 'disableremoteplayback', 'autoplay', 'controls', 'controlslist', 'crossorigin', 'loop', 'muted', 'playsinline', 'poster', 'preload', 'src'];\n    }\n    static #define() {\n      if (this.#isDefined) return;\n      this.#isDefined = true;\n      const propsToAttrs = new Set(this.observedAttributes);\n      // defaultMuted maps to the muted attribute, handled manually below.\n      propsToAttrs.delete('muted');\n\n      // Passthrough native el functions from the custom el to the native el\n      for (let prop of nativeElProps) {\n        if (prop in this.prototype) continue;\n        const type = typeof nativeElTest[prop];\n        if (type == 'function') {\n          // Function\n          this.prototype[prop] = function () {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n            this.#init();\n            const fn = () => {\n              if (this.call) return this.call(prop, ...args);\n              return this.nativeEl[prop].apply(this.nativeEl, args);\n            };\n            if (this.loadComplete && !this.isLoaded) {\n              return this.loadComplete.then(fn);\n            }\n            return fn();\n          };\n        } else {\n          // Some properties like src, preload, defaultMuted are handled manually.\n\n          // Getter\n          let config = {\n            get() {\n              var _this$get, _this$nativeEl;\n              this.#init();\n              let attr = prop.toLowerCase();\n              if (propsToAttrs.has(attr)) {\n                const val = this.getAttribute(attr);\n                return val === null ? false : val === '' ? true : val;\n              }\n              return ((_this$get = this.get) === null || _this$get === void 0 ? void 0 : _this$get.call(this, prop)) ?? ((_this$nativeEl = this.nativeEl) === null || _this$nativeEl === void 0 ? void 0 : _this$nativeEl[prop]) ?? this.#standinEl[prop];\n            }\n          };\n          if (prop !== prop.toUpperCase()) {\n            // Setter (not a CONSTANT)\n            config.set = async function (val) {\n              this.#init();\n              let attr = prop.toLowerCase();\n              if (propsToAttrs.has(attr)) {\n                if (val === true || val === false || val == null) {\n                  this.toggleAttribute(attr, Boolean(val));\n                } else {\n                  this.setAttribute(attr, val);\n                }\n                return;\n              }\n              if (this.loadComplete && !this.isLoaded) await this.loadComplete;\n              if (this.set) {\n                this.set(prop, val);\n                return;\n              }\n              this.nativeEl[prop] = val;\n            };\n          }\n          Object.defineProperty(this.prototype, prop, config);\n        }\n      }\n    }\n    #isInit;\n    #loadComplete;\n    #hasLoaded = false;\n    #isLoaded = false;\n    #nativeEl;\n    #standinEl;\n    constructor() {\n      super();\n      if (!this.shadowRoot) {\n        this.attachShadow({\n          mode: 'open'\n        });\n        this.shadowRoot.append(this.constructor.template.content.cloneNode(true));\n      }\n\n      // If a load method is provided in the child class create a load promise.\n      if (this.load !== SuperMedia.prototype.load) {\n        this.loadComplete = new PublicPromise();\n      }\n\n      // If the custom element is defined before the custom element's HTML is parsed\n      // no attributes will be available in the constructor (construction process).\n      // Wait until initializing in the attributeChangedCallback or\n      // connectedCallback or accessing any properties.\n    }\n    get loadComplete() {\n      return this.#loadComplete;\n    }\n    set loadComplete(promise) {\n      this.#isLoaded = false;\n      this.#loadComplete = promise;\n      promise === null || promise === void 0 ? void 0 : promise.then(() => {\n        this.#isLoaded = true;\n      });\n    }\n    get isLoaded() {\n      return this.#isLoaded;\n    }\n    get nativeEl() {\n      return this.#nativeEl ?? this.shadowRoot.querySelector(tag) ?? this.querySelector(tag);\n    }\n    set nativeEl(val) {\n      this.#nativeEl = val;\n    }\n    get defaultMuted() {\n      return this.hasAttribute('muted');\n    }\n    set defaultMuted(val) {\n      this.toggleAttribute('muted', Boolean(val));\n    }\n    get src() {\n      return this.getAttribute('src');\n    }\n    set src(val) {\n      this.setAttribute('src', `${val}`);\n    }\n    get preload() {\n      var _this$nativeEl2;\n      return this.getAttribute('preload') ?? ((_this$nativeEl2 = this.nativeEl) === null || _this$nativeEl2 === void 0 ? void 0 : _this$nativeEl2.preload);\n    }\n    set preload(val) {\n      this.setAttribute('preload', `${val}`);\n    }\n    async #init() {\n      if (this.#isInit) return;\n      this.#isInit = true;\n      this.#initStandinEl();\n      this.#initNativeEl();\n      for (let prop of nativeElProps) this.#upgradeProperty(prop);\n\n      // Keep some native child elements like track and source in sync.\n      const childMap = new Map();\n      // An unnamed <slot> will be filled with all of the custom element's\n      // top-level child nodes that do not have the slot attribute.\n      const slotEl = this.shadowRoot.querySelector('slot:not([name])');\n      slotEl === null || slotEl === void 0 ? void 0 : slotEl.addEventListener('slotchange', () => {\n        const removeNativeChildren = new Map(childMap);\n        slotEl.assignedElements().filter(el => ['track', 'source'].includes(el.localName)).forEach(async el => {\n          var _this$nativeEl$append, _this$nativeEl3;\n          // If the source or track is still in the assigned elements keep it.\n          removeNativeChildren.delete(el);\n          // Re-use clones if possible.\n          let clone = childMap.get(el);\n          if (!clone) {\n            clone = el.cloneNode();\n            childMap.set(el, clone);\n          }\n          if (this.loadComplete && !this.isLoaded) await this.loadComplete;\n          (_this$nativeEl$append = (_this$nativeEl3 = this.nativeEl).append) === null || _this$nativeEl$append === void 0 ? void 0 : _this$nativeEl$append.call(_this$nativeEl3, clone);\n        });\n        removeNativeChildren.forEach(el => el.remove());\n      });\n\n      // The video events are dispatched on the SuperMediaElement instance.\n      // This makes it possible to add event listeners before the element is upgraded.\n      for (let type of this.constructor.Events) {\n        var _this$shadowRoot$addE, _this$shadowRoot;\n        (_this$shadowRoot$addE = (_this$shadowRoot = this.shadowRoot).addEventListener) === null || _this$shadowRoot$addE === void 0 ? void 0 : _this$shadowRoot$addE.call(_this$shadowRoot, type, evt => {\n          if (evt.target !== this.nativeEl) return;\n          this.dispatchEvent(new CustomEvent(evt.type, {\n            detail: evt.detail\n          }));\n        }, true);\n      }\n    }\n    #upgradeProperty(prop) {\n      // Sets properties that are set before the custom element is upgraded.\n      // https://web.dev/custom-elements-best-practices/#make-properties-lazy\n      if (Object.prototype.hasOwnProperty.call(this, prop)) {\n        const value = this[prop];\n        // Delete the set property from this instance.\n        delete this[prop];\n        // Set the value again via the (prototype) setter on this class.\n        this[prop] = value;\n      }\n    }\n    #initStandinEl() {\n      // Neither Chrome or Firefox support setting the muted attribute\n      // after using document.createElement.\n      // Get around this by setting the muted property manually.\n      const dummyEl = document.createElement(tag, {\n        is\n      });\n      dummyEl.muted = this.hasAttribute('muted');\n      for (let {\n        name,\n        value\n      } of this.attributes) {\n        dummyEl.setAttribute(name, value);\n      }\n      this.#standinEl = {};\n      for (let name of getNativeElProps(dummyEl)) {\n        this.#standinEl[name] = dummyEl[name];\n      }\n\n      // unload dummy video element\n      dummyEl.removeAttribute('src');\n      dummyEl.load();\n    }\n    async #initNativeEl() {\n      if (this.loadComplete && !this.isLoaded) await this.loadComplete;\n\n      // If there is no nativeEl by now, create it our bloody selves.\n      if (!this.nativeEl) {\n        const nativeEl = document.createElement(tag, {\n          is\n        });\n        nativeEl.part = tag;\n        this.shadowRoot.append(nativeEl);\n      }\n\n      // Neither Chrome or Firefox support setting the muted attribute\n      // after using document.createElement.\n      // Get around this by setting the muted property manually.\n      this.nativeEl.muted = this.hasAttribute('muted');\n    }\n    attributeChangedCallback(attrName, oldValue, newValue) {\n      // Initialize right after construction when the attributes become available.\n      this.#init();\n\n      // Only call loadSrc when the super class has a load method.\n      if (attrName === 'src' && this.load !== SuperMedia.prototype.load) {\n        this.#loadSrc();\n      }\n      this.#forwardAttribute(attrName, oldValue, newValue);\n    }\n    async #loadSrc() {\n      var _this$loadComplete;\n      // The first time we use the Promise created in the constructor.\n      if (this.#hasLoaded) this.loadComplete = new PublicPromise();\n      this.#hasLoaded = true;\n\n      // Wait 1 tick to allow other attributes to be set.\n      await Promise.resolve();\n      await this.load();\n      (_this$loadComplete = this.loadComplete) === null || _this$loadComplete === void 0 ? void 0 : _this$loadComplete.resolve();\n      await this.loadComplete;\n    }\n    async #forwardAttribute(attrName, oldValue, newValue) {\n      if (this.loadComplete && !this.isLoaded) await this.loadComplete;\n\n      // Ignore a few that don't need to be passed & skipped attributes.\n      // e.g. src: native element is using MSE and has a blob url as src attribute.\n      if (['id', 'class', ...this.constructor.skipAttributes].includes(attrName)) {\n        return;\n      }\n      if (newValue === null) {\n        var _this$nativeEl$remove, _this$nativeEl4;\n        (_this$nativeEl$remove = (_this$nativeEl4 = this.nativeEl).removeAttribute) === null || _this$nativeEl$remove === void 0 ? void 0 : _this$nativeEl$remove.call(_this$nativeEl4, attrName);\n      } else {\n        var _this$nativeEl$setAtt, _this$nativeEl5;\n        (_this$nativeEl$setAtt = (_this$nativeEl5 = this.nativeEl).setAttribute) === null || _this$nativeEl$setAtt === void 0 ? void 0 : _this$nativeEl$setAtt.call(_this$nativeEl5, attrName, newValue);\n      }\n    }\n    connectedCallback() {\n      this.#init();\n    }\n  };\n};\nfunction getNativeElProps(nativeElTest) {\n  // Map all native element properties to the custom element\n  // so that they're applied to the native element.\n  // Skipping HTMLElement because of things like \"attachShadow\"\n  // causing issues. Most of those props still need to apply to\n  // the custom element.\n  let nativeElProps = [];\n\n  // Walk the prototype chain up to HTMLElement.\n  // This will grab all super class props in between.\n  // i.e. VideoElement and MediaElement\n  for (let proto = Object.getPrototypeOf(nativeElTest); proto && proto !== HTMLElement.prototype; proto = Object.getPrototypeOf(proto)) {\n    nativeElProps.push(...Object.getOwnPropertyNames(proto));\n  }\n  return nativeElProps;\n}\n\n/**\n * A utility to create Promises with convenient public resolve and reject methods.\n * @return {Promise}\n */\nclass PublicPromise extends Promise {\n  constructor() {\n    let executor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};\n    let res, rej;\n    super((resolve, reject) => {\n      executor(resolve, reject);\n      res = resolve;\n      rej = reject;\n    });\n    this.resolve = res;\n    this.reject = rej;\n  }\n}\nexport const SuperVideoElement = globalThis.document ? SuperMediaMixin(HTMLElement, {\n  tag: 'video'\n}) : class {};\nexport const SuperAudioElement = globalThis.document ? SuperMediaMixin(HTMLElement, {\n  tag: 'audio'\n}) : class {};","map":null,"metadata":{},"sourceType":"module"}