{"ast":null,"code":"import { document, globalThis } from \"../utils/server-safe-globals.js\";\nimport { AvailabilityStates, StreamTypes, TextTrackKinds } from \"../constants.js\";\nimport { containsComposedNode } from \"../utils/element-utils.js\";\nimport { enterFullscreen, exitFullscreen, isFullscreen } from \"../utils/fullscreen-api.js\";\nimport { airplaySupported, castSupported, fullscreenSupported, hasFullscreenSupport, hasPipSupport, hasVolumeSupportAsync, pipSupported } from \"../utils/platform-tests.js\";\nimport { getShowingSubtitleTracks, getSubtitleTracks, toggleSubtitleTracks } from \"./util.js\";\nimport { getTextTracksList } from \"../utils/captions.js\";\nimport { isValidNumber } from \"../utils/utils.js\";\nconst StreamTypeValues = Object.values(StreamTypes);\nlet volumeSupported;\nconst volumeSupportPromise = hasVolumeSupportAsync().then(supported => {\n  volumeSupported = supported;\n  return volumeSupported;\n});\nconst prepareStateOwners = async function () {\n  for (var _len = arguments.length, stateOwners = new Array(_len), _key = 0; _key < _len; _key++) {\n    stateOwners[_key] = arguments[_key];\n  }\n  await Promise.all(stateOwners.filter(x => x).map(async stateOwner => {\n    if (!(\"localName\" in stateOwner && stateOwner instanceof globalThis.HTMLElement)) {\n      return;\n    }\n    const name = stateOwner.localName;\n    if (!name.includes(\"-\")) return;\n    const classDef = globalThis.customElements.get(name);\n    if (classDef && stateOwner instanceof classDef) return;\n    await globalThis.customElements.whenDefined(name);\n    globalThis.customElements.upgrade(stateOwner);\n  }));\n};\nconst domParser = new globalThis.DOMParser();\nconst parseHtmlToText = text => text ? domParser.parseFromString(text, \"text/html\").body.textContent || text : text;\nconst stateMediator = {\n  mediaError: {\n    get(stateOwners, event) {\n      const {\n        media\n      } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\") return;\n      return media == null ? void 0 : media.error;\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaErrorCode: {\n    get(stateOwners, event) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\") return;\n      return (_a = media == null ? void 0 : media.error) == null ? void 0 : _a.code;\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaErrorMessage: {\n    get(stateOwners, event) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\") return;\n      return (_b = (_a = media == null ? void 0 : media.error) == null ? void 0 : _a.message) != null ? _b : \"\";\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaWidth: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.videoWidth) != null ? _a : 0;\n    },\n    mediaEvents: [\"resize\"]\n  },\n  mediaHeight: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.videoHeight) != null ? _a : 0;\n    },\n    mediaEvents: [\"resize\"]\n  },\n  mediaPaused: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.paused) != null ? _a : true;\n    },\n    set(value, stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (value) {\n        media.pause();\n      } else {\n        (_a = media.play()) == null ? void 0 : _a.catch(() => {});\n      }\n    },\n    mediaEvents: [\"play\", \"playing\", \"pause\", \"emptied\"]\n  },\n  mediaHasPlayed: {\n    // We want to let the user know that the media started playing at any point (`media-has-played`).\n    // Since these propagators are all called when boostrapping state, let's verify this is\n    // a real playing event by checking that 1) there's media and 2) it isn't currently paused.\n    get(stateOwners, event) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return false;\n      if (!event) return !media.paused;\n      return event.type === \"playing\";\n    },\n    mediaEvents: [\"playing\", \"emptied\"]\n  },\n  mediaEnded: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.ended) != null ? _a : false;\n    },\n    mediaEvents: [\"seeked\", \"ended\", \"emptied\"]\n  },\n  mediaPlaybackRate: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.playbackRate) != null ? _a : 1;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (!Number.isFinite(+value)) return;\n      media.playbackRate = +value;\n    },\n    mediaEvents: [\"ratechange\", \"loadstart\"]\n  },\n  mediaMuted: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.muted) != null ? _a : false;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      try {\n        globalThis.localStorage.setItem(\"media-chrome-pref-muted\", value ? \"true\" : \"false\");\n      } catch (e) {\n        console.debug(\"Error setting muted pref\", e);\n      }\n      media.muted = value;\n    },\n    mediaEvents: [\"volumechange\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      const {\n        options: {\n          noMutedPref\n        }\n      } = stateOwners;\n      const {\n        media\n      } = stateOwners;\n      if (!media || media.muted || noMutedPref) return;\n      try {\n        const mutedPref = globalThis.localStorage.getItem(\"media-chrome-pref-muted\") === \"true\";\n        stateMediator.mediaMuted.set(mutedPref, stateOwners);\n        handler(mutedPref);\n      } catch (e) {\n        console.debug(\"Error getting muted pref\", e);\n      }\n    }]\n  },\n  mediaVolume: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.volume) != null ? _a : 1;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      try {\n        if (value == null) {\n          globalThis.localStorage.removeItem(\"media-chrome-pref-volume\");\n        } else {\n          globalThis.localStorage.setItem(\"media-chrome-pref-volume\", value.toString());\n        }\n      } catch (e) {\n        console.debug(\"Error setting volume pref\", e);\n      }\n      if (!Number.isFinite(+value)) return;\n      media.volume = +value;\n    },\n    mediaEvents: [\"volumechange\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      const {\n        options: {\n          noVolumePref\n        }\n      } = stateOwners;\n      if (noVolumePref) return;\n      try {\n        const {\n          media\n        } = stateOwners;\n        if (!media) return;\n        const volumePref = globalThis.localStorage.getItem(\"media-chrome-pref-volume\");\n        if (volumePref == null) return;\n        stateMediator.mediaVolume.set(+volumePref, stateOwners);\n        handler(+volumePref);\n      } catch (e) {\n        console.debug(\"Error getting volume pref\", e);\n      }\n    }]\n  },\n  // NOTE: Keeping this roughly equivalent to prior impl to reduce number of changes,\n  // however we may want to model \"derived\" state differently from \"primary\" state\n  // (in this case, derived === mediaVolumeLevel, primary === mediaMuted, mediaVolume) (CJP)\n  mediaVolumeLevel: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (typeof (media == null ? void 0 : media.volume) == \"undefined\") return \"high\";\n      if (media.muted || media.volume === 0) return \"off\";\n      if (media.volume < 0.5) return \"low\";\n      if (media.volume < 0.75) return \"medium\";\n      return \"high\";\n    },\n    mediaEvents: [\"volumechange\"]\n  },\n  mediaCurrentTime: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.currentTime) != null ? _a : 0;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media || !isValidNumber(value)) return;\n      media.currentTime = value;\n    },\n    mediaEvents: [\"timeupdate\", \"loadedmetadata\"]\n  },\n  mediaDuration: {\n    get(stateOwners) {\n      const {\n        media,\n        options: {\n          defaultDuration\n        } = {}\n      } = stateOwners;\n      if (defaultDuration && (!media || !media.duration || Number.isNaN(media.duration) || !Number.isFinite(media.duration))) {\n        return defaultDuration;\n      }\n      return Number.isFinite(media == null ? void 0 : media.duration) ? media.duration : Number.NaN;\n    },\n    mediaEvents: [\"durationchange\", \"loadedmetadata\", \"emptied\"]\n  },\n  mediaLoading: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      return (media == null ? void 0 : media.readyState) < 3;\n    },\n    mediaEvents: [\"waiting\", \"playing\", \"emptied\"]\n  },\n  mediaSeekable: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!((_a = media == null ? void 0 : media.seekable) == null ? void 0 : _a.length)) return void 0;\n      const start = media.seekable.start(0);\n      const end = media.seekable.end(media.seekable.length - 1);\n      if (!start && !end) return void 0;\n      return [Number(start.toFixed(3)), Number(end.toFixed(3))];\n    },\n    mediaEvents: [\"loadedmetadata\", \"emptied\", \"progress\", \"seekablechange\"]\n  },\n  mediaBuffered: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      const timeRanges = (_a = media == null ? void 0 : media.buffered) != null ? _a : [];\n      return Array.from(timeRanges).map((_, i) => [Number(timeRanges.start(i).toFixed(3)), Number(timeRanges.end(i).toFixed(3))]);\n    },\n    mediaEvents: [\"progress\", \"emptied\"]\n  },\n  mediaStreamType: {\n    get(stateOwners) {\n      const {\n        media,\n        options: {\n          defaultStreamType\n        } = {}\n      } = stateOwners;\n      const usedDefaultStreamType = [StreamTypes.LIVE, StreamTypes.ON_DEMAND].includes(defaultStreamType) ? defaultStreamType : void 0;\n      if (!media) return usedDefaultStreamType;\n      const {\n        streamType\n      } = media;\n      if (StreamTypeValues.includes(streamType)) {\n        if (streamType === StreamTypes.UNKNOWN) {\n          return usedDefaultStreamType;\n        }\n        return streamType;\n      }\n      const duration = media.duration;\n      if (duration === Infinity) {\n        return StreamTypes.LIVE;\n      } else if (Number.isFinite(duration)) {\n        return StreamTypes.ON_DEMAND;\n      }\n      return usedDefaultStreamType;\n    },\n    mediaEvents: [\"emptied\", \"durationchange\", \"loadedmetadata\", \"streamtypechange\"]\n  },\n  mediaTargetLiveWindow: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return Number.NaN;\n      const {\n        targetLiveWindow\n      } = media;\n      const streamType = stateMediator.mediaStreamType.get(stateOwners);\n      if ((targetLiveWindow == null || Number.isNaN(targetLiveWindow)) && streamType === StreamTypes.LIVE) {\n        return 0;\n      }\n      return targetLiveWindow;\n    },\n    mediaEvents: [\"emptied\", \"durationchange\", \"loadedmetadata\", \"streamtypechange\", \"targetlivewindowchange\"]\n  },\n  mediaTimeIsLive: {\n    get(stateOwners) {\n      const {\n        media,\n        // Default to 10 seconds\n        options: {\n          liveEdgeOffset = 10\n        } = {}\n      } = stateOwners;\n      if (!media) return false;\n      if (typeof media.liveEdgeStart === \"number\") {\n        if (Number.isNaN(media.liveEdgeStart)) return false;\n        return media.currentTime >= media.liveEdgeStart;\n      }\n      const live = stateMediator.mediaStreamType.get(stateOwners) === StreamTypes.LIVE;\n      if (!live) return false;\n      const seekable = media.seekable;\n      if (!seekable) return true;\n      if (!seekable.length) return false;\n      const liveEdgeStart = seekable.end(seekable.length - 1) - liveEdgeOffset;\n      return media.currentTime >= liveEdgeStart;\n    },\n    mediaEvents: [\"playing\", \"timeupdate\", \"progress\", \"waiting\", \"emptied\"]\n  },\n  // Text Tracks modeling\n  mediaSubtitlesList: {\n    get(stateOwners) {\n      return getSubtitleTracks(stateOwners).map(_ref => {\n        let {\n          kind,\n          label,\n          language\n        } = _ref;\n        return {\n          kind,\n          label,\n          language\n        };\n      });\n    },\n    mediaEvents: [\"loadstart\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaSubtitlesShowing: {\n    get(stateOwners) {\n      return getShowingSubtitleTracks(stateOwners).map(_ref2 => {\n        let {\n          kind,\n          label,\n          language\n        } = _ref2;\n        return {\n          kind,\n          label,\n          language\n        };\n      });\n    },\n    mediaEvents: [\"loadstart\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\", \"change\"],\n    stateOwnersUpdateHandlers: [(_handler, stateOwners) => {\n      var _a, _b;\n      const {\n        media,\n        options\n      } = stateOwners;\n      if (!media) return;\n      const updateDefaultSubtitlesCallback = event => {\n        var _a2;\n        if (!options.defaultSubtitles) return;\n        const nonSubsEvent = event && ![TextTrackKinds.CAPTIONS, TextTrackKinds.SUBTITLES].includes(\n        // @ts-ignore\n        (_a2 = event == null ? void 0 : event.track) == null ? void 0 : _a2.kind);\n        if (nonSubsEvent) return;\n        toggleSubtitleTracks(stateOwners, true);\n      };\n      media.addEventListener(\"loadstart\", updateDefaultSubtitlesCallback);\n      (_a = media.textTracks) == null ? void 0 : _a.addEventListener(\"addtrack\", updateDefaultSubtitlesCallback);\n      (_b = media.textTracks) == null ? void 0 : _b.addEventListener(\"removetrack\", updateDefaultSubtitlesCallback);\n      return () => {\n        var _a2, _b2;\n        media.removeEventListener(\"loadstart\", updateDefaultSubtitlesCallback);\n        (_a2 = media.textTracks) == null ? void 0 : _a2.removeEventListener(\"addtrack\", updateDefaultSubtitlesCallback);\n        (_b2 = media.textTracks) == null ? void 0 : _b2.removeEventListener(\"removetrack\", updateDefaultSubtitlesCallback);\n      };\n    }]\n  },\n  mediaChaptersCues: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return [];\n      const [chaptersTrack] = getTextTracksList(media, {\n        kind: TextTrackKinds.CHAPTERS\n      });\n      return Array.from((_a = chaptersTrack == null ? void 0 : chaptersTrack.cues) != null ? _a : []).map(_ref3 => {\n        let {\n          text,\n          startTime,\n          endTime\n        } = _ref3;\n        return {\n          text: parseHtmlToText(text),\n          startTime,\n          endTime\n        };\n      });\n    },\n    mediaEvents: [\"loadstart\", \"loadedmetadata\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\", \"change\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      const chaptersTrack = media.querySelector('track[kind=\"chapters\"][default][src]');\n      const shadowChaptersTrack = (_a = media.shadowRoot) == null ? void 0 : _a.querySelector(':is(video,audio) > track[kind=\"chapters\"][default][src]');\n      chaptersTrack == null ? void 0 : chaptersTrack.addEventListener(\"load\", handler);\n      shadowChaptersTrack == null ? void 0 : shadowChaptersTrack.addEventListener(\"load\", handler);\n      return () => {\n        chaptersTrack == null ? void 0 : chaptersTrack.removeEventListener(\"load\", handler);\n        shadowChaptersTrack == null ? void 0 : shadowChaptersTrack.removeEventListener(\"load\", handler);\n      };\n    }]\n  },\n  // Modeling state tied to root node\n  mediaIsPip: {\n    get(stateOwners) {\n      var _a, _b;\n      const {\n        media,\n        documentElement\n      } = stateOwners;\n      if (!media || !documentElement) return false;\n      if (!documentElement.pictureInPictureElement) return false;\n      if (documentElement.pictureInPictureElement === media) return true;\n      if (documentElement.pictureInPictureElement instanceof HTMLMediaElement) {\n        if (!((_a = media.localName) == null ? void 0 : _a.includes(\"-\"))) return false;\n        return containsComposedNode(media, documentElement.pictureInPictureElement);\n      }\n      if (documentElement.pictureInPictureElement.localName.includes(\"-\")) {\n        let currentRoot = documentElement.pictureInPictureElement.shadowRoot;\n        while (currentRoot == null ? void 0 : currentRoot.pictureInPictureElement) {\n          if (currentRoot.pictureInPictureElement === media) return true;\n          currentRoot = (_b = currentRoot.pictureInPictureElement) == null ? void 0 : _b.shadowRoot;\n        }\n      }\n      return false;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (value) {\n        if (!document.pictureInPictureEnabled) {\n          console.warn(\"MediaChrome: Picture-in-picture is not enabled\");\n          return;\n        }\n        if (!media.requestPictureInPicture) {\n          console.warn(\"MediaChrome: The current media does not support picture-in-picture\");\n          return;\n        }\n        const warnNotReady = () => {\n          console.warn(\"MediaChrome: The media is not ready for picture-in-picture. It must have a readyState > 0.\");\n        };\n        media.requestPictureInPicture().catch(err => {\n          if (err.code === 11) {\n            if (!media.src) {\n              console.warn(\"MediaChrome: The media is not ready for picture-in-picture. It must have a src set.\");\n              return;\n            }\n            if (media.readyState === 0 && media.preload === \"none\") {\n              const cleanup = () => {\n                media.removeEventListener(\"loadedmetadata\", tryPip);\n                media.preload = \"none\";\n              };\n              const tryPip = () => {\n                media.requestPictureInPicture().catch(warnNotReady);\n                cleanup();\n              };\n              media.addEventListener(\"loadedmetadata\", tryPip);\n              media.preload = \"metadata\";\n              setTimeout(() => {\n                if (media.readyState === 0) warnNotReady();\n                cleanup();\n              }, 1e3);\n            } else {\n              throw err;\n            }\n          } else {\n            throw err;\n          }\n        });\n      } else if (document.pictureInPictureElement) {\n        document.exitPictureInPicture();\n      }\n    },\n    mediaEvents: [\"enterpictureinpicture\", \"leavepictureinpicture\"]\n  },\n  mediaRenditionList: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return [...((_a = media == null ? void 0 : media.videoRenditions) != null ? _a : [])].map(videoRendition => ({\n        ...videoRendition\n      }));\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\"]\n  },\n  /** @TODO Model this as a derived value? (CJP) */\n  mediaRenditionSelected: {\n    get(stateOwners) {\n      var _a, _b, _c;\n      const {\n        media\n      } = stateOwners;\n      return (_c = (_b = media == null ? void 0 : media.videoRenditions) == null ? void 0 : _b[(_a = media.videoRenditions) == null ? void 0 : _a.selectedIndex]) == null ? void 0 : _c.id;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.videoRenditions)) {\n        console.warn(\"MediaController: Rendition selection not supported by this media.\");\n        return;\n      }\n      const renditionId = value;\n      const index = Array.prototype.findIndex.call(media.videoRenditions, r => r.id == renditionId);\n      if (media.videoRenditions.selectedIndex != index) {\n        media.videoRenditions.selectedIndex = index;\n      }\n    },\n    mediaEvents: [\"emptied\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\", \"change\"]\n  },\n  mediaAudioTrackList: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return [...((_a = media == null ? void 0 : media.audioTracks) != null ? _a : [])];\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaAudioTrackEnabled: {\n    get(stateOwners) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      return (_b = [...((_a = media == null ? void 0 : media.audioTracks) != null ? _a : [])].find(audioTrack => audioTrack.enabled)) == null ? void 0 : _b.id;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.audioTracks)) {\n        console.warn(\"MediaChrome: Audio track selection not supported by this media.\");\n        return;\n      }\n      const audioTrackId = value;\n      for (const track of media.audioTracks) {\n        track.enabled = audioTrackId == track.id;\n      }\n    },\n    mediaEvents: [\"emptied\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\", \"change\"]\n  },\n  mediaIsFullscreen: {\n    get(stateOwners) {\n      return isFullscreen(stateOwners);\n    },\n    set(value, stateOwners) {\n      if (!value) {\n        exitFullscreen(stateOwners);\n      } else {\n        enterFullscreen(stateOwners);\n      }\n    },\n    // older Safari version may require webkit-specific events\n    rootEvents: [\"fullscreenchange\", \"webkitfullscreenchange\"],\n    // iOS requires webkit-specific events on the video.\n    mediaEvents: [\"webkitbeginfullscreen\", \"webkitendfullscreen\", \"webkitpresentationmodechanged\"]\n  },\n  mediaIsCasting: {\n    // Note this relies on a customized castable-video element.\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.remote) || ((_a = media.remote) == null ? void 0 : _a.state) === \"disconnected\") return false;\n      return !!media.remote.state;\n    },\n    set(value, stateOwners) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (value && ((_a = media.remote) == null ? void 0 : _a.state) !== \"disconnected\") return;\n      if (!value && ((_b = media.remote) == null ? void 0 : _b.state) !== \"connected\") return;\n      if (typeof media.remote.prompt !== \"function\") {\n        console.warn(\"MediaChrome: Casting is not supported in this environment\");\n        return;\n      }\n      media.remote.prompt().catch(() => {});\n    },\n    remoteEvents: [\"connect\", \"connecting\", \"disconnect\"]\n  },\n  // NOTE: Newly added state for tracking airplaying\n  mediaIsAirplaying: {\n    // NOTE: Cannot know if airplaying since Safari doesn't fully support HTMLMediaElement::remote yet (e.g. remote::state) (CJP)\n    get() {\n      return false;\n    },\n    set(_value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (!(media.webkitShowPlaybackTargetPicker && globalThis.WebKitPlaybackTargetAvailabilityEvent)) {\n        console.error(\"MediaChrome: received a request to select AirPlay but AirPlay is not supported in this environment\");\n        return;\n      }\n      media.webkitShowPlaybackTargetPicker();\n    },\n    mediaEvents: [\"webkitcurrentplaybacktargetiswirelesschanged\"]\n  },\n  mediaFullscreenUnavailable: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!fullscreenSupported || !hasFullscreenSupport(media)) return AvailabilityStates.UNSUPPORTED;\n      return void 0;\n    }\n  },\n  mediaPipUnavailable: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!pipSupported || !hasPipSupport(media)) return AvailabilityStates.UNSUPPORTED;\n    }\n  },\n  mediaVolumeUnavailable: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (volumeSupported === false || (media == null ? void 0 : media.volume) == void 0) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      return void 0;\n    },\n    // NOTE: Slightly different impl here. Added generic support for\n    // \"stateOwnersUpdateHandlers\" since the original impl had to hack around\n    // race conditions. (CJP)\n    stateOwnersUpdateHandlers: [handler => {\n      if (volumeSupported == null) {\n        volumeSupportPromise.then(supported => handler(supported ? void 0 : AvailabilityStates.UNSUPPORTED));\n      }\n    }]\n  },\n  mediaCastUnavailable: {\n    // @ts-ignore\n    get(stateOwners) {\n      let {\n        availability = \"not-available\"\n      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!castSupported || !((_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.state)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (availability == null || availability === \"available\") return void 0;\n      return AvailabilityStates.UNAVAILABLE;\n    },\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      const remotePlaybackDisabled = media.disableRemotePlayback || media.hasAttribute(\"disableremoteplayback\");\n      if (!remotePlaybackDisabled) {\n        (_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.watchAvailability(availabilityBool => {\n          const availability = availabilityBool ? \"available\" : \"not-available\";\n          handler({\n            availability\n          });\n        }).catch(error => {\n          if (error.name === \"NotSupportedError\") {\n            handler({\n              availability: null\n            });\n          } else {\n            handler({\n              availability: \"not-available\"\n            });\n          }\n        });\n      }\n      return () => {\n        var _a2;\n        (_a2 = media == null ? void 0 : media.remote) == null ? void 0 : _a2.cancelWatchAvailability().catch(() => {});\n      };\n    }]\n  },\n  mediaAirplayUnavailable: {\n    get(_stateOwners, event) {\n      if (!airplaySupported) return AvailabilityStates.UNSUPPORTED;\n      if ((event == null ? void 0 : event.availability) === \"not-available\") {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    // NOTE: Keeping this event, as it's still the documented way of monitoring\n    // for AirPlay availability from Apple.\n    // See: https://developer.apple.com/documentation/webkitjs/adding_an_airplay_button_to_your_safari_media_controls#2940021 (CJP)\n    mediaEvents: [\"webkitplaybacktargetavailabilitychanged\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      const remotePlaybackDisabled = media.disableRemotePlayback || media.hasAttribute(\"disableremoteplayback\");\n      if (!remotePlaybackDisabled) {\n        (_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.watchAvailability(availabilityBool => {\n          const availability = availabilityBool ? \"available\" : \"not-available\";\n          handler({\n            availability\n          });\n        }).catch(error => {\n          if (error.name === \"NotSupportedError\") {\n            handler({\n              availability: null\n            });\n          } else {\n            handler({\n              availability: \"not-available\"\n            });\n          }\n        });\n      }\n      return () => {\n        var _a2;\n        (_a2 = media == null ? void 0 : media.remote) == null ? void 0 : _a2.cancelWatchAvailability().catch(() => {});\n      };\n    }]\n  },\n  mediaRenditionUnavailable: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.videoRenditions)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (!((_a = media.videoRenditions) == null ? void 0 : _a.length)) {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\"]\n  },\n  mediaAudioTrackUnavailable: {\n    get(stateOwners) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.audioTracks)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (((_b = (_a = media.audioTracks) == null ? void 0 : _a.length) != null ? _b : 0) <= 1) {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\"]\n  }\n};\nexport { prepareStateOwners, stateMediator, volumeSupportPromise };","map":{"version":3,"names":["document","globalThis","AvailabilityStates","StreamTypes","TextTrackKinds","containsComposedNode","enterFullscreen","exitFullscreen","isFullscreen","airplaySupported","castSupported","fullscreenSupported","hasFullscreenSupport","hasPipSupport","hasVolumeSupportAsync","pipSupported","getShowingSubtitleTracks","getSubtitleTracks","toggleSubtitleTracks","getTextTracksList","isValidNumber","StreamTypeValues","Object","values","volumeSupported","volumeSupportPromise","then","supported","prepareStateOwners","_len","arguments","length","stateOwners","Array","_key","Promise","all","filter","x","map","stateOwner","HTMLElement","name","localName","includes","classDef","customElements","get","whenDefined","upgrade","domParser","DOMParser","parseHtmlToText","text","parseFromString","body","textContent","stateMediator","mediaError","event","media","type","error","mediaEvents","mediaErrorCode","_a","code","mediaErrorMessage","_b","message","mediaWidth","videoWidth","mediaHeight","videoHeight","mediaPaused","paused","set","value","pause","play","catch","mediaHasPlayed","mediaEnded","ended","mediaPlaybackRate","playbackRate","Number","isFinite","mediaMuted","muted","localStorage","setItem","e","console","debug","stateOwnersUpdateHandlers","handler","options","noMutedPref","mutedPref","getItem","mediaVolume","volume","removeItem","toString","noVolumePref","volumePref","mediaVolumeLevel","mediaCurrentTime","currentTime","mediaDuration","defaultDuration","duration","isNaN","NaN","mediaLoading","readyState","mediaSeekable","seekable","start","end","toFixed","mediaBuffered","timeRanges","buffered","from","_","i","mediaStreamType","defaultStreamType","usedDefaultStreamType","LIVE","ON_DEMAND","streamType","UNKNOWN","Infinity","mediaTargetLiveWindow","targetLiveWindow","mediaTimeIsLive","liveEdgeOffset","liveEdgeStart","live","mediaSubtitlesList","_ref","kind","label","language","textTracksEvents","mediaSubtitlesShowing","_ref2","_handler","updateDefaultSubtitlesCallback","_a2","defaultSubtitles","nonSubsEvent","CAPTIONS","SUBTITLES","track","addEventListener","textTracks","_b2","removeEventListener","mediaChaptersCues","chaptersTrack","CHAPTERS","cues","_ref3","startTime","endTime","querySelector","shadowChaptersTrack","shadowRoot","mediaIsPip","documentElement","pictureInPictureElement","HTMLMediaElement","currentRoot","pictureInPictureEnabled","warn","requestPictureInPicture","warnNotReady","err","src","preload","cleanup","tryPip","setTimeout","exitPictureInPicture","mediaRenditionList","videoRenditions","videoRendition","videoRenditionsEvents","mediaRenditionSelected","_c","selectedIndex","id","renditionId","index","prototype","findIndex","call","r","mediaAudioTrackList","audioTracks","audioTracksEvents","mediaAudioTrackEnabled","find","audioTrack","enabled","audioTrackId","mediaIsFullscreen","rootEvents","mediaIsCasting","remote","state","prompt","remoteEvents","mediaIsAirplaying","_value","webkitShowPlaybackTargetPicker","WebKitPlaybackTargetAvailabilityEvent","mediaFullscreenUnavailable","UNSUPPORTED","mediaPipUnavailable","mediaVolumeUnavailable","mediaCastUnavailable","availability","undefined","UNAVAILABLE","remotePlaybackDisabled","disableRemotePlayback","hasAttribute","watchAvailability","availabilityBool","cancelWatchAvailability","mediaAirplayUnavailable","_stateOwners","mediaRenditionUnavailable","mediaAudioTrackUnavailable"],"sources":["/Users/monawiebkeurban/Documents/portfolio/node_modules/media-chrome/dist/media-store/state-mediator.js"],"sourcesContent":["import { document, globalThis } from \"../utils/server-safe-globals.js\";\nimport {\n  AvailabilityStates,\n  StreamTypes,\n  TextTrackKinds\n} from \"../constants.js\";\nimport { containsComposedNode } from \"../utils/element-utils.js\";\nimport {\n  enterFullscreen,\n  exitFullscreen,\n  isFullscreen\n} from \"../utils/fullscreen-api.js\";\nimport {\n  airplaySupported,\n  castSupported,\n  fullscreenSupported,\n  hasFullscreenSupport,\n  hasPipSupport,\n  hasVolumeSupportAsync,\n  pipSupported\n} from \"../utils/platform-tests.js\";\nimport {\n  getShowingSubtitleTracks,\n  getSubtitleTracks,\n  toggleSubtitleTracks\n} from \"./util.js\";\nimport { getTextTracksList } from \"../utils/captions.js\";\nimport { isValidNumber } from \"../utils/utils.js\";\nconst StreamTypeValues = Object.values(StreamTypes);\nlet volumeSupported;\nconst volumeSupportPromise = hasVolumeSupportAsync().then((supported) => {\n  volumeSupported = supported;\n  return volumeSupported;\n});\nconst prepareStateOwners = async (...stateOwners) => {\n  await Promise.all(\n    stateOwners.filter((x) => x).map(async (stateOwner) => {\n      if (!(\"localName\" in stateOwner && stateOwner instanceof globalThis.HTMLElement)) {\n        return;\n      }\n      const name = stateOwner.localName;\n      if (!name.includes(\"-\"))\n        return;\n      const classDef = globalThis.customElements.get(name);\n      if (classDef && stateOwner instanceof classDef)\n        return;\n      await globalThis.customElements.whenDefined(name);\n      globalThis.customElements.upgrade(stateOwner);\n    })\n  );\n};\nconst domParser = new globalThis.DOMParser();\nconst parseHtmlToText = (text) => text ? domParser.parseFromString(text, \"text/html\").body.textContent || text : text;\nconst stateMediator = {\n  mediaError: {\n    get(stateOwners, event) {\n      const { media } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\")\n        return;\n      return media == null ? void 0 : media.error;\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaErrorCode: {\n    get(stateOwners, event) {\n      var _a;\n      const { media } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\")\n        return;\n      return (_a = media == null ? void 0 : media.error) == null ? void 0 : _a.code;\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaErrorMessage: {\n    get(stateOwners, event) {\n      var _a, _b;\n      const { media } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\")\n        return;\n      return (_b = (_a = media == null ? void 0 : media.error) == null ? void 0 : _a.message) != null ? _b : \"\";\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaWidth: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.videoWidth) != null ? _a : 0;\n    },\n    mediaEvents: [\"resize\"]\n  },\n  mediaHeight: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.videoHeight) != null ? _a : 0;\n    },\n    mediaEvents: [\"resize\"]\n  },\n  mediaPaused: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.paused) != null ? _a : true;\n    },\n    set(value, stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (value) {\n        media.pause();\n      } else {\n        (_a = media.play()) == null ? void 0 : _a.catch(() => {\n        });\n      }\n    },\n    mediaEvents: [\"play\", \"playing\", \"pause\", \"emptied\"]\n  },\n  mediaHasPlayed: {\n    // We want to let the user know that the media started playing at any point (`media-has-played`).\n    // Since these propagators are all called when boostrapping state, let's verify this is\n    // a real playing event by checking that 1) there's media and 2) it isn't currently paused.\n    get(stateOwners, event) {\n      const { media } = stateOwners;\n      if (!media)\n        return false;\n      if (!event)\n        return !media.paused;\n      return event.type === \"playing\";\n    },\n    mediaEvents: [\"playing\", \"emptied\"]\n  },\n  mediaEnded: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.ended) != null ? _a : false;\n    },\n    mediaEvents: [\"seeked\", \"ended\", \"emptied\"]\n  },\n  mediaPlaybackRate: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.playbackRate) != null ? _a : 1;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (!Number.isFinite(+value))\n        return;\n      media.playbackRate = +value;\n    },\n    mediaEvents: [\"ratechange\", \"loadstart\"]\n  },\n  mediaMuted: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.muted) != null ? _a : false;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      try {\n        globalThis.localStorage.setItem(\n          \"media-chrome-pref-muted\",\n          value ? \"true\" : \"false\"\n        );\n      } catch (e) {\n        console.debug(\"Error setting muted pref\", e);\n      }\n      media.muted = value;\n    },\n    mediaEvents: [\"volumechange\"],\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        const {\n          options: { noMutedPref }\n        } = stateOwners;\n        const { media } = stateOwners;\n        if (!media || media.muted || noMutedPref)\n          return;\n        try {\n          const mutedPref = globalThis.localStorage.getItem(\"media-chrome-pref-muted\") === \"true\";\n          stateMediator.mediaMuted.set(mutedPref, stateOwners);\n          handler(mutedPref);\n        } catch (e) {\n          console.debug(\"Error getting muted pref\", e);\n        }\n      }\n    ]\n  },\n  mediaVolume: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.volume) != null ? _a : 1;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      try {\n        if (value == null) {\n          globalThis.localStorage.removeItem(\"media-chrome-pref-volume\");\n        } else {\n          globalThis.localStorage.setItem(\n            \"media-chrome-pref-volume\",\n            value.toString()\n          );\n        }\n      } catch (e) {\n        console.debug(\"Error setting volume pref\", e);\n      }\n      if (!Number.isFinite(+value))\n        return;\n      media.volume = +value;\n    },\n    mediaEvents: [\"volumechange\"],\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        const {\n          options: { noVolumePref }\n        } = stateOwners;\n        if (noVolumePref)\n          return;\n        try {\n          const { media } = stateOwners;\n          if (!media)\n            return;\n          const volumePref = globalThis.localStorage.getItem(\n            \"media-chrome-pref-volume\"\n          );\n          if (volumePref == null)\n            return;\n          stateMediator.mediaVolume.set(+volumePref, stateOwners);\n          handler(+volumePref);\n        } catch (e) {\n          console.debug(\"Error getting volume pref\", e);\n        }\n      }\n    ]\n  },\n  // NOTE: Keeping this roughly equivalent to prior impl to reduce number of changes,\n  // however we may want to model \"derived\" state differently from \"primary\" state\n  // (in this case, derived === mediaVolumeLevel, primary === mediaMuted, mediaVolume) (CJP)\n  mediaVolumeLevel: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (typeof (media == null ? void 0 : media.volume) == \"undefined\")\n        return \"high\";\n      if (media.muted || media.volume === 0)\n        return \"off\";\n      if (media.volume < 0.5)\n        return \"low\";\n      if (media.volume < 0.75)\n        return \"medium\";\n      return \"high\";\n    },\n    mediaEvents: [\"volumechange\"]\n  },\n  mediaCurrentTime: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.currentTime) != null ? _a : 0;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media || !isValidNumber(value))\n        return;\n      media.currentTime = value;\n    },\n    mediaEvents: [\"timeupdate\", \"loadedmetadata\"]\n  },\n  mediaDuration: {\n    get(stateOwners) {\n      const { media, options: { defaultDuration } = {} } = stateOwners;\n      if (defaultDuration && (!media || !media.duration || Number.isNaN(media.duration) || !Number.isFinite(media.duration))) {\n        return defaultDuration;\n      }\n      return Number.isFinite(media == null ? void 0 : media.duration) ? media.duration : Number.NaN;\n    },\n    mediaEvents: [\"durationchange\", \"loadedmetadata\", \"emptied\"]\n  },\n  mediaLoading: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      return (media == null ? void 0 : media.readyState) < 3;\n    },\n    mediaEvents: [\"waiting\", \"playing\", \"emptied\"]\n  },\n  mediaSeekable: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!((_a = media == null ? void 0 : media.seekable) == null ? void 0 : _a.length))\n        return void 0;\n      const start = media.seekable.start(0);\n      const end = media.seekable.end(media.seekable.length - 1);\n      if (!start && !end)\n        return void 0;\n      return [Number(start.toFixed(3)), Number(end.toFixed(3))];\n    },\n    mediaEvents: [\"loadedmetadata\", \"emptied\", \"progress\", \"seekablechange\"]\n  },\n  mediaBuffered: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      const timeRanges = (_a = media == null ? void 0 : media.buffered) != null ? _a : [];\n      return Array.from(timeRanges).map((_, i) => [\n        Number(timeRanges.start(i).toFixed(3)),\n        Number(timeRanges.end(i).toFixed(3))\n      ]);\n    },\n    mediaEvents: [\"progress\", \"emptied\"]\n  },\n  mediaStreamType: {\n    get(stateOwners) {\n      const { media, options: { defaultStreamType } = {} } = stateOwners;\n      const usedDefaultStreamType = [\n        StreamTypes.LIVE,\n        StreamTypes.ON_DEMAND\n      ].includes(defaultStreamType) ? defaultStreamType : void 0;\n      if (!media)\n        return usedDefaultStreamType;\n      const { streamType } = media;\n      if (StreamTypeValues.includes(streamType)) {\n        if (streamType === StreamTypes.UNKNOWN) {\n          return usedDefaultStreamType;\n        }\n        return streamType;\n      }\n      const duration = media.duration;\n      if (duration === Infinity) {\n        return StreamTypes.LIVE;\n      } else if (Number.isFinite(duration)) {\n        return StreamTypes.ON_DEMAND;\n      }\n      return usedDefaultStreamType;\n    },\n    mediaEvents: [\n      \"emptied\",\n      \"durationchange\",\n      \"loadedmetadata\",\n      \"streamtypechange\"\n    ]\n  },\n  mediaTargetLiveWindow: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return Number.NaN;\n      const { targetLiveWindow } = media;\n      const streamType = stateMediator.mediaStreamType.get(stateOwners);\n      if ((targetLiveWindow == null || Number.isNaN(targetLiveWindow)) && streamType === StreamTypes.LIVE) {\n        return 0;\n      }\n      return targetLiveWindow;\n    },\n    mediaEvents: [\n      \"emptied\",\n      \"durationchange\",\n      \"loadedmetadata\",\n      \"streamtypechange\",\n      \"targetlivewindowchange\"\n    ]\n  },\n  mediaTimeIsLive: {\n    get(stateOwners) {\n      const {\n        media,\n        // Default to 10 seconds\n        options: { liveEdgeOffset = 10 } = {}\n      } = stateOwners;\n      if (!media)\n        return false;\n      if (typeof media.liveEdgeStart === \"number\") {\n        if (Number.isNaN(media.liveEdgeStart))\n          return false;\n        return media.currentTime >= media.liveEdgeStart;\n      }\n      const live = stateMediator.mediaStreamType.get(stateOwners) === StreamTypes.LIVE;\n      if (!live)\n        return false;\n      const seekable = media.seekable;\n      if (!seekable)\n        return true;\n      if (!seekable.length)\n        return false;\n      const liveEdgeStart = seekable.end(seekable.length - 1) - liveEdgeOffset;\n      return media.currentTime >= liveEdgeStart;\n    },\n    mediaEvents: [\"playing\", \"timeupdate\", \"progress\", \"waiting\", \"emptied\"]\n  },\n  // Text Tracks modeling\n  mediaSubtitlesList: {\n    get(stateOwners) {\n      return getSubtitleTracks(stateOwners).map(\n        ({ kind, label, language }) => ({ kind, label, language })\n      );\n    },\n    mediaEvents: [\"loadstart\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaSubtitlesShowing: {\n    get(stateOwners) {\n      return getShowingSubtitleTracks(stateOwners).map(\n        ({ kind, label, language }) => ({ kind, label, language })\n      );\n    },\n    mediaEvents: [\"loadstart\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\", \"change\"],\n    stateOwnersUpdateHandlers: [\n      (_handler, stateOwners) => {\n        var _a, _b;\n        const { media, options } = stateOwners;\n        if (!media)\n          return;\n        const updateDefaultSubtitlesCallback = (event) => {\n          var _a2;\n          if (!options.defaultSubtitles)\n            return;\n          const nonSubsEvent = event && ![TextTrackKinds.CAPTIONS, TextTrackKinds.SUBTITLES].includes(\n            // @ts-ignore\n            (_a2 = event == null ? void 0 : event.track) == null ? void 0 : _a2.kind\n          );\n          if (nonSubsEvent)\n            return;\n          toggleSubtitleTracks(stateOwners, true);\n        };\n        media.addEventListener(\n          \"loadstart\",\n          updateDefaultSubtitlesCallback\n        );\n        (_a = media.textTracks) == null ? void 0 : _a.addEventListener(\n          \"addtrack\",\n          updateDefaultSubtitlesCallback\n        );\n        (_b = media.textTracks) == null ? void 0 : _b.addEventListener(\n          \"removetrack\",\n          updateDefaultSubtitlesCallback\n        );\n        return () => {\n          var _a2, _b2;\n          media.removeEventListener(\n            \"loadstart\",\n            updateDefaultSubtitlesCallback\n          );\n          (_a2 = media.textTracks) == null ? void 0 : _a2.removeEventListener(\n            \"addtrack\",\n            updateDefaultSubtitlesCallback\n          );\n          (_b2 = media.textTracks) == null ? void 0 : _b2.removeEventListener(\n            \"removetrack\",\n            updateDefaultSubtitlesCallback\n          );\n        };\n      }\n    ]\n  },\n  mediaChaptersCues: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!media)\n        return [];\n      const [chaptersTrack] = getTextTracksList(media, {\n        kind: TextTrackKinds.CHAPTERS\n      });\n      return Array.from((_a = chaptersTrack == null ? void 0 : chaptersTrack.cues) != null ? _a : []).map(\n        ({ text, startTime, endTime }) => ({\n          text: parseHtmlToText(text),\n          startTime,\n          endTime\n        })\n      );\n    },\n    mediaEvents: [\"loadstart\", \"loadedmetadata\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\", \"change\"],\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        var _a;\n        const { media } = stateOwners;\n        if (!media)\n          return;\n        const chaptersTrack = media.querySelector(\n          'track[kind=\"chapters\"][default][src]'\n        );\n        const shadowChaptersTrack = (_a = media.shadowRoot) == null ? void 0 : _a.querySelector(\n          ':is(video,audio) > track[kind=\"chapters\"][default][src]'\n        );\n        chaptersTrack == null ? void 0 : chaptersTrack.addEventListener(\"load\", handler);\n        shadowChaptersTrack == null ? void 0 : shadowChaptersTrack.addEventListener(\"load\", handler);\n        return () => {\n          chaptersTrack == null ? void 0 : chaptersTrack.removeEventListener(\"load\", handler);\n          shadowChaptersTrack == null ? void 0 : shadowChaptersTrack.removeEventListener(\"load\", handler);\n        };\n      }\n    ]\n  },\n  // Modeling state tied to root node\n  mediaIsPip: {\n    get(stateOwners) {\n      var _a, _b;\n      const { media, documentElement } = stateOwners;\n      if (!media || !documentElement)\n        return false;\n      if (!documentElement.pictureInPictureElement)\n        return false;\n      if (documentElement.pictureInPictureElement === media)\n        return true;\n      if (documentElement.pictureInPictureElement instanceof HTMLMediaElement) {\n        if (!((_a = media.localName) == null ? void 0 : _a.includes(\"-\")))\n          return false;\n        return containsComposedNode(\n          media,\n          documentElement.pictureInPictureElement\n        );\n      }\n      if (documentElement.pictureInPictureElement.localName.includes(\"-\")) {\n        let currentRoot = documentElement.pictureInPictureElement.shadowRoot;\n        while (currentRoot == null ? void 0 : currentRoot.pictureInPictureElement) {\n          if (currentRoot.pictureInPictureElement === media)\n            return true;\n          currentRoot = (_b = currentRoot.pictureInPictureElement) == null ? void 0 : _b.shadowRoot;\n        }\n      }\n      return false;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (value) {\n        if (!document.pictureInPictureEnabled) {\n          console.warn(\"MediaChrome: Picture-in-picture is not enabled\");\n          return;\n        }\n        if (!media.requestPictureInPicture) {\n          console.warn(\n            \"MediaChrome: The current media does not support picture-in-picture\"\n          );\n          return;\n        }\n        const warnNotReady = () => {\n          console.warn(\n            \"MediaChrome: The media is not ready for picture-in-picture. It must have a readyState > 0.\"\n          );\n        };\n        media.requestPictureInPicture().catch((err) => {\n          if (err.code === 11) {\n            if (!media.src) {\n              console.warn(\n                \"MediaChrome: The media is not ready for picture-in-picture. It must have a src set.\"\n              );\n              return;\n            }\n            if (media.readyState === 0 && media.preload === \"none\") {\n              const cleanup = () => {\n                media.removeEventListener(\"loadedmetadata\", tryPip);\n                media.preload = \"none\";\n              };\n              const tryPip = () => {\n                media.requestPictureInPicture().catch(warnNotReady);\n                cleanup();\n              };\n              media.addEventListener(\"loadedmetadata\", tryPip);\n              media.preload = \"metadata\";\n              setTimeout(() => {\n                if (media.readyState === 0)\n                  warnNotReady();\n                cleanup();\n              }, 1e3);\n            } else {\n              throw err;\n            }\n          } else {\n            throw err;\n          }\n        });\n      } else if (document.pictureInPictureElement) {\n        document.exitPictureInPicture();\n      }\n    },\n    mediaEvents: [\"enterpictureinpicture\", \"leavepictureinpicture\"]\n  },\n  mediaRenditionList: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return [...(_a = media == null ? void 0 : media.videoRenditions) != null ? _a : []].map((videoRendition) => ({\n        ...videoRendition\n      }));\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\"]\n  },\n  /** @TODO Model this as a derived value? (CJP) */\n  mediaRenditionSelected: {\n    get(stateOwners) {\n      var _a, _b, _c;\n      const { media } = stateOwners;\n      return (_c = (_b = media == null ? void 0 : media.videoRenditions) == null ? void 0 : _b[(_a = media.videoRenditions) == null ? void 0 : _a.selectedIndex]) == null ? void 0 : _c.id;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.videoRenditions)) {\n        console.warn(\n          \"MediaController: Rendition selection not supported by this media.\"\n        );\n        return;\n      }\n      const renditionId = value;\n      const index = Array.prototype.findIndex.call(\n        media.videoRenditions,\n        (r) => r.id == renditionId\n      );\n      if (media.videoRenditions.selectedIndex != index) {\n        media.videoRenditions.selectedIndex = index;\n      }\n    },\n    mediaEvents: [\"emptied\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\", \"change\"]\n  },\n  mediaAudioTrackList: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return [...(_a = media == null ? void 0 : media.audioTracks) != null ? _a : []];\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaAudioTrackEnabled: {\n    get(stateOwners) {\n      var _a, _b;\n      const { media } = stateOwners;\n      return (_b = [...(_a = media == null ? void 0 : media.audioTracks) != null ? _a : []].find(\n        (audioTrack) => audioTrack.enabled\n      )) == null ? void 0 : _b.id;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.audioTracks)) {\n        console.warn(\n          \"MediaChrome: Audio track selection not supported by this media.\"\n        );\n        return;\n      }\n      const audioTrackId = value;\n      for (const track of media.audioTracks) {\n        track.enabled = audioTrackId == track.id;\n      }\n    },\n    mediaEvents: [\"emptied\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\", \"change\"]\n  },\n  mediaIsFullscreen: {\n    get(stateOwners) {\n      return isFullscreen(stateOwners);\n    },\n    set(value, stateOwners) {\n      if (!value) {\n        exitFullscreen(stateOwners);\n      } else {\n        enterFullscreen(stateOwners);\n      }\n    },\n    // older Safari version may require webkit-specific events\n    rootEvents: [\"fullscreenchange\", \"webkitfullscreenchange\"],\n    // iOS requires webkit-specific events on the video.\n    mediaEvents: [\n      \"webkitbeginfullscreen\",\n      \"webkitendfullscreen\",\n      \"webkitpresentationmodechanged\"\n    ]\n  },\n  mediaIsCasting: {\n    // Note this relies on a customized castable-video element.\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.remote) || ((_a = media.remote) == null ? void 0 : _a.state) === \"disconnected\")\n        return false;\n      return !!media.remote.state;\n    },\n    set(value, stateOwners) {\n      var _a, _b;\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (value && ((_a = media.remote) == null ? void 0 : _a.state) !== \"disconnected\")\n        return;\n      if (!value && ((_b = media.remote) == null ? void 0 : _b.state) !== \"connected\")\n        return;\n      if (typeof media.remote.prompt !== \"function\") {\n        console.warn(\n          \"MediaChrome: Casting is not supported in this environment\"\n        );\n        return;\n      }\n      media.remote.prompt().catch(() => {\n      });\n    },\n    remoteEvents: [\"connect\", \"connecting\", \"disconnect\"]\n  },\n  // NOTE: Newly added state for tracking airplaying\n  mediaIsAirplaying: {\n    // NOTE: Cannot know if airplaying since Safari doesn't fully support HTMLMediaElement::remote yet (e.g. remote::state) (CJP)\n    get() {\n      return false;\n    },\n    set(_value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (!(media.webkitShowPlaybackTargetPicker && globalThis.WebKitPlaybackTargetAvailabilityEvent)) {\n        console.error(\n          \"MediaChrome: received a request to select AirPlay but AirPlay is not supported in this environment\"\n        );\n        return;\n      }\n      media.webkitShowPlaybackTargetPicker();\n    },\n    mediaEvents: [\"webkitcurrentplaybacktargetiswirelesschanged\"]\n  },\n  mediaFullscreenUnavailable: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (!fullscreenSupported || !hasFullscreenSupport(media))\n        return AvailabilityStates.UNSUPPORTED;\n      return void 0;\n    }\n  },\n  mediaPipUnavailable: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (!pipSupported || !hasPipSupport(media))\n        return AvailabilityStates.UNSUPPORTED;\n    }\n  },\n  mediaVolumeUnavailable: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (volumeSupported === false || (media == null ? void 0 : media.volume) == void 0) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      return void 0;\n    },\n    // NOTE: Slightly different impl here. Added generic support for\n    // \"stateOwnersUpdateHandlers\" since the original impl had to hack around\n    // race conditions. (CJP)\n    stateOwnersUpdateHandlers: [\n      (handler) => {\n        if (volumeSupported == null) {\n          volumeSupportPromise.then(\n            (supported) => handler(supported ? void 0 : AvailabilityStates.UNSUPPORTED)\n          );\n        }\n      }\n    ]\n  },\n  mediaCastUnavailable: {\n    // @ts-ignore\n    get(stateOwners, { availability = \"not-available\" } = {}) {\n      var _a;\n      const { media } = stateOwners;\n      if (!castSupported || !((_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.state)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (availability == null || availability === \"available\")\n        return void 0;\n      return AvailabilityStates.UNAVAILABLE;\n    },\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        var _a;\n        const { media } = stateOwners;\n        if (!media)\n          return;\n        const remotePlaybackDisabled = media.disableRemotePlayback || media.hasAttribute(\"disableremoteplayback\");\n        if (!remotePlaybackDisabled) {\n          (_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.watchAvailability((availabilityBool) => {\n            const availability = availabilityBool ? \"available\" : \"not-available\";\n            handler({ availability });\n          }).catch((error) => {\n            if (error.name === \"NotSupportedError\") {\n              handler({ availability: null });\n            } else {\n              handler({ availability: \"not-available\" });\n            }\n          });\n        }\n        return () => {\n          var _a2;\n          (_a2 = media == null ? void 0 : media.remote) == null ? void 0 : _a2.cancelWatchAvailability().catch(() => {\n          });\n        };\n      }\n    ]\n  },\n  mediaAirplayUnavailable: {\n    get(_stateOwners, event) {\n      if (!airplaySupported)\n        return AvailabilityStates.UNSUPPORTED;\n      if ((event == null ? void 0 : event.availability) === \"not-available\") {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    // NOTE: Keeping this event, as it's still the documented way of monitoring\n    // for AirPlay availability from Apple.\n    // See: https://developer.apple.com/documentation/webkitjs/adding_an_airplay_button_to_your_safari_media_controls#2940021 (CJP)\n    mediaEvents: [\"webkitplaybacktargetavailabilitychanged\"],\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        var _a;\n        const { media } = stateOwners;\n        if (!media)\n          return;\n        const remotePlaybackDisabled = media.disableRemotePlayback || media.hasAttribute(\"disableremoteplayback\");\n        if (!remotePlaybackDisabled) {\n          (_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.watchAvailability((availabilityBool) => {\n            const availability = availabilityBool ? \"available\" : \"not-available\";\n            handler({ availability });\n          }).catch((error) => {\n            if (error.name === \"NotSupportedError\") {\n              handler({ availability: null });\n            } else {\n              handler({ availability: \"not-available\" });\n            }\n          });\n        }\n        return () => {\n          var _a2;\n          (_a2 = media == null ? void 0 : media.remote) == null ? void 0 : _a2.cancelWatchAvailability().catch(() => {\n          });\n        };\n      }\n    ]\n  },\n  mediaRenditionUnavailable: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.videoRenditions)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (!((_a = media.videoRenditions) == null ? void 0 : _a.length)) {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\"]\n  },\n  mediaAudioTrackUnavailable: {\n    get(stateOwners) {\n      var _a, _b;\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.audioTracks)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (((_b = (_a = media.audioTracks) == null ? void 0 : _a.length) != null ? _b : 0) <= 1) {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\"]\n  }\n};\nexport {\n  prepareStateOwners,\n  stateMediator,\n  volumeSupportPromise\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}