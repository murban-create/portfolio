{"ast":null,"code":"import { isValidNumber } from \"./utils.js\";\nconst UnitLabels = [{\n  singular: \"hour\",\n  plural: \"hours\"\n}, {\n  singular: \"minute\",\n  plural: \"minutes\"\n}, {\n  singular: \"second\",\n  plural: \"seconds\"\n}];\nconst toTimeUnitPhrase = (timeUnitValue, unitIndex) => {\n  const unitLabel = timeUnitValue === 1 ? UnitLabels[unitIndex].singular : UnitLabels[unitIndex].plural;\n  return `${timeUnitValue} ${unitLabel}`;\n};\nconst formatAsTimePhrase = seconds => {\n  if (!isValidNumber(seconds)) return \"\";\n  const positiveSeconds = Math.abs(seconds);\n  const negative = positiveSeconds !== seconds;\n  const secondsDateTime = new Date(0, 0, 0, 0, 0, positiveSeconds, 0);\n  const timeParts = [secondsDateTime.getHours(), secondsDateTime.getMinutes(), secondsDateTime.getSeconds()];\n  const timeString = timeParts.map((timeUnitValue, index) => timeUnitValue && toTimeUnitPhrase(timeUnitValue, index)).filter(x => x).join(\", \");\n  const negativeSuffix = negative ? \" remaining\" : \"\";\n  return `${timeString}${negativeSuffix}`;\n};\nfunction formatTime(seconds, guide) {\n  let negative = false;\n  if (seconds < 0) {\n    negative = true;\n    seconds = 0 - seconds;\n  }\n  seconds = seconds < 0 ? 0 : seconds;\n  let s = Math.floor(seconds % 60);\n  let m = Math.floor(seconds / 60 % 60);\n  let h = Math.floor(seconds / 3600);\n  const gm = Math.floor(guide / 60 % 60);\n  const gh = Math.floor(guide / 3600);\n  if (isNaN(seconds) || seconds === Infinity) {\n    h = m = s = \"0\";\n  }\n  h = h > 0 || gh > 0 ? h + \":\" : \"\";\n  m = ((h || gm >= 10) && m < 10 ? \"0\" + m : m) + \":\";\n  s = s < 10 ? \"0\" + s : s;\n  return (negative ? \"-\" : \"\") + h + m + s;\n}\nconst emptyTimeRanges = Object.freeze({\n  length: 0,\n  start(index) {\n    const unsignedIdx = index >>> 0;\n    if (unsignedIdx >= this.length) {\n      throw new DOMException(`Failed to execute 'start' on 'TimeRanges': The index provided (${unsignedIdx}) is greater than or equal to the maximum bound (${this.length}).`);\n    }\n    return 0;\n  },\n  end(index) {\n    const unsignedIdx = index >>> 0;\n    if (unsignedIdx >= this.length) {\n      throw new DOMException(`Failed to execute 'end' on 'TimeRanges': The index provided (${unsignedIdx}) is greater than or equal to the maximum bound (${this.length}).`);\n    }\n    return 0;\n  }\n});\nfunction serializeTimeRanges() {\n  let timeRanges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyTimeRanges;\n  return Array.from(timeRanges).map((_, i) => [Number(timeRanges.start(i).toFixed(3)), Number(timeRanges.end(i).toFixed(3))].join(\":\")).join(\" \");\n}\nexport { emptyTimeRanges, formatAsTimePhrase, formatTime, serializeTimeRanges };","map":null,"metadata":{},"sourceType":"module"}