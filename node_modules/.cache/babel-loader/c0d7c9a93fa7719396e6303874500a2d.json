{"ast":null,"code":"import ue from \"mux-embed\";\nimport Ze from \"hls.js\";\nvar g = Ze;\nvar C = {\n    VIDEO: \"video\",\n    THUMBNAIL: \"thumbnail\",\n    STORYBOARD: \"storyboard\",\n    DRM: \"drm\"\n  },\n  D = {\n    NOT_AN_ERROR: 0,\n    NETWORK_OFFLINE: 2000002,\n    NETWORK_UNKNOWN_ERROR: 2e6,\n    NETWORK_NO_STATUS: 2000001,\n    NETWORK_INVALID_URL: 24e5,\n    NETWORK_NOT_FOUND: 2404e3,\n    NETWORK_NOT_READY: 2412e3,\n    NETWORK_GENERIC_SERVER_FAIL: 25e5,\n    NETWORK_TOKEN_MISSING: 2403201,\n    NETWORK_TOKEN_MALFORMED: 2412202,\n    NETWORK_TOKEN_EXPIRED: 2403210,\n    NETWORK_TOKEN_AUD_MISSING: 2403221,\n    NETWORK_TOKEN_AUD_MISMATCH: 2403222,\n    NETWORK_TOKEN_SUB_MISMATCH: 2403232,\n    ENCRYPTED_ERROR: 5e6,\n    ENCRYPTED_UNSUPPORTED_KEY_SYSTEM: 5000001,\n    ENCRYPTED_GENERATE_REQUEST_FAILED: 5000002,\n    ENCRYPTED_UPDATE_LICENSE_FAILED: 5000003,\n    ENCRYPTED_UPDATE_SERVER_CERT_FAILED: 5000004,\n    ENCRYPTED_CDM_ERROR: 5000005,\n    ENCRYPTED_OUTPUT_RESTRICTED: 5000006,\n    ENCRYPTED_MISSING_TOKEN: 5000002\n  },\n  V = e => e === C.VIDEO ? \"playback\" : e,\n  L = class L extends Error {\n    constructor(t) {\n      let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : L.MEDIA_ERR_CUSTOM;\n      let n = arguments.length > 2 ? arguments[2] : undefined;\n      let o = arguments.length > 3 ? arguments[3] : undefined;\n      var a;\n      super(t), this.name = \"MediaError\", this.code = r, this.context = o, this.fatal = n != null ? n : r >= L.MEDIA_ERR_NETWORK && r <= L.MEDIA_ERR_ENCRYPTED, this.message || (this.message = (a = L.defaultMessages[this.code]) != null ? a : \"\");\n    }\n  };\nL.MEDIA_ERR_ABORTED = 1, L.MEDIA_ERR_NETWORK = 2, L.MEDIA_ERR_DECODE = 3, L.MEDIA_ERR_SRC_NOT_SUPPORTED = 4, L.MEDIA_ERR_ENCRYPTED = 5, L.MEDIA_ERR_CUSTOM = 100, L.defaultMessages = {\n  1: \"You aborted the media playback\",\n  2: \"A network error caused the media download to fail.\",\n  3: \"A media error caused playback to be aborted. The media could be corrupt or your browser does not support this format.\",\n  4: \"An unsupported error occurred. The server or network failed, or your browser does not support this format.\",\n  5: \"The media is encrypted and there are no keys to decrypt it.\"\n};\nvar f = L;\nvar et = e => e == null,\n  O = (e, t) => et(t) ? !1 : e in t,\n  K = {\n    ANY: \"any\",\n    MUTED: \"muted\"\n  },\n  _ = {\n    ON_DEMAND: \"on-demand\",\n    LIVE: \"live\",\n    UNKNOWN: \"unknown\"\n  },\n  X = {\n    MSE: \"mse\",\n    NATIVE: \"native\"\n  },\n  S = {\n    HEADER: \"header\",\n    QUERY: \"query\",\n    NONE: \"none\"\n  },\n  jt = Object.values(S),\n  A = {\n    M3U8: \"application/vnd.apple.mpegurl\",\n    MP4: \"video/mp4\"\n  },\n  W = {\n    HLS: A.M3U8\n  },\n  Jt = Object.keys(W),\n  qt = [...Object.values(A), \"hls\", \"HLS\"],\n  Gt = {\n    upTo720p: \"720p\",\n    upTo1080p: \"1080p\",\n    upTo1440p: \"1440p\",\n    upTo2160p: \"2160p\"\n  },\n  Xt = {\n    noLessThan480p: \"480p\",\n    noLessThan540p: \"540p\",\n    noLessThan720p: \"720p\",\n    noLessThan1080p: \"1080p\",\n    noLessThan1440p: \"1440p\",\n    noLessThan2160p: \"2160p\"\n  },\n  zt = {\n    DESCENDING: \"desc\"\n  };\nvar tt = \"en\",\n  Y = {\n    code: tt\n  };\nvar v = function (e, t, r, n) {\n  let o = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : e;\n  o.addEventListener(t, r, n), e.addEventListener(\"teardown\", () => {\n    o.removeEventListener(t, r);\n  }, {\n    once: !0\n  });\n};\nfunction fe(e, t, r) {\n  t && r > t && (r = t);\n  for (let n = 0; n < e.length; n++) if (e.start(n) <= r && e.end(n) >= r) return !0;\n  return !1;\n}\nvar F = e => {\n    let t = e.indexOf(\"?\");\n    if (t < 0) return [e];\n    let r = e.slice(0, t),\n      n = e.slice(t);\n    return [r, n];\n  },\n  U = e => {\n    let {\n      type: t\n    } = e;\n    if (t) {\n      let r = t.toUpperCase();\n      return O(r, W) ? W[r] : t;\n    }\n    return rt(e);\n  },\n  Q = e => e === \"VOD\" ? _.ON_DEMAND : _.LIVE,\n  Z = e => e === \"EVENT\" ? Number.POSITIVE_INFINITY : e === \"VOD\" ? Number.NaN : 0,\n  rt = e => {\n    let {\n      src: t\n    } = e;\n    if (!t) return \"\";\n    let r = \"\";\n    try {\n      r = new URL(t).pathname;\n    } catch {\n      console.error(\"invalid url\");\n    }\n    let n = r.lastIndexOf(\".\");\n    if (n < 0) return ot(e) ? A.M3U8 : \"\";\n    let a = r.slice(n + 1).toUpperCase();\n    return O(a, A) ? A[a] : \"\";\n  },\n  nt = \"mux.com\",\n  ot = _ref => {\n    let {\n      src: e,\n      customDomain: t = nt\n    } = _ref;\n    let r;\n    try {\n      r = new URL(`${e}`);\n    } catch {\n      return !1;\n    }\n    let n = r.protocol === \"https:\",\n      o = r.hostname === `stream.${t}`.toLowerCase(),\n      a = r.pathname.split(\"/\"),\n      i = a.length === 2,\n      c = !(a != null && a[1].includes(\".\"));\n    return n && o && i && c;\n  },\n  ee = e => {\n    let t = (e != null ? e : \"\").split(\".\")[1];\n    if (t) try {\n      let r = t.replace(/-/g, \"+\").replace(/_/g, \"/\"),\n        n = decodeURIComponent(atob(r).split(\"\").map(function (o) {\n          return \"%\" + (\"00\" + o.charCodeAt(0).toString(16)).slice(-2);\n        }).join(\"\"));\n      return JSON.parse(n);\n    } catch {\n      return;\n    }\n  },\n  Te = function (_ref2) {\n    let {\n      exp: e\n    } = _ref2;\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Date.now();\n    return !e || e * 1e3 < t;\n  },\n  ye = (_ref3, t) => {\n    let {\n      sub: e\n    } = _ref3;\n    return e !== t;\n  },\n  me = (_ref4, t) => {\n    let {\n      aud: e\n    } = _ref4;\n    return !e;\n  },\n  Ee = (_ref5, t) => {\n    let {\n      aud: e\n    } = _ref5;\n    return e !== t;\n  },\n  ge = \"en\";\nfunction x(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n  var o, a;\n  let r = t && (a = (o = Y) == null ? void 0 : o[e]) != null ? a : e,\n    n = t ? Y.code : ge;\n  return new z(r, n);\n}\nvar z = class {\n  constructor(t) {\n    let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n => (n = Y) != null ? n : ge)();\n    this.message = t, this.locale = r;\n  }\n  format(t) {\n    return this.message.replace(/\\{(\\w+)\\}/g, (r, n) => {\n      var o;\n      return (o = t[n]) != null ? o : \"\";\n    });\n  }\n  toString() {\n    return this.message;\n  }\n};\nvar at = Object.values(K),\n  Me = e => typeof e == \"boolean\" || typeof e == \"string\" && at.includes(e),\n  xe = (e, t, r) => {\n    let {\n        autoplay: n\n      } = e,\n      o = !1,\n      a = !1,\n      i = Me(n) ? n : !!n,\n      c = () => {\n        o || v(t, \"playing\", () => {\n          o = !0;\n        }, {\n          once: !0\n        });\n      };\n    if (c(), v(t, \"loadstart\", () => {\n      o = !1, c(), te(t, i);\n    }, {\n      once: !0\n    }), v(t, \"loadstart\", () => {\n      r || (e.streamType && e.streamType !== _.UNKNOWN ? a = e.streamType === _.LIVE : a = !Number.isFinite(t.duration)), te(t, i);\n    }, {\n      once: !0\n    }), r && r.once(g.Events.LEVEL_LOADED, (u, s) => {\n      var p;\n      e.streamType && e.streamType !== _.UNKNOWN ? a = e.streamType === _.LIVE : a = (p = s.details.live) != null ? p : !1;\n    }), !i) {\n      let u = () => {\n        !a || Number.isFinite(e.startTime) || (r != null && r.liveSyncPosition ? t.currentTime = r.liveSyncPosition : Number.isFinite(t.seekable.end(0)) && (t.currentTime = t.seekable.end(0)));\n      };\n      r && v(t, \"play\", () => {\n        t.preload === \"metadata\" ? r.once(g.Events.LEVEL_UPDATED, u) : u();\n      }, {\n        once: !0\n      });\n    }\n    return u => {\n      o || (i = Me(u) ? u : !!u, te(t, i));\n    };\n  },\n  te = (e, t) => {\n    if (!t) return;\n    let r = e.muted,\n      n = () => e.muted = r;\n    switch (t) {\n      case K.ANY:\n        e.play().catch(() => {\n          e.muted = !0, e.play().catch(n);\n        });\n        break;\n      case K.MUTED:\n        e.muted = !0, e.play().catch(n);\n        break;\n      default:\n        e.play().catch(() => {});\n        break;\n    }\n  };\nvar Re = (_ref6, r, n) => {\n  let {\n    preload: e,\n    src: t\n  } = _ref6;\n  let o = p => {\n    p != null && [\"\", \"none\", \"metadata\", \"auto\"].includes(p) ? r.setAttribute(\"preload\", p) : r.removeAttribute(\"preload\");\n  };\n  if (!n) return o(e), o;\n  let a = !1,\n    i = !1,\n    c = n.config.maxBufferLength,\n    d = n.config.maxBufferSize,\n    u = p => {\n      o(p);\n      let l = p != null ? p : r.preload;\n      i || l === \"none\" || (l === \"metadata\" ? (n.config.maxBufferLength = 1, n.config.maxBufferSize = 1) : (n.config.maxBufferLength = c, n.config.maxBufferSize = d), s());\n    },\n    s = () => {\n      !a && t && (a = !0, n.loadSource(t));\n    };\n  return v(r, \"play\", () => {\n    i = !0, n.config.maxBufferLength = c, n.config.maxBufferSize = d, s();\n  }, {\n    once: !0\n  }), u(e), u;\n};\nfunction De(e, t) {\n  var c;\n  if (!(\"videoTracks\" in e)) return;\n  let r = new WeakMap();\n  t.on(g.Events.MANIFEST_PARSED, function (d, u) {\n    i();\n    let s = e.addVideoTrack(\"main\");\n    s.selected = !0;\n    for (let [p, l] of u.levels.entries()) {\n      let T = s.addRendition(l.url[0], l.width, l.height, l.videoCodec, l.bitrate);\n      r.set(l, `${p}`), T.id = `${p}`;\n    }\n  }), t.on(g.Events.AUDIO_TRACKS_UPDATED, function (d, u) {\n    a();\n    for (let s of u.audioTracks) {\n      let p = s.default ? \"main\" : \"alternative\",\n        l = e.addAudioTrack(p, s.name, s.lang);\n      l.id = `${s.id}`, s.default && (l.enabled = !0);\n    }\n  }), e.audioTracks.addEventListener(\"change\", () => {\n    var s;\n    let d = +((s = [...e.audioTracks].find(p => p.enabled)) == null ? void 0 : s.id),\n      u = t.audioTracks.map(p => p.id);\n    d != t.audioTrack && u.includes(d) && (t.audioTrack = d);\n  }), t.on(g.Events.LEVELS_UPDATED, function (d, u) {\n    var l;\n    let s = e.videoTracks[(l = e.videoTracks.selectedIndex) != null ? l : 0];\n    if (!s) return;\n    let p = u.levels.map(T => r.get(T));\n    for (let T of e.videoRenditions) T.id && !p.includes(T.id) && s.removeRendition(T);\n  });\n  let n = d => {\n    let u = d.target.selectedIndex;\n    u != t.nextLevel && (t.nextLevel = u);\n  };\n  (c = e.videoRenditions) == null || c.addEventListener(\"change\", n);\n  let o = () => {\n      for (let d of e.videoTracks) e.removeVideoTrack(d);\n    },\n    a = () => {\n      for (let d of e.audioTracks) e.removeAudioTrack(d);\n    },\n    i = () => {\n      o(), a();\n    };\n  t.once(g.Events.DESTROYING, i);\n}\nvar re = e => \"time\" in e ? e.time : e.startTime;\nfunction be(e, t) {\n  t.on(g.Events.NON_NATIVE_TEXT_TRACKS_FOUND, (o, _ref7) => {\n    let {\n      tracks: a\n    } = _ref7;\n    a.forEach(i => {\n      var s, p;\n      let c = (s = i.subtitleTrack) != null ? s : i.closedCaptions,\n        d = t.subtitleTracks.findIndex(_ref8 => {\n          let {\n            lang: l,\n            name: T,\n            type: m\n          } = _ref8;\n          return l == (c == null ? void 0 : c.lang) && T === i.label && m.toLowerCase() === i.kind;\n        }),\n        u = ((p = i._id) != null ? p : i.default) ? \"default\" : `${i.kind}${d}`;\n      ne(e, i.kind, i.label, c == null ? void 0 : c.lang, u, i.default);\n    });\n  });\n  let r = () => {\n    if (!t.subtitleTracks.length) return;\n    let o = Array.from(e.textTracks).find(c => c.id && c.mode === \"showing\" && [\"subtitles\", \"captions\"].includes(c.kind));\n    if (!o) return;\n    let a = t.subtitleTracks[t.subtitleTrack],\n      i = a ? a.default ? \"default\" : `${t.subtitleTracks[t.subtitleTrack].type.toLowerCase()}${t.subtitleTrack}` : void 0;\n    if (t.subtitleTrack < 0 || (o == null ? void 0 : o.id) !== i) {\n      let c = t.subtitleTracks.findIndex(_ref9 => {\n        let {\n          lang: d,\n          name: u,\n          type: s,\n          default: p\n        } = _ref9;\n        return o.id === \"default\" && p || d == o.language && u === o.label && s.toLowerCase() === o.kind;\n      });\n      t.subtitleTrack = c;\n    }\n    (o == null ? void 0 : o.id) === i && o.cues && Array.from(o.cues).forEach(c => {\n      o.addCue(c);\n    });\n  };\n  e.textTracks.addEventListener(\"change\", r), t.on(g.Events.CUES_PARSED, (o, _ref10) => {\n    let {\n      track: a,\n      cues: i\n    } = _ref10;\n    let c = e.textTracks.getTrackById(a);\n    if (!c) return;\n    let d = c.mode === \"disabled\";\n    d && (c.mode = \"hidden\"), i.forEach(u => {\n      var s;\n      (s = c.cues) != null && s.getCueById(u.id) || c.addCue(u);\n    }), d && (c.mode = \"disabled\");\n  }), t.once(g.Events.DESTROYING, () => {\n    e.textTracks.removeEventListener(\"change\", r), e.querySelectorAll(\"track[data-removeondestroy]\").forEach(a => {\n      a.remove();\n    });\n  });\n  let n = () => {\n    Array.from(e.textTracks).forEach(o => {\n      var a, i;\n      if (![\"subtitles\", \"caption\"].includes(o.kind) && (o.label === \"thumbnails\" || o.kind === \"chapters\")) {\n        if (!((a = o.cues) != null && a.length)) {\n          let c = \"track\";\n          o.kind && (c += `[kind=\"${o.kind}\"]`), o.label && (c += `[label=\"${o.label}\"]`);\n          let d = e.querySelector(c),\n            u = (i = d == null ? void 0 : d.getAttribute(\"src\")) != null ? i : \"\";\n          d == null || d.removeAttribute(\"src\"), setTimeout(() => {\n            d == null || d.setAttribute(\"src\", u);\n          }, 0);\n        }\n        o.mode !== \"hidden\" && (o.mode = \"hidden\");\n      }\n    });\n  };\n  t.once(g.Events.MANIFEST_LOADED, n), t.once(g.Events.MEDIA_ATTACHED, n);\n}\nfunction ne(e, t, r, n, o, a) {\n  let i = document.createElement(\"track\");\n  return i.kind = t, i.label = r, n && (i.srclang = n), o && (i.id = o), a && (i.default = !0), i.track.mode = [\"subtitles\", \"captions\"].includes(t) ? \"disabled\" : \"hidden\", i.setAttribute(\"data-removeondestroy\", \"\"), e.append(i), i.track;\n}\nfunction st(e, t) {\n  let r = Array.prototype.find.call(e.querySelectorAll(\"track\"), n => n.track === t);\n  r == null || r.remove();\n}\nfunction w(e, t, r) {\n  var n;\n  return (n = Array.from(e.querySelectorAll(\"track\")).find(o => o.track.label === t && o.track.kind === r)) == null ? void 0 : n.track;\n}\nasync function Ce(e, t, r, n) {\n  let o = w(e, r, n);\n  return o || (o = ne(e, n, r), o.mode = \"hidden\", await new Promise(a => setTimeout(() => a(void 0), 0))), o.mode !== \"hidden\" && (o.mode = \"hidden\"), [...t].sort((a, i) => re(i) - re(a)).forEach(a => {\n    var d, u;\n    let i = a.value,\n      c = re(a);\n    if (\"endTime\" in a && a.endTime != null) o == null || o.addCue(new VTTCue(c, a.endTime, n === \"chapters\" ? i : JSON.stringify(i != null ? i : null)));else {\n      let s = Array.prototype.findIndex.call(o == null ? void 0 : o.cues, m => m.startTime >= c),\n        p = (d = o == null ? void 0 : o.cues) == null ? void 0 : d[s],\n        l = p ? p.startTime : Number.isFinite(e.duration) ? e.duration : Number.MAX_SAFE_INTEGER,\n        T = (u = o == null ? void 0 : o.cues) == null ? void 0 : u[s - 1];\n      T && (T.endTime = c), o == null || o.addCue(new VTTCue(c, l, n === \"chapters\" ? i : JSON.stringify(i != null ? i : null)));\n    }\n  }), e.textTracks.dispatchEvent(new Event(\"change\", {\n    bubbles: !0,\n    composed: !0\n  })), o;\n}\nvar oe = \"cuepoints\",\n  ve = Object.freeze({\n    label: oe\n  });\nasync function Pe(e, t) {\n  let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ve;\n  return Ce(e, t, r.label, \"metadata\");\n}\nvar $ = e => ({\n  time: e.startTime,\n  value: JSON.parse(e.text)\n});\nfunction it(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    label: oe\n  };\n  let r = w(e, t.label, \"metadata\");\n  return r != null && r.cues ? Array.from(r.cues, n => $(n)) : [];\n}\nfunction _e(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    label: oe\n  };\n  var a, i;\n  let r = w(e, t.label, \"metadata\");\n  if (!((a = r == null ? void 0 : r.activeCues) != null && a.length)) return;\n  if (r.activeCues.length === 1) return $(r.activeCues[0]);\n  let {\n      currentTime: n\n    } = e,\n    o = Array.prototype.find.call((i = r.activeCues) != null ? i : [], _ref11 => {\n      let {\n        startTime: c,\n        endTime: d\n      } = _ref11;\n      return c <= n && d > n;\n    });\n  return $(o || r.activeCues[0]);\n}\nasync function ke(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ve;\n  return new Promise(r => {\n    v(e, \"loadstart\", async () => {\n      let n = await Pe(e, [], t);\n      v(e, \"cuechange\", () => {\n        let o = _e(e);\n        if (o) {\n          let a = new CustomEvent(\"cuepointchange\", {\n            composed: !0,\n            bubbles: !0,\n            detail: o\n          });\n          e.dispatchEvent(a);\n        }\n      }, {}, n), r(n);\n    });\n  });\n}\nvar ae = \"chapters\",\n  he = Object.freeze({\n    label: ae\n  }),\n  B = e => ({\n    startTime: e.startTime,\n    endTime: e.endTime,\n    value: e.text\n  });\nasync function Le(e, t) {\n  let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : he;\n  return Ce(e, t, r.label, \"chapters\");\n}\nfunction ct(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    label: ae\n  };\n  var n;\n  let r = w(e, t.label, \"chapters\");\n  return (n = r == null ? void 0 : r.cues) != null && n.length ? Array.from(r.cues, o => B(o)) : [];\n}\nfunction Ne(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    label: ae\n  };\n  var a, i;\n  let r = w(e, t.label, \"chapters\");\n  if (!((a = r == null ? void 0 : r.activeCues) != null && a.length)) return;\n  if (r.activeCues.length === 1) return B(r.activeCues[0]);\n  let {\n      currentTime: n\n    } = e,\n    o = Array.prototype.find.call((i = r.activeCues) != null ? i : [], _ref12 => {\n      let {\n        startTime: c,\n        endTime: d\n      } = _ref12;\n      return c <= n && d > n;\n    });\n  return B(o || r.activeCues[0]);\n}\nasync function Ae(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : he;\n  return new Promise(r => {\n    v(e, \"loadstart\", async () => {\n      let n = await Le(e, [], t);\n      v(e, \"cuechange\", () => {\n        let o = Ne(e);\n        if (o) {\n          let a = new CustomEvent(\"chapterchange\", {\n            composed: !0,\n            bubbles: !0,\n            detail: o\n          });\n          e.dispatchEvent(a);\n        }\n      }, {}, n), r(n);\n    });\n  });\n}\nfunction ut(e, t) {\n  if (t) {\n    let r = t.playingDate;\n    if (r != null) return new Date(r.getTime() - e.currentTime * 1e3);\n  }\n  return typeof e.getStartDate == \"function\" ? e.getStartDate() : new Date(NaN);\n}\nfunction dt(e, t) {\n  if (t && t.playingDate) return t.playingDate;\n  if (typeof e.getStartDate == \"function\") {\n    let r = e.getStartDate();\n    return new Date(r.getTime() + e.currentTime * 1e3);\n  }\n  return new Date(NaN);\n}\nvar se = {\n    VIDEO: \"v\",\n    THUMBNAIL: \"t\",\n    STORYBOARD: \"s\",\n    DRM: \"d\"\n  },\n  lt = e => {\n    if (e === C.VIDEO) return se.VIDEO;\n    if (e === C.DRM) return se.DRM;\n  },\n  pt = (e, t) => {\n    var o, a;\n    let r = V(e),\n      n = `${r}Token`;\n    return (o = t.tokens) != null && o[r] ? (a = t.tokens) == null ? void 0 : a[r] : O(n, t) ? t[n] : void 0;\n  },\n  H = function (e, t, r, n) {\n    let o = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;\n    let a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !(i => (i = globalThis.navigator) == null ? void 0 : i.onLine)();\n    var M, h;\n    if (a) {\n      let E = x(\"Your device appears to be offline\", o),\n        b = void 0,\n        y = f.MEDIA_ERR_NETWORK,\n        k = new f(E, y, !1, b);\n      return k.errorCategory = t, k.muxCode = D.NETWORK_OFFLINE, k.data = e, k;\n    }\n    let c = \"status\" in e ? e.status : e.code,\n      d = Date.now(),\n      u = f.MEDIA_ERR_NETWORK;\n    if (c === 200) return;\n    let s = V(t),\n      p = pt(t, r),\n      l = lt(t),\n      [T] = F((M = r.playbackId) != null ? M : \"\");\n    if (!c || !T) return;\n    let m = ee(p);\n    if (p && !m) {\n      let E = x(\"The {tokenNamePrefix}-token provided is invalid or malformed.\", o).format({\n          tokenNamePrefix: s\n        }),\n        b = x(\"Compact JWT string: {token}\", o).format({\n          token: p\n        }),\n        y = new f(E, u, !0, b);\n      return y.errorCategory = t, y.muxCode = D.NETWORK_TOKEN_MALFORMED, y.data = e, y;\n    }\n    if (c >= 500) {\n      let E = new f(\"\", u, n != null ? n : !0);\n      return E.errorCategory = t, E.muxCode = D.NETWORK_UNKNOWN_ERROR, E;\n    }\n    if (c === 403) if (m) {\n      if (Te(m, d)) {\n        let E = {\n            timeStyle: \"medium\",\n            dateStyle: \"medium\"\n          },\n          b = x(\"The video\\u2019s secured {tokenNamePrefix}-token has expired.\", o).format({\n            tokenNamePrefix: s\n          }),\n          y = x(\"Expired at: {expiredDate}. Current time: {currentDate}.\", o).format({\n            expiredDate: new Intl.DateTimeFormat(\"en\", E).format((h = m.exp) != null ? h : 0 * 1e3),\n            currentDate: new Intl.DateTimeFormat(\"en\", E).format(d)\n          }),\n          k = new f(b, u, !0, y);\n        return k.errorCategory = t, k.muxCode = D.NETWORK_TOKEN_EXPIRED, k.data = e, k;\n      }\n      if (ye(m, T)) {\n        let E = x(\"The video\\u2019s playback ID does not match the one encoded in the {tokenNamePrefix}-token.\", o).format({\n            tokenNamePrefix: s\n          }),\n          b = x(\"Specified playback ID: {playbackId} and the playback ID encoded in the {tokenNamePrefix}-token: {tokenPlaybackId}\", o).format({\n            tokenNamePrefix: s,\n            playbackId: T,\n            tokenPlaybackId: m.sub\n          }),\n          y = new f(E, u, !0, b);\n        return y.errorCategory = t, y.muxCode = D.NETWORK_TOKEN_SUB_MISMATCH, y.data = e, y;\n      }\n      if (me(m, l)) {\n        let E = x(\"The {tokenNamePrefix}-token is formatted with incorrect information.\", o).format({\n            tokenNamePrefix: s\n          }),\n          b = x(\"The {tokenNamePrefix}-token has no aud value. aud value should be {expectedAud}.\", o).format({\n            tokenNamePrefix: s,\n            expectedAud: l\n          }),\n          y = new f(E, u, !0, b);\n        return y.errorCategory = t, y.muxCode = D.NETWORK_TOKEN_AUD_MISSING, y.data = e, y;\n      }\n      if (Ee(m, l)) {\n        let E = x(\"The {tokenNamePrefix}-token is formatted with incorrect information.\", o).format({\n            tokenNamePrefix: s\n          }),\n          b = x(\"The {tokenNamePrefix}-token has an incorrect aud value: {aud}. aud value should be {expectedAud}.\", o).format({\n            tokenNamePrefix: s,\n            expectedAud: l,\n            aud: m.aud\n          }),\n          y = new f(E, u, !0, b);\n        return y.errorCategory = t, y.muxCode = D.NETWORK_TOKEN_AUD_MISMATCH, y.data = e, y;\n      }\n    } else {\n      let E = x(\"Authorization error trying to access this {category} URL. If this is a signed URL, you might need to provide a {tokenNamePrefix}-token.\", o).format({\n          tokenNamePrefix: s,\n          category: t\n        }),\n        b = x(\"Specified playback ID: {playbackId}\", o).format({\n          playbackId: T\n        }),\n        y = new f(E, u, n != null ? n : !0, b);\n      return y.errorCategory = t, y.muxCode = D.NETWORK_TOKEN_MISSING, y.data = e, y;\n    }\n    if (c === 412) {\n      let E = x(\"This playback-id may belong to a live stream that is not currently active or an asset that is not ready.\", o),\n        b = x(\"Specified playback ID: {playbackId}\", o).format({\n          playbackId: T\n        }),\n        y = new f(E, u, n != null ? n : !0, b);\n      return y.errorCategory = t, y.muxCode = D.NETWORK_NOT_READY, y.streamType = r.streamType === _.LIVE ? \"live\" : r.streamType === _.ON_DEMAND ? \"on-demand\" : \"unknown\", y.data = e, y;\n    }\n    if (c === 404) {\n      let E = x(\"This URL or playback-id does not exist. You may have used an Asset ID or an ID from a different resource.\", o),\n        b = x(\"Specified playback ID: {playbackId}\", o).format({\n          playbackId: T\n        }),\n        y = new f(E, u, n != null ? n : !0, b);\n      return y.errorCategory = t, y.muxCode = D.NETWORK_NOT_FOUND, y.data = e, y;\n    }\n    if (c === 400) {\n      let E = x(\"The URL or playback-id was invalid. You may have used an invalid value as a playback-id.\"),\n        b = x(\"Specified playback ID: {playbackId}\", o).format({\n          playbackId: T\n        }),\n        y = new f(E, u, n != null ? n : !0, b);\n      return y.errorCategory = t, y.muxCode = D.NETWORK_INVALID_URL, y.data = e, y;\n    }\n    let R = new f(\"\", u, n != null ? n : !0);\n    return R.errorCategory = t, R.muxCode = D.NETWORK_UNKNOWN_ERROR, R.data = e, R;\n  };\nvar Ie = g.DefaultConfig.capLevelController,\n  j = class j extends Ie {\n    constructor(t) {\n      super(t);\n    }\n    get levels() {\n      var t;\n      return (t = this.hls.levels) != null ? t : [];\n    }\n    getValidLevels(t) {\n      return this.levels.filter((r, n) => this.isLevelAllowed(r) && n <= t);\n    }\n    getMaxLevel(t) {\n      let r = super.getMaxLevel(t),\n        n = this.getValidLevels(t);\n      if (!n[r]) return r;\n      let o = Math.min(n[r].width, n[r].height),\n        a = j.minMaxResolution;\n      return o >= a ? r : Ie.getMaxLevelByMediaSize(n, a * (16 / 9), a);\n    }\n  };\nj.minMaxResolution = 720;\nvar ie = j,\n  Se = ie;\nvar J = {\n    FAIRPLAY: \"fairplay\",\n    PLAYREADY: \"playready\",\n    WIDEVINE: \"widevine\"\n  },\n  ft = e => {\n    if (e.includes(\"fps\")) return J.FAIRPLAY;\n    if (e.includes(\"playready\")) return J.PLAYREADY;\n    if (e.includes(\"widevine\")) return J.WIDEVINE;\n  },\n  Tt = e => {\n    let t = e.split(`\n`).find((r, n, o) => n && o[n - 1].startsWith(\"#EXT-X-STREAM-INF\"));\n    return fetch(t).then(r => r.status !== 200 ? Promise.reject(r) : r.text());\n  },\n  yt = e => {\n    let t = e.split(`\n`).filter(n => n.startsWith(\"#EXT-X-SESSION-DATA\"));\n    if (!t.length) return {};\n    let r = {};\n    for (let n of t) {\n      let o = Et(n),\n        a = o[\"DATA-ID\"];\n      a && (r[a] = {\n        ...o\n      });\n    }\n    return {\n      sessionData: r\n    };\n  },\n  mt = /([A-Z0-9-]+)=\"?(.*?)\"?(?:,|$)/g;\nfunction Et(e) {\n  let t = [...e.matchAll(mt)];\n  return Object.fromEntries(t.map(_ref13 => {\n    let [, r, n] = _ref13;\n    return [r, n];\n  }));\n}\nvar gt = e => {\n    var c, d, u;\n    let t = e.split(`\n`),\n      n = (d = ((c = t.find(s => s.startsWith(\"#EXT-X-PLAYLIST-TYPE\"))) != null ? c : \"\").split(\":\")[1]) == null ? void 0 : d.trim(),\n      o = Q(n),\n      a = Z(n),\n      i;\n    if (o === _.LIVE) {\n      let s = t.find(l => l.startsWith(\"#EXT-X-PART-INF\"));\n      if (!!s) i = +s.split(\":\")[1].split(\"=\")[1] * 2;else {\n        let l = t.find(R => R.startsWith(\"#EXT-X-TARGETDURATION\")),\n          T = (u = l == null ? void 0 : l.split(\":\")) == null ? void 0 : u[1];\n        i = +(T != null ? T : 6) * 3;\n      }\n    }\n    return {\n      streamType: o,\n      targetLiveWindow: a,\n      liveEdgeStartOffset: i\n    };\n  },\n  Mt = async (e, t) => {\n    if (t === A.MP4) return {\n      streamType: _.ON_DEMAND,\n      targetLiveWindow: Number.NaN,\n      liveEdgeStartOffset: void 0,\n      sessionData: void 0\n    };\n    if (t === A.M3U8) {\n      let r = await fetch(e);\n      if (!r.ok) return Promise.reject(r);\n      let n = await r.text(),\n        o = await Tt(n);\n      return {\n        ...yt(n),\n        ...gt(o)\n      };\n    }\n    return console.error(`Media type ${t} is an unrecognized or unsupported type for src ${e}.`), {\n      streamType: void 0,\n      targetLiveWindow: void 0,\n      liveEdgeStartOffset: void 0,\n      sessionData: void 0\n    };\n  },\n  xt = async function (e, t) {\n    let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : U({\n      src: e\n    });\n    var d, u, s, p;\n    let {\n        streamType: n,\n        targetLiveWindow: o,\n        liveEdgeStartOffset: a,\n        sessionData: i\n      } = await Mt(e, r),\n      c = i == null ? void 0 : i[\"com.apple.hls.chapters\"];\n    (c != null && c.URI || c != null && c.VALUE.toLocaleLowerCase().startsWith(\"http\")) && de((d = c.URI) != null ? d : c.VALUE, t), ((u = P.get(t)) != null ? u : {}).liveEdgeStartOffset = a, ((s = P.get(t)) != null ? s : {}).targetLiveWindow = o, t.dispatchEvent(new CustomEvent(\"targetlivewindowchange\", {\n      composed: !0,\n      bubbles: !0\n    })), ((p = P.get(t)) != null ? p : {}).streamType = n, t.dispatchEvent(new CustomEvent(\"streamtypechange\", {\n      composed: !0,\n      bubbles: !0\n    }));\n  },\n  de = async (e, t) => {\n    var r, n;\n    try {\n      let o = await fetch(e);\n      if (!o.ok) throw new Error(`Failed to fetch Mux metadata: ${o.status} ${o.statusText}`);\n      let a = await o.json(),\n        i = {};\n      if (!((r = a == null ? void 0 : a[0]) != null && r.metadata)) return;\n      for (let d of a[0].metadata) d.key && d.value && (i[d.key] = d.value);\n      ((n = P.get(t)) != null ? n : {}).metadata = i;\n      let c = new CustomEvent(\"muxmetadata\");\n      t.dispatchEvent(c);\n    } catch (o) {\n      console.error(o);\n    }\n  },\n  Rt = e => {\n    var i;\n    let t = e.type,\n      r = Q(t),\n      n = Z(t),\n      o,\n      a = !!((i = e.partList) != null && i.length);\n    return r === _.LIVE && (o = a ? e.partTarget * 2 : e.targetduration * 3), {\n      streamType: r,\n      targetLiveWindow: n,\n      liveEdgeStartOffset: o,\n      lowLatency: a\n    };\n  },\n  Dt = (e, t, r) => {\n    var c, d, u, s, p, l, T, m;\n    let {\n      streamType: n,\n      targetLiveWindow: o,\n      liveEdgeStartOffset: a,\n      lowLatency: i\n    } = Rt(e);\n    if (n === _.LIVE) {\n      i ? (r.config.backBufferLength = (c = r.userConfig.backBufferLength) != null ? c : 4, r.config.maxFragLookUpTolerance = (d = r.userConfig.maxFragLookUpTolerance) != null ? d : .001, r.config.abrBandWidthUpFactor = (u = r.userConfig.abrBandWidthUpFactor) != null ? u : r.config.abrBandWidthFactor) : r.config.backBufferLength = (s = r.userConfig.backBufferLength) != null ? s : 8;\n      let R = Object.freeze({\n        get length() {\n          return t.seekable.length;\n        },\n        start(M) {\n          return t.seekable.start(M);\n        },\n        end(M) {\n          var h;\n          return M > this.length || M < 0 || Number.isFinite(t.duration) ? t.seekable.end(M) : (h = r.liveSyncPosition) != null ? h : t.seekable.end(M);\n        }\n      });\n      ((p = P.get(t)) != null ? p : {}).seekable = R;\n    }\n    ((l = P.get(t)) != null ? l : {}).liveEdgeStartOffset = a, ((T = P.get(t)) != null ? T : {}).targetLiveWindow = o, t.dispatchEvent(new CustomEvent(\"targetlivewindowchange\", {\n      composed: !0,\n      bubbles: !0\n    })), ((m = P.get(t)) != null ? m : {}).streamType = n, t.dispatchEvent(new CustomEvent(\"streamtypechange\", {\n      composed: !0,\n      bubbles: !0\n    }));\n  },\n  Oe,\n  Ue,\n  bt = (Ue = (Oe = globalThis == null ? void 0 : globalThis.navigator) == null ? void 0 : Oe.userAgent) != null ? Ue : \"\",\n  He,\n  Ve,\n  Ke,\n  Ct = (Ke = (Ve = (He = globalThis == null ? void 0 : globalThis.navigator) == null ? void 0 : He.userAgentData) == null ? void 0 : Ve.platform) != null ? Ke : \"\",\n  vt = bt.toLowerCase().includes(\"android\") || [\"x11\", \"android\"].some(e => Ct.toLowerCase().includes(e)),\n  P = new WeakMap(),\n  I = \"mux.com\",\n  We,\n  Ye,\n  Fe = (Ye = (We = g).isSupported) == null ? void 0 : Ye.call(We),\n  Pt = vt,\n  Wr = () => ue.utils.now(),\n  _t = ue.utils.generateUUID,\n  Yr = function () {\n    let {\n      playbackId: e,\n      customDomain: t = I,\n      maxResolution: r,\n      minResolution: n,\n      renditionOrder: o,\n      programStartTime: a,\n      programEndTime: i,\n      assetStartTime: c,\n      assetEndTime: d,\n      playbackToken: u,\n      tokens: {\n        playback: s = u\n      } = {},\n      extraSourceParams: p = {}\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!e) return;\n    let [l, T = \"\"] = F(e),\n      m = new URL(`https://stream.${t}/${l}.m3u8${T}`);\n    return s || m.searchParams.has(\"token\") ? (m.searchParams.forEach((R, M) => {\n      M != \"token\" && m.searchParams.delete(M);\n    }), s && m.searchParams.set(\"token\", s)) : (r && m.searchParams.set(\"max_resolution\", r), n && (m.searchParams.set(\"min_resolution\", n), r && +r.slice(0, -1) < +n.slice(0, -1) && console.error(\"minResolution must be <= maxResolution\", \"minResolution\", n, \"maxResolution\", r)), o && m.searchParams.set(\"rendition_order\", o), a && m.searchParams.set(\"program_start_time\", `${a}`), i && m.searchParams.set(\"program_end_time\", `${i}`), c && m.searchParams.set(\"asset_start_time\", `${c}`), d && m.searchParams.set(\"asset_end_time\", `${d}`), Object.entries(p).forEach(_ref14 => {\n      let [R, M] = _ref14;\n      M != null && m.searchParams.set(R, M);\n    })), m.toString();\n  },\n  G = e => {\n    if (!e) return;\n    let [t] = e.split(\"?\");\n    return t || void 0;\n  },\n  $e = e => {\n    if (!e || !e.startsWith(\"https://stream.\")) return;\n    let [t] = new URL(e).pathname.slice(1).split(/\\.m3u8|\\//);\n    return t || void 0;\n  },\n  kt = e => {\n    var t, r, n;\n    return (t = e == null ? void 0 : e.metadata) != null && t.video_id ? e.metadata.video_id : Xe(e) && (n = (r = G(e.playbackId)) != null ? r : $e(e.src)) != null ? n : e.src;\n  },\n  ht = e => {\n    var t;\n    return (t = P.get(e)) == null ? void 0 : t.error;\n  },\n  Fr = e => {\n    var t;\n    return (t = P.get(e)) == null ? void 0 : t.metadata;\n  },\n  we = e => {\n    var t, r;\n    return (r = (t = P.get(e)) == null ? void 0 : t.streamType) != null ? r : _.UNKNOWN;\n  },\n  $r = e => {\n    var t, r;\n    return (r = (t = P.get(e)) == null ? void 0 : t.targetLiveWindow) != null ? r : Number.NaN;\n  },\n  Be = e => {\n    var t, r;\n    return (r = (t = P.get(e)) == null ? void 0 : t.seekable) != null ? r : e.seekable;\n  },\n  Br = e => {\n    var n;\n    let t = (n = P.get(e)) == null ? void 0 : n.liveEdgeStartOffset;\n    if (typeof t != \"number\") return Number.NaN;\n    let r = Be(e);\n    return r.length ? r.end(r.length - 1) - t : Number.NaN;\n  },\n  le = .034,\n  Lt = function (e, t) {\n    let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : le;\n    return Math.abs(e - t) <= r;\n  },\n  je = function (e, t) {\n    let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : le;\n    return e > t || Lt(e, t, r);\n  },\n  Nt = function (e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : le;\n    return e.paused && je(e.currentTime, e.duration, t);\n  },\n  Je = (e, t) => {\n    var u, s, p;\n    if (!t || !e.buffered.length) return;\n    if (e.readyState > 2) return !1;\n    let r = t.currentLevel >= 0 ? (s = (u = t.levels) == null ? void 0 : u[t.currentLevel]) == null ? void 0 : s.details : (p = t.levels.find(l => !!l.details)) == null ? void 0 : p.details;\n    if (!r || r.live) return;\n    let {\n      fragments: n\n    } = r;\n    if (!(n != null && n.length)) return;\n    if (e.currentTime < e.duration - (r.targetduration + .5)) return !1;\n    let o = n[n.length - 1];\n    if (e.currentTime <= o.start) return !1;\n    let a = o.start + o.duration / 2,\n      i = e.buffered.start(e.buffered.length - 1),\n      c = e.buffered.end(e.buffered.length - 1);\n    return a > i && a < c;\n  },\n  At = (e, t) => e.ended || e.loop ? e.ended : t && Je(e, t) ? !0 : Nt(e),\n  jr = (e, t, r) => {\n    It(t, r, e);\n    let {\n        metadata: n = {}\n      } = e,\n      {\n        view_session_id: o = _t()\n      } = n,\n      a = kt(e);\n    n.view_session_id = o, n.video_id = a, e.metadata = n;\n    let i = s => {\n      var p;\n      (p = t.mux) == null || p.emit(\"hb\", {\n        view_drm_type: s\n      });\n    };\n    e.drmTypeCb = i, P.set(t, {\n      retryCount: 0\n    });\n    let c = St(e, t),\n      d = Re(e, t, c);\n    e != null && e.muxDataKeepSession && t != null && t.mux && !t.mux.deleted ? c && t.mux.addHLSJS({\n      hlsjs: c,\n      Hls: c ? g : void 0\n    }) : Kt(e, t, c), Wt(e, t, c), ke(t), Ae(t);\n    let u = xe(e, t, c);\n    return {\n      engine: c,\n      setAutoplay: u,\n      setPreload: d\n    };\n  },\n  It = (e, t, r) => {\n    let n = t == null ? void 0 : t.engine;\n    e != null && e.mux && !e.mux.deleted && (r != null && r.muxDataKeepSession ? n && e.mux.removeHLSJS() : (e.mux.destroy(), delete e.mux)), n && (n.detachMedia(), n.destroy()), e && (e.hasAttribute(\"src\") && (e.removeAttribute(\"src\"), e.load()), e.removeEventListener(\"error\", Qe), e.removeEventListener(\"error\", ce), e.removeEventListener(\"durationchange\", ze), P.delete(e), e.dispatchEvent(new Event(\"teardown\")));\n  };\nfunction qe(e, t) {\n  var u;\n  let r = U(e);\n  if (!(r === A.M3U8)) return !0;\n  let o = !r || ((u = t.canPlayType(r)) != null ? u : !0),\n    {\n      preferPlayback: a\n    } = e,\n    i = a === X.MSE,\n    c = a === X.NATIVE;\n  return o && (c || !(Fe && (i || Pt)));\n}\nvar St = (e, t) => {\n    let {\n        debug: r,\n        streamType: n,\n        startTime: o = -1,\n        metadata: a,\n        preferCmcd: i,\n        _hlsConfig: c = {}\n      } = e,\n      u = U(e) === A.M3U8,\n      s = qe(e, t);\n    if (u && !s && Fe) {\n      let p = {\n          backBufferLength: 30,\n          renderTextTracksNatively: !1,\n          liveDurationInfinity: !0,\n          capLevelToPlayerSize: !0,\n          capLevelOnFPSDrop: !0\n        },\n        l = wt(n),\n        T = Ot(e),\n        m = [S.QUERY, S.HEADER].includes(i) ? {\n          useHeaders: i === S.HEADER,\n          sessionId: a == null ? void 0 : a.view_session_id,\n          contentId: a == null ? void 0 : a.video_id\n        } : void 0,\n        R = new g({\n          debug: r,\n          startPosition: o,\n          cmcd: m,\n          xhrSetup: (M, h) => {\n            var y, k;\n            if (i && i !== S.QUERY) return;\n            let E = new URL(h);\n            if (!E.searchParams.has(\"CMCD\")) return;\n            let b = ((k = (y = E.searchParams.get(\"CMCD\")) == null ? void 0 : y.split(\",\")) != null ? k : []).filter(pe => pe.startsWith(\"sid\") || pe.startsWith(\"cid\")).join(\",\");\n            E.searchParams.set(\"CMCD\", b), M.open(\"GET\", E);\n          },\n          capLevelController: Se,\n          ...p,\n          ...l,\n          ...T,\n          ...c\n        });\n      return R.on(g.Events.MANIFEST_PARSED, async function (M, h) {\n        var b, y;\n        let E = (b = h.sessionData) == null ? void 0 : b[\"com.apple.hls.chapters\"];\n        (E != null && E.URI || E != null && E.VALUE.toLocaleLowerCase().startsWith(\"http\")) && de((y = E == null ? void 0 : E.URI) != null ? y : E == null ? void 0 : E.VALUE, t);\n      }), R;\n    }\n  },\n  wt = e => e === _.LIVE ? {\n    backBufferLength: 8\n  } : {},\n  Ot = e => {\n    let {\n        tokens: {\n          drm: t\n        } = {},\n        playbackId: r,\n        drmTypeCb: n\n      } = e,\n      o = G(r);\n    return !t || !o ? {} : {\n      emeEnabled: !0,\n      drmSystems: {\n        \"com.apple.fps\": {\n          licenseUrl: q(e, \"fairplay\"),\n          serverCertificateUrl: Ge(e, \"fairplay\")\n        },\n        \"com.widevine.alpha\": {\n          licenseUrl: q(e, \"widevine\")\n        },\n        \"com.microsoft.playready\": {\n          licenseUrl: q(e, \"playready\")\n        }\n      },\n      requestMediaKeySystemAccessFunc: (a, i) => (a === \"com.widevine.alpha\" && (i = [...i.map(c => {\n        var u;\n        let d = (u = c.videoCapabilities) == null ? void 0 : u.map(s => ({\n          ...s,\n          robustness: \"HW_SECURE_ALL\"\n        }));\n        return {\n          ...c,\n          videoCapabilities: d\n        };\n      }), ...i]), navigator.requestMediaKeySystemAccess(a, i).then(c => {\n        let d = ft(a);\n        return n == null || n(d), c;\n      }))\n    };\n  },\n  Ut = async e => {\n    let t = await fetch(e);\n    return t.status !== 200 ? Promise.reject(t) : await t.arrayBuffer();\n  },\n  Ht = async (e, t) => {\n    let r = await fetch(t, {\n      method: \"POST\",\n      headers: {\n        \"Content-type\": \"application/octet-stream\"\n      },\n      body: e\n    });\n    if (r.status !== 200) return Promise.reject(r);\n    let n = await r.arrayBuffer();\n    return new Uint8Array(n);\n  },\n  Vt = (e, t) => {\n    v(t, \"encrypted\", async n => {\n      try {\n        let o = n.initDataType;\n        if (o !== \"skd\") {\n          console.error(`Received unexpected initialization data type \"${o}\"`);\n          return;\n        }\n        if (!t.mediaKeys) {\n          let u = await navigator.requestMediaKeySystemAccess(\"com.apple.fps\", [{\n            initDataTypes: [o],\n            videoCapabilities: [{\n              contentType: \"application/vnd.apple.mpegurl\",\n              robustness: \"\"\n            }],\n            distinctiveIdentifier: \"not-allowed\",\n            persistentState: \"not-allowed\",\n            sessionTypes: [\"temporary\"]\n          }]).then(p => {\n            var l;\n            return (l = e.drmTypeCb) == null || l.call(e, J.FAIRPLAY), p;\n          }).catch(() => {\n            let p = x(\"Cannot play DRM-protected content with current security configuration on this browser. Try playing in another browser.\"),\n              l = new f(p, f.MEDIA_ERR_ENCRYPTED, !0);\n            l.errorCategory = C.DRM, l.muxCode = D.ENCRYPTED_UNSUPPORTED_KEY_SYSTEM, N(t, l);\n          });\n          if (!u) return;\n          let s = await u.createMediaKeys();\n          try {\n            let p = await Ut(Ge(e, \"fairplay\")).catch(l => {\n              if (l instanceof Response) {\n                let T = H(l, C.DRM, e);\n                return console.error(\"mediaError\", T == null ? void 0 : T.message, T == null ? void 0 : T.context), T ? Promise.reject(T) : Promise.reject(new Error(\"Unexpected error in app cert request\"));\n              }\n              return Promise.reject(l);\n            });\n            await s.setServerCertificate(p).catch(() => {\n              let l = x(\"Your server certificate failed when attempting to set it. This may be an issue with a no longer valid certificate.\"),\n                T = new f(l, f.MEDIA_ERR_ENCRYPTED, !0);\n              return T.errorCategory = C.DRM, T.muxCode = D.ENCRYPTED_UPDATE_SERVER_CERT_FAILED, Promise.reject(T);\n            });\n          } catch (p) {\n            N(t, p);\n            return;\n          }\n          await t.setMediaKeys(s);\n        }\n        let a = n.initData;\n        if (a == null) {\n          console.error(`Could not start encrypted playback due to missing initData in ${n.type} event`);\n          return;\n        }\n        let i = t.mediaKeys.createSession();\n        i.addEventListener(\"keystatuseschange\", () => {\n          i.keyStatuses.forEach(u => {\n            let s;\n            if (u === \"internal-error\") {\n              let p = x(\"The DRM Content Decryption Module system had an internal failure. Try reloading the page, upading your browser, or playing in another browser.\");\n              s = new f(p, f.MEDIA_ERR_ENCRYPTED, !0), s.errorCategory = C.DRM, s.muxCode = D.ENCRYPTED_CDM_ERROR;\n            } else if (u === \"output-restricted\" || u === \"output-downscaled\") {\n              let p = x(\"DRM playback is being attempted in an environment that is not sufficiently secure. User may see black screen.\");\n              s = new f(p, f.MEDIA_ERR_ENCRYPTED, !1), s.errorCategory = C.DRM, s.muxCode = D.ENCRYPTED_OUTPUT_RESTRICTED;\n            }\n            s && N(t, s);\n          });\n        });\n        let c = await Promise.all([i.generateRequest(o, a).catch(() => {\n            let u = x(\"Failed to generate a DRM license request. This may be an issue with the player or your protected content.\"),\n              s = new f(u, f.MEDIA_ERR_ENCRYPTED, !0);\n            s.errorCategory = C.DRM, s.muxCode = D.ENCRYPTED_GENERATE_REQUEST_FAILED, N(t, s);\n          }), new Promise(u => {\n            i.addEventListener(\"message\", s => {\n              u(s.message);\n            }, {\n              once: !0\n            });\n          })]).then(_ref15 => {\n            let [, u] = _ref15;\n            return u;\n          }),\n          d = await Ht(c, q(e, \"fairplay\")).catch(u => {\n            if (u instanceof Response) {\n              let s = H(u, C.DRM, e);\n              return console.error(\"mediaError\", s == null ? void 0 : s.message, s == null ? void 0 : s.context), s ? Promise.reject(s) : Promise.reject(new Error(\"Unexpected error in license key request\"));\n            }\n            return Promise.reject(u);\n          });\n        await i.update(d).catch(() => {\n          let u = x(\"Failed to update DRM license. This may be an issue with the player or your protected content.\"),\n            s = new f(u, f.MEDIA_ERR_ENCRYPTED, !0);\n          return s.errorCategory = C.DRM, s.muxCode = D.ENCRYPTED_UPDATE_LICENSE_FAILED, Promise.reject(s);\n        });\n      } catch (o) {\n        N(t, o);\n        return;\n      }\n    });\n  },\n  q = (_ref16, n) => {\n    let {\n      playbackId: e,\n      tokens: {\n        drm: t\n      } = {},\n      customDomain: r = I\n    } = _ref16;\n    let o = G(e);\n    return `https://license.${r.toLocaleLowerCase().endsWith(I) ? r : I}/license/${n}/${o}?token=${t}`;\n  },\n  Ge = (_ref17, n) => {\n    let {\n      playbackId: e,\n      tokens: {\n        drm: t\n      } = {},\n      customDomain: r = I\n    } = _ref17;\n    let o = G(e);\n    return `https://license.${r.toLocaleLowerCase().endsWith(I) ? r : I}/appcert/${n}/${o}?token=${t}`;\n  },\n  Xe = _ref18 => {\n    let {\n      playbackId: e,\n      src: t,\n      customDomain: r\n    } = _ref18;\n    if (e) return !0;\n    if (typeof t != \"string\") return !1;\n    let n = window == null ? void 0 : window.location.href,\n      o = new URL(t, n).hostname.toLocaleLowerCase();\n    return o.includes(I) || !!r && o.includes(r.toLocaleLowerCase());\n  },\n  Kt = (e, t, r) => {\n    var d;\n    let {\n        envKey: n,\n        disableTracking: o,\n        muxDataSDK: a = ue,\n        muxDataSDKOptions: i = {}\n      } = e,\n      c = Xe(e);\n    if (!o && (n || c)) {\n      let {\n          playerInitTime: u,\n          playerSoftwareName: s,\n          playerSoftwareVersion: p,\n          beaconCollectionDomain: l,\n          debug: T,\n          disableCookies: m\n        } = e,\n        R = {\n          ...e.metadata,\n          video_title: ((d = e == null ? void 0 : e.metadata) == null ? void 0 : d.video_title) || void 0\n        },\n        M = h => typeof h.player_error_code == \"string\" ? !1 : typeof e.errorTranslator == \"function\" ? e.errorTranslator(h) : h;\n      a.monitor(t, {\n        debug: T,\n        beaconCollectionDomain: l,\n        hlsjs: r,\n        Hls: r ? g : void 0,\n        automaticErrorTracking: !1,\n        errorTranslator: M,\n        disableCookies: m,\n        ...i,\n        data: {\n          ...(n ? {\n            env_key: n\n          } : {}),\n          player_software_name: s,\n          player_software: s,\n          player_software_version: p,\n          player_init_time: u,\n          ...R\n        }\n      });\n    }\n  },\n  Wt = (e, t, r) => {\n    var s, p;\n    let n = qe(e, t),\n      {\n        src: o,\n        customDomain: a = I\n      } = e,\n      i = () => {\n        t.ended || !At(t, r) || (Je(t, r) ? t.currentTime = t.buffered.end(t.buffered.length - 1) : t.dispatchEvent(new Event(\"ended\")));\n      },\n      c,\n      d,\n      u = () => {\n        let l = Be(t),\n          T,\n          m;\n        l.length > 0 && (T = l.start(0), m = l.end(0)), (d !== m || c !== T) && t.dispatchEvent(new CustomEvent(\"seekablechange\", {\n          composed: !0\n        })), c = T, d = m;\n      };\n    if (v(t, \"durationchange\", u), t && n) {\n      let l = U(e);\n      if (typeof o == \"string\") {\n        if (o.endsWith(\".mp4\") && o.includes(a)) {\n          let R = $e(o),\n            M = new URL(`https://stream.${a}/${R}/metadata.json`);\n          de(M.toString(), t);\n        }\n        let T = () => {\n            if (we(t) !== _.LIVE || Number.isFinite(t.duration)) return;\n            let R = setInterval(u, 1e3);\n            t.addEventListener(\"teardown\", () => {\n              clearInterval(R);\n            }, {\n              once: !0\n            }), v(t, \"durationchange\", () => {\n              Number.isFinite(t.duration) && clearInterval(R);\n            });\n          },\n          m = async () => xt(o, t, l).then(T).catch(R => {\n            if (R instanceof Response) {\n              let M = H(R, C.VIDEO, e);\n              if (M) {\n                N(t, M);\n                return;\n              }\n            } else R instanceof Error;\n          });\n        if (t.preload === \"none\") {\n          let R = () => {\n              m(), t.removeEventListener(\"loadedmetadata\", M);\n            },\n            M = () => {\n              m(), t.removeEventListener(\"play\", R);\n            };\n          v(t, \"play\", R, {\n            once: !0\n          }), v(t, \"loadedmetadata\", M, {\n            once: !0\n          });\n        } else m();\n        (s = e.tokens) != null && s.drm ? Vt(e, t) : v(t, \"encrypted\", () => {\n          let R = x(\"Attempting to play DRM-protected content without providing a DRM token.\"),\n            M = new f(R, f.MEDIA_ERR_ENCRYPTED, !0);\n          M.errorCategory = C.DRM, M.muxCode = D.ENCRYPTED_MISSING_TOKEN, N(t, M);\n        }, {\n          once: !0\n        }), t.setAttribute(\"src\", o), e.startTime && (((p = P.get(t)) != null ? p : {}).startTime = e.startTime, t.addEventListener(\"durationchange\", ze, {\n          once: !0\n        }));\n      } else t.removeAttribute(\"src\");\n      t.addEventListener(\"error\", Qe), t.addEventListener(\"error\", ce), t.addEventListener(\"emptied\", () => {\n        t.querySelectorAll(\"track[data-removeondestroy]\").forEach(m => {\n          m.remove();\n        });\n      }, {\n        once: !0\n      }), v(t, \"pause\", i), v(t, \"seeked\", i), v(t, \"play\", () => {\n        t.ended || je(t.currentTime, t.duration) && (t.currentTime = t.seekable.length ? t.seekable.start(0) : 0);\n      });\n    } else r && o ? (r.once(g.Events.LEVEL_LOADED, (l, T) => {\n      Dt(T.details, t, r), u(), we(t) === _.LIVE && !Number.isFinite(t.duration) && (r.on(g.Events.LEVEL_UPDATED, u), v(t, \"durationchange\", () => {\n        Number.isFinite(t.duration) && r.off(g.Events.LEVELS_UPDATED, u);\n      }));\n    }), r.on(g.Events.ERROR, (l, T) => {\n      var R, M;\n      let m = Yt(T, e);\n      if (m.muxCode === D.NETWORK_NOT_READY) {\n        let E = (R = P.get(t)) != null ? R : {},\n          b = (M = E.retryCount) != null ? M : 0;\n        if (b < 6) {\n          let y = b === 0 ? 5e3 : 6e4,\n            k = new f(`Retrying in ${y / 1e3} seconds...`, m.code, m.fatal);\n          Object.assign(k, m), N(t, k), setTimeout(() => {\n            E.retryCount = b + 1, T.details === \"manifestLoadError\" && T.url && r.loadSource(T.url);\n          }, y);\n          return;\n        } else {\n          E.retryCount = 0;\n          let y = new f('Try again later or <a href=\"#\" onclick=\"window.location.reload(); return false;\" style=\"color: #4a90e2;\">click here to retry</a>', m.code, m.fatal);\n          Object.assign(y, m), N(t, y);\n          return;\n        }\n      }\n      N(t, m);\n    }), r.on(g.Events.MANIFEST_LOADED, () => {\n      let l = P.get(t);\n      l && l.error && (l.error = null, l.retryCount = 0, t.dispatchEvent(new Event(\"emptied\")), t.dispatchEvent(new Event(\"loadstart\")));\n    }), t.addEventListener(\"error\", ce), v(t, \"waiting\", i), De(e, r), be(t, r), r.attachMedia(t)) : console.error(\"It looks like the video you're trying to play will not work on this system! If possible, try upgrading to the newest versions of your browser or software.\");\n  };\nfunction ze(e) {\n  var n;\n  let t = e.target,\n    r = (n = P.get(t)) == null ? void 0 : n.startTime;\n  if (r && fe(t.seekable, t.duration, r)) {\n    let o = t.preload === \"auto\";\n    o && (t.preload = \"none\"), t.currentTime = r, o && (t.preload = \"auto\");\n  }\n}\nasync function Qe(e) {\n  if (!e.isTrusted) return;\n  e.stopImmediatePropagation();\n  let t = e.target;\n  if (!(t != null && t.error)) return;\n  let {\n      message: r,\n      code: n\n    } = t.error,\n    o = new f(r, n);\n  if (t.src && n === f.MEDIA_ERR_SRC_NOT_SUPPORTED && t.readyState === HTMLMediaElement.HAVE_NOTHING) {\n    setTimeout(() => {\n      var i;\n      let a = (i = ht(t)) != null ? i : t.error;\n      (a == null ? void 0 : a.code) === f.MEDIA_ERR_SRC_NOT_SUPPORTED && N(t, o);\n    }, 500);\n    return;\n  }\n  if (t.src && (n !== f.MEDIA_ERR_DECODE || n !== void 0)) try {\n    let {\n      status: a\n    } = await fetch(t.src);\n    o.data = {\n      response: {\n        code: a\n      }\n    };\n  } catch {}\n  N(t, o);\n}\nfunction N(e, t) {\n  var r;\n  t.fatal && (((r = P.get(e)) != null ? r : {}).error = t, e.dispatchEvent(new CustomEvent(\"error\", {\n    detail: t\n  })));\n}\nfunction ce(e) {\n  var n, o;\n  if (!(e instanceof CustomEvent) || !(e.detail instanceof f)) return;\n  let t = e.target,\n    r = e.detail;\n  !r || !r.fatal || (((n = P.get(t)) != null ? n : {}).error = r, (o = t.mux) == null || o.emit(\"error\", {\n    player_error_code: r.code,\n    player_error_message: r.message,\n    player_error_context: r.context\n  }));\n}\nvar Yt = (e, t) => {\n  var c, d, u;\n  console.error(\"getErrorFromHlsErrorData()\", e);\n  let r = {\n      [g.ErrorTypes.NETWORK_ERROR]: f.MEDIA_ERR_NETWORK,\n      [g.ErrorTypes.MEDIA_ERROR]: f.MEDIA_ERR_DECODE,\n      [g.ErrorTypes.KEY_SYSTEM_ERROR]: f.MEDIA_ERR_ENCRYPTED\n    },\n    n = s => [g.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED, g.ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED].includes(s.details) ? f.MEDIA_ERR_NETWORK : r[s.type],\n    o = s => {\n      if (s.type === g.ErrorTypes.KEY_SYSTEM_ERROR) return C.DRM;\n      if (s.type === g.ErrorTypes.NETWORK_ERROR) return C.VIDEO;\n    },\n    a,\n    i = n(e);\n  if (i === f.MEDIA_ERR_NETWORK && e.response) {\n    let s = (c = o(e)) != null ? c : C.VIDEO;\n    a = (d = H(e.response, s, t, e.fatal)) != null ? d : new f(\"\", i, e.fatal);\n  } else if (i === f.MEDIA_ERR_ENCRYPTED) {\n    if (e.details === g.ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE) {\n      let s = x(\"Attempting to play DRM-protected content without providing a DRM token.\");\n      a = new f(s, f.MEDIA_ERR_ENCRYPTED, e.fatal), a.errorCategory = C.DRM, a.muxCode = D.ENCRYPTED_MISSING_TOKEN;\n    } else if (e.details === g.ErrorDetails.KEY_SYSTEM_NO_ACCESS) {\n      let s = x(\"Cannot play DRM-protected content with current security configuration on this browser. Try playing in another browser.\");\n      a = new f(s, f.MEDIA_ERR_ENCRYPTED, e.fatal), a.errorCategory = C.DRM, a.muxCode = D.ENCRYPTED_UNSUPPORTED_KEY_SYSTEM;\n    } else if (e.details === g.ErrorDetails.KEY_SYSTEM_NO_SESSION) {\n      let s = x(\"Failed to generate a DRM license request. This may be an issue with the player or your protected content.\");\n      a = new f(s, f.MEDIA_ERR_ENCRYPTED, !0), a.errorCategory = C.DRM, a.muxCode = D.ENCRYPTED_GENERATE_REQUEST_FAILED;\n    } else if (e.details === g.ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED) {\n      let s = x(\"Failed to update DRM license. This may be an issue with the player or your protected content.\");\n      a = new f(s, f.MEDIA_ERR_ENCRYPTED, e.fatal), a.errorCategory = C.DRM, a.muxCode = D.ENCRYPTED_UPDATE_LICENSE_FAILED;\n    } else if (e.details === g.ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED) {\n      let s = x(\"Your server certificate failed when attempting to set it. This may be an issue with a no longer valid certificate.\");\n      a = new f(s, f.MEDIA_ERR_ENCRYPTED, e.fatal), a.errorCategory = C.DRM, a.muxCode = D.ENCRYPTED_UPDATE_SERVER_CERT_FAILED;\n    } else if (e.details === g.ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR) {\n      let s = x(\"The DRM Content Decryption Module system had an internal failure. Try reloading the page, upading your browser, or playing in another browser.\");\n      a = new f(s, f.MEDIA_ERR_ENCRYPTED, e.fatal), a.errorCategory = C.DRM, a.muxCode = D.ENCRYPTED_CDM_ERROR;\n    } else if (e.details === g.ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED) {\n      let s = x(\"DRM playback is being attempted in an environment that is not sufficiently secure. User may see black screen.\");\n      a = new f(s, f.MEDIA_ERR_ENCRYPTED, !1), a.errorCategory = C.DRM, a.muxCode = D.ENCRYPTED_OUTPUT_RESTRICTED;\n    } else a = new f(e.error.message, f.MEDIA_ERR_ENCRYPTED, e.fatal), a.errorCategory = C.DRM, a.muxCode = D.ENCRYPTED_ERROR;\n  } else a = new f(\"\", i, e.fatal);\n  return a.context || (a.context = `${e.url ? `url: ${e.url}\n` : \"\"}${e.response && (e.response.code || e.response.text) ? `response: ${e.response.code}, ${e.response.text}\n` : \"\"}${e.reason ? `failure reason: ${e.reason}\n` : \"\"}${e.level ? `level: ${e.level}\n` : \"\"}${e.parent ? `parent stream controller: ${e.parent}\n` : \"\"}${e.buffer ? `buffer length: ${e.buffer}\n` : \"\"}${e.error ? `error: ${e.error}\n` : \"\"}${e.event ? `event: ${e.event}\n` : \"\"}${e.err ? `error message: ${(u = e.err) == null ? void 0 : u.message}\n` : \"\"}`), a.data = e, a;\n};\nexport { K as AutoplayTypes, jt as CmcdTypeValues, S as CmcdTypes, A as ExtensionMimeTypeMap, g as Hls, Gt as MaxResolution, f as MediaError, W as MimeTypeShorthandMap, Xt as MinResolution, C as MuxErrorCategory, D as MuxErrorCode, se as MuxJWTAud, X as PlaybackTypes, zt as RenditionOrder, _ as StreamTypes, Le as addChapters, Pe as addCuePoints, ne as addTextTrack, qt as allMediaTypes, V as errorCategoryToTokenNameOrPrefix, de as fetchAndDispatchMuxMetadata, Wr as generatePlayerInitTime, _t as generateUUID, Ne as getActiveChapter, _e as getActiveCuePoint, Ut as getAppCertificate, ct as getChapters, it as getCuePoints, dt as getCurrentPdt, Ot as getDRMConfig, At as getEnded, ht as getError, Ht as getLicenseKey, Br as getLiveEdgeStart, Tt as getMediaPlaylistFromMultivariantPlaylist, Fr as getMetadata, yt as getMultivariantPlaylistSessionData, Be as getSeekable, ut as getStartDate, Rt as getStreamInfoFromHlsjsLevelDetails, gt as getStreamInfoFromPlaylist, Mt as getStreamInfoFromSrcAndType, we as getStreamType, wt as getStreamTypeConfig, $r as getTargetLiveWindow, w as getTextTrack, x as i18n, jr as initialize, O as isKeyOf, Xe as isMuxVideoSrc, Nt as isPseudoEnded, Je as isStuckOnLastFragment, Wt as loadMedia, ue as mux, P as muxMediaState, ee as parseJwt, Et as parseTagAttributes, st as removeTextTrack, Ae as setupChapters, ke as setupCuePoints, St as setupHls, Kt as setupMux, Vt as setupNativeFairplayDRM, Jt as shorthandKeys, It as teardown, Ge as toAppCertURL, ft as toDRMTypeFromKeySystem, q as toLicenseKeyURL, Yr as toMuxVideoURL, $e as toPlaybackIdFromSrc, F as toPlaybackIdParts, Dt as updateStreamInfoFromHlsjsLevelDetails, xt as updateStreamInfoFromSrc };","map":{"version":3,"mappings":"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","names":["mux","Hls","hls_default","MuxErrorCategory","VIDEO","THUMBNAIL","STORYBOARD","DRM","MuxErrorCode","NOT_AN_ERROR","NETWORK_OFFLINE","NETWORK_UNKNOWN_ERROR","NETWORK_NO_STATUS","NETWORK_INVALID_URL","NETWORK_NOT_FOUND","NETWORK_NOT_READY","NETWORK_GENERIC_SERVER_FAIL","NETWORK_TOKEN_MISSING","NETWORK_TOKEN_MALFORMED","NETWORK_TOKEN_EXPIRED","NETWORK_TOKEN_AUD_MISSING","NETWORK_TOKEN_AUD_MISMATCH","NETWORK_TOKEN_SUB_MISMATCH","ENCRYPTED_ERROR","ENCRYPTED_UNSUPPORTED_KEY_SYSTEM","ENCRYPTED_GENERATE_REQUEST_FAILED","ENCRYPTED_UPDATE_LICENSE_FAILED","ENCRYPTED_UPDATE_SERVER_CERT_FAILED","ENCRYPTED_CDM_ERROR","ENCRYPTED_OUTPUT_RESTRICTED","ENCRYPTED_MISSING_TOKEN","errorCategoryToTokenNameOrPrefix","category","_MediaError","Error","constructor","message","code","MEDIA_ERR_CUSTOM","fatal","context","name","MEDIA_ERR_NETWORK","MEDIA_ERR_ENCRYPTED","_a","defaultMessages","MEDIA_ERR_ABORTED","MEDIA_ERR_DECODE","MEDIA_ERR_SRC_NOT_SUPPORTED","MediaError","isNil","x","isKeyOf","O","k","o","AutoplayTypes","ANY","MUTED","StreamTypes","ON_DEMAND","LIVE","UNKNOWN","PlaybackTypes","MSE","NATIVE","CmcdTypes","HEADER","QUERY","NONE","CmcdTypeValues","Object","values","ExtensionMimeTypeMap","M3U8","MP4","MimeTypeShorthandMap","HLS","shorthandKeys","keys","allMediaTypes","MaxResolution","upTo720p","upTo1080p","upTo1440p","upTo2160p","MinResolution","noLessThan480p","noLessThan540p","noLessThan720p","noLessThan1080p","noLessThan1440p","noLessThan2160p","RenditionOrder","DESCENDING","en_default","addEventListenerWithTeardown","mediaEl","type","listener","options","target","addEventListener","removeEventListener","once","inSeekableRange","seekable","duration","time","i","length","start","end","toPlaybackIdParts","playbackIdWithOptionalParams","qIndex","indexOf","idPart","slice","queryPart","getType","props","upperType","toUpperCase","inferMimeTypeFromURL","toStreamTypeFromPlaylistType","playlistType","toTargetLiveWindowFromPlaylistType","Number","POSITIVE_INFINITY","NaN","src","pathname","URL","console","error","extDelimIdx","lastIndexOf","isExtensionLessMuxM3U8URL","upperExt","MUX_VIDEO_DOMAIN","_ref","customDomain","urlObj","validProtocol","protocol","validHostname","hostname","toLowerCase","pathParts","split","validPathPartsLength","validExtensionlessPath","includes","parseJwt","token","base64Url","base64","replace","jsonPayload","decodeURIComponent","atob","map","c","charCodeAt","toString","join","JSON","parse","isJWTExpired","exp","referenceTime","Date","now","isJWTSubMismatch","ye","expectedSub","sub","isJWTAudMissing","me","_expectedAud","aud","isJWTAudMismatch","Ee","expectedAud","DEFAULT_LOCALE","i18n","str","translate","_b","locale","IntlMessageFormat","format","_match","key","AutoplayTypeValues","isAutoplayValue","value","setupAutoplay","xe","hls","autoplay","maybeAutoplay","hasPlayed","isLive","updateHasPlayed","handleAutoplay","streamType","isFinite","Events","LEVEL_LOADED","_event","data","details","live","handleSeek","u","startTime","liveSyncPosition","currentTime","preload","LEVEL_UPDATED","newAutoplay","te","oldMuted","muted","restoreMuted","n","play","catch","setupPreload","Re","updatePreload","val","setAttribute","removeAttribute","hasLoadedSource","hasPlayFired","originalLength","config","maxBufferLength","originalSize","maxBufferSize","updateHlsPreload","newPreload","safeLoadSource","s","loadSource","setupMediaTracks","customMediaEl","levelIdMap","WeakMap","on","MANIFEST_PARSED","removeAllMediaTracks","videoTrack","addVideoTrack","selected","id","level","levels","entries","videoRendition","addRendition","url","width","height","videoCodec","bitrate","set","AUDIO_TRACKS_UPDATED","removeAudioTracks","a","audioTracks","kind","default","audioTrack","addAudioTrack","lang","enabled","audioTrackId","find","t","availableIds","LEVELS_UPDATED","videoTracks","selectedIndex","levelIds","l","get","rendition","videoRenditions","removeRendition","switchRendition","event","nextLevel","removeVideoTracks","removeVideoTrack","removeAudioTrack","DESTROYING","cuePointStart","cuePoint","setupTextTracks","NON_NATIVE_TEXT_TRACKS_FOUND","_type","tracks","forEach","trackObj","baseTrackObj","subtitleTrack","closedCaptions","idx","subtitleTracks","findIndex","_ref8","label","_id","addTextTrack","changeHandler","r","showingTrack","Array","from","textTracks","textTrack","mode","currentHlsTrack","hlsTrackId","_ref9","defaultTrack","language","cues","cue","addCue","CUES_PARSED","track","getTrackById","disabled","getCueById","querySelectorAll","trackEl","remove","forceHiddenTracks","selector","querySelector","getAttribute","setTimeout","MANIFEST_LOADED","MEDIA_ATTACHED","document","createElement","srclang","append","removeTextTrack","trackElement","prototype","call","getTextTrack","addCuesToTextTrack","Promise","resolve","sort","cuePointA","cuePointB","endTime","VTTCue","stringify","cueAfterIndex","cueAfter","MAX_SAFE_INTEGER","previousCue","dispatchEvent","Event","bubbles","composed","DEFAULT_CUEPOINTS_TRACK_LABEL","DefaultCuePointsConfig","freeze","addCuePoints","cuePoints","cuePointsConfig","toCuePoint","text","getCuePoints","getActiveCuePoint","activeCues","actualActiveCue","_ref11","setupCuePoints","activeCuePoint","evt","CustomEvent","detail","DEFAULT_CHAPTERS_TRACK_LABEL","DefaultChaptersConfig","vttCueToChapter","addChapters","chapters","chaptersConfig","getChapters","getActiveChapter","_ref12","setupChapters","getStartDate","playingDate","getTime","getCurrentPdt","startDate","MuxJWTAud","categoryToAud","categoryToToken","pt","muxMediaEl","nameOrPrefix","tokenName","tokens","getErrorFromResponse","resp","offline","navigator","onLine","mediaErrorCode","mediaError","errorCategory","muxCode","status","requestTime","tokenNamePrefix","playbackId","jwtObj","dateOptions","timeStyle","dateStyle","expiredDate","Intl","DateTimeFormat","currentDate","tokenPlaybackId","CapLevelController","DefaultConfig","capLevelController","_MinCapLevelController","getValidLevels","capLevelIndex","filter","index","isLevelAllowed","getMaxLevel","baseMaxLevel","validLevels","baseMaxLevelResolution","Math","min","preferredMinMaxResolution","minMaxResolution","getMaxLevelByMediaSize","MinCapLevelController","min_cap_level_controller_default","DRMType","FAIRPLAY","PLAYREADY","WIDEVINE","toDRMTypeFromKeySystem","keySystem","getMediaPlaylistFromMultivariantPlaylist","multivariantPlaylist","mediaPlaylistUrl","_line","lines","startsWith","fetch","then","reject","getMultivariantPlaylistSessionData","playlist","sessionDataLines","line","sessionData","sessionDataAttrs","parseTagAttributes","dataId","ATTR_LIST_REGEX","matches","matchAll","fromEntries","_ref13","getStreamInfoFromPlaylist","playlistLines","trim","targetLiveWindow","liveEdgeStartOffset","partInfLine","targetDurationLine","targetDurationValue","_c","getStreamInfoFromSrcAndType","multivariantPlaylistResponse","ok","mediaPlaylist","updateStreamInfoFromSrc","metadata","URI","VALUE","toLocaleLowerCase","fetchAndDispatchMuxMetadata","_d","metadataUrl","statusText","json","item","eventUpdateMetadata","getStreamInfoFromHlsjsLevelDetails","levelDetails","lowLatency","partList","partTarget","targetduration","updateStreamInfoFromHlsjsLevelDetails","Dt","backBufferLength","userConfig","maxFragLookUpTolerance","abrBandWidthUpFactor","abrBandWidthFactor","_e","_f","_g","_h","userAgentStr","userAgent","userAgentPlatform","userAgentData","platform","isAndroidLike","some","platformStr","muxMediaState","MSE_SUPPORTED","isSupported","DEFAULT_PREFER_MSE","generatePlayerInitTime","Wr","utils","generateUUID","toMuxVideoURL","playbackIdWithParams","domain","maxResolution","minResolution","renditionOrder","programStartTime","programEndTime","assetStartTime","assetEndTime","playbackToken","playback","extraSourceParams","searchParams","has","_","delete","_ref14","v","toPlaybackIdFromParameterized","toPlaybackIdFromSrc","toVideoId","video_id","isMuxVideoSrc","getError","getMetadata","getStreamType","getTargetLiveWindow","getSeekable","getLiveEdgeStart","DEFAULT_ENDED_MOE","isApproximatelyEqual","y","moe","abs","isApproximatelyGTE","isPseudoEnded","paused","isStuckOnLastFragment","Je","buffered","readyState","videoLevelDetails","currentLevel","fragments","lastFragment","lastFragmentMidpoint","lastBufferedStart","lastBufferedEnd","getEnded","At","ended","loop","initialize","jr","core","teardown","view_session_id","drmTypeCb","drmType","emit","view_drm_type","retryCount","nextHlsInstance","setupHls","setPreload","muxDataKeepSession","deleted","addHLSJS","hlsjs","setupMux","loadMedia","setAutoplay","engine","It","removeHLSJS","destroy","detachMedia","hasAttribute","load","handleNativeError","handleInternalError","seekInSeekableRange","useNative","canUseNative","canPlayType","preferPlayback","preferMse","preferNative","St","debug","startPosition","preferCmcd","_hlsConfig","hlsType","shouldUseNative","defaultConfig","renderTextTracksNatively","liveDurationInfinity","capLevelToPlayerSize","capLevelOnFPSDrop","streamTypeConfig","getStreamTypeConfig","drmConfig","getDRMConfig","cmcd","useHeaders","sessionId","contentId","xhrSetup","xhr","cmcdVal","cmcdKVStr","open","drm","drmToken","emeEnabled","drmSystems","licenseUrl","toLicenseKeyURL","serverCertificateUrl","toAppCertURL","requestMediaKeySystemAccessFunc","supportedConfigurations","mediaKeySystemConfig","videoCapabilities","capability","robustness","requestMediaKeySystemAccess","getAppCertificate","appCertificateUrl","arrayBuffer","getLicenseKey","licenseServerUrl","method","headers","body","keyBuffer","Uint8Array","setupNativeFairplayDRM","Vt","initDataType","mediaKeys","access","initDataTypes","contentType","distinctiveIdentifier","persistentState","sessionTypes","saveAndDispatchError","createMediaKeys","fairPlayAppCert","errOrResp","Response","setServerCertificate","setMediaKeys","initData","session","createSession","keyStatuses","mediaKeyStatus","all","generateRequest","messageEvent","_ref15","messageEventMsg","response","update","q","scheme","endsWith","Ge","_ref18","base","window","location","href","Kt","envKey","env_key","disableTracking","muxDataSDK","muxDataSDKOptions","inferredEnv","playerInitTime","player_init_time","playerSoftwareName","player_software_name","playerSoftwareVersion","player_software_version","beaconCollectionDomain","disableCookies","video_title","muxEmbedErrorTranslator","player_error_code","errorTranslator","monitor","automaticErrorTracking","player_software","Wt","maybeDispatchEndedCallback","prevSeekableStart","prevSeekableEnd","seekableChange","seekableTimeRanges","nextSeekableStart","nextSeekableEnd","setupSeekableChangePoll","T","intervalId","setInterval","clearInterval","setupNativeStreamInfo","playHandler","R","loadedMetadataHandler","M","_evt","off","ERROR","getErrorFromHlsErrorData","state","retryDelay","retryDelayError","assign","retryLinkError","attachMedia","wasAuto","isTrusted","stopImmediatePropagation","HTMLMediaElement","HAVE_NOTHING","ourError","player_error_message","player_error_context","Yt","ErrorCodeMap","ErrorTypes","NETWORK_ERROR","MEDIA_ERROR","KEY_SYSTEM_ERROR","hlsErrorDataToErrorCode","ErrorDetails","KEY_SYSTEM_LICENSE_REQUEST_FAILED","KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED","hlsErrorDataToCategory","errorCode","KEY_SYSTEM_NO_CONFIGURED_LICENSE","KEY_SYSTEM_NO_ACCESS","KEY_SYSTEM_NO_SESSION","KEY_SYSTEM_SESSION_UPDATE_FAILED","KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED","KEY_SYSTEM_STATUS_INTERNAL_ERROR","KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED","reason","parent","buffer","err"],"sources":["/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/playback-core/src/index.ts","/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/playback-core/src/hls.ts","/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/playback-core/src/errors.ts","/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/playback-core/src/types.ts","/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/playback-core/lang/en.json","/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/playback-core/src/util.ts","/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/playback-core/src/autoplay.ts","/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/playback-core/src/preload.ts","/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/playback-core/src/media-tracks.ts","/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/playback-core/src/text-tracks.ts","/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/playback-core/src/pdt.ts","/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/playback-core/src/request-errors.ts","/Users/monawiebkeurban/Documents/portfolio/node_modules/@mux/playback-core/src/min-cap-level-controller.ts"],"sourcesContent":["import type { ValueOf, PlaybackCore, MuxMediaProps, MuxMediaPropsInternal, MuxMediaPropTypes } from './types';\nimport mux, { ErrorEvent } from 'mux-embed';\nimport Hls from './hls';\nimport type { HlsInterface } from './hls';\nimport type { ErrorData, HlsConfig } from 'hls.js';\nimport { MediaError, MuxErrorCategory, MuxErrorCode, errorCategoryToTokenNameOrPrefix } from './errors';\nimport { setupAutoplay } from './autoplay';\nimport { setupPreload } from './preload';\nimport { setupMediaTracks } from './media-tracks';\nimport {\n  setupTextTracks,\n  addTextTrack,\n  removeTextTrack,\n  getTextTrack,\n  addCuePoints,\n  getCuePoints,\n  getActiveCuePoint,\n  setupCuePoints,\n  addChapters,\n  getChapters,\n  getActiveChapter,\n  setupChapters,\n} from './text-tracks';\nimport { getStartDate, getCurrentPdt } from './pdt';\nimport {\n  inSeekableRange,\n  toPlaybackIdParts,\n  getType,\n  toStreamTypeFromPlaylistType,\n  toTargetLiveWindowFromPlaylistType,\n  addEventListenerWithTeardown,\n  i18n,\n  parseJwt,\n} from './util';\nimport { StreamTypes, PlaybackTypes, ExtensionMimeTypeMap, CmcdTypes, HlsPlaylistTypes, MediaTypes } from './types';\nimport { getErrorFromResponse, MuxJWTAud } from './request-errors';\nimport MinCapLevelController from './min-cap-level-controller';\n// import { MediaKeySessionContext } from 'hls.js';\nexport {\n  mux,\n  Hls,\n  MediaError,\n  MuxErrorCategory,\n  MuxErrorCode,\n  errorCategoryToTokenNameOrPrefix,\n  MuxJWTAud,\n  addTextTrack,\n  removeTextTrack,\n  getTextTrack,\n  addCuePoints,\n  getCuePoints,\n  getActiveCuePoint,\n  setupCuePoints,\n  addChapters,\n  getChapters,\n  getActiveChapter,\n  setupChapters,\n  getStartDate,\n  getCurrentPdt,\n  toPlaybackIdParts,\n  i18n,\n  parseJwt,\n};\nexport * from './types';\n\nconst DRMType = {\n  FAIRPLAY: 'fairplay',\n  PLAYREADY: 'playready',\n  WIDEVINE: 'widevine',\n} as const;\n\ntype DRMTypeValue = (typeof DRMType)[keyof typeof DRMType];\nexport const toDRMTypeFromKeySystem = (keySystem: string): DRMTypeValue | undefined => {\n  if (keySystem.includes('fps')) return DRMType.FAIRPLAY;\n  if (keySystem.includes('playready')) return DRMType.PLAYREADY;\n  if (keySystem.includes('widevine')) return DRMType.WIDEVINE;\n  return undefined;\n};\n\nexport const getMediaPlaylistFromMultivariantPlaylist = (multivariantPlaylist: string) => {\n  const mediaPlaylistUrl = multivariantPlaylist.split('\\n').find((_line, idx, lines) => {\n    return idx && lines[idx - 1].startsWith('#EXT-X-STREAM-INF');\n  }) as string;\n\n  return fetch(mediaPlaylistUrl).then((resp) => {\n    if (resp.status !== 200) {\n      return Promise.reject(resp);\n    }\n    return resp.text();\n  });\n};\n\nexport const getMultivariantPlaylistSessionData = (playlist: string) => {\n  // See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-12#section-4.4.6.4\n  const sessionDataLines = playlist.split('\\n').filter((line) => line.startsWith('#EXT-X-SESSION-DATA'));\n  if (!sessionDataLines.length) return {};\n\n  const sessionData: Record<string, Record<string, string>> = {};\n\n  for (const line of sessionDataLines) {\n    const sessionDataAttrs = parseTagAttributes(line);\n    const dataId = sessionDataAttrs['DATA-ID'];\n    if (!dataId) continue;\n\n    sessionData[dataId] = { ...sessionDataAttrs };\n  }\n\n  return {\n    sessionData,\n  };\n};\n\n// matches all HLS attribute name=value pairs, with or without quotes, using per spec rules\n// for matching AttributeName (See: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-17#section-4.2)\nconst ATTR_LIST_REGEX = /([A-Z0-9-]+)=\"?(.*?)\"?(?:,|$)/g;\nexport function parseTagAttributes(str: string) {\n  const matches = [...str.matchAll(ATTR_LIST_REGEX)];\n  return Object.fromEntries(matches.map(([, key, value]) => [key, value]));\n}\n\nexport const getStreamInfoFromPlaylist = (playlist: string) => {\n  const playlistLines = playlist.split('\\n');\n  const typeLine = playlistLines.find((line) => line.startsWith('#EXT-X-PLAYLIST-TYPE')) ?? '';\n  const playlistType = typeLine.split(':')[1]?.trim() as HlsPlaylistTypes;\n  const streamType = toStreamTypeFromPlaylistType(playlistType);\n  const targetLiveWindow = toTargetLiveWindowFromPlaylistType(playlistType);\n\n  // Computation of the live edge start offset per media-ui-extensions proposal. See: https://github.com/video-dev/media-ui-extensions/blob/main/proposals/0007-live-edge.md#recommended-computation-for-rfc8216bis12-aka-hls (CJP)\n  let liveEdgeStartOffset = undefined;\n\n  if (streamType === StreamTypes.LIVE) {\n    // Required if playlist contains one or more EXT-X-PART tags. See: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-12#section-4.4.3.7 (CJP)\n    const partInfLine = playlistLines.find((line) => line.startsWith('#EXT-X-PART-INF'));\n    const lowLatency = !!partInfLine;\n\n    if (lowLatency) {\n      // The EXT-X-PART-INF only has one in-spec named attribute, PART-TARGET, which is required,\n      // so parsing & casting presumptuously here. See spec link above for more info. (CJP)\n      const partTarget = +partInfLine.split(':')[1].split('=')[1];\n      liveEdgeStartOffset = partTarget * 2;\n    } else {\n      // This is required for all media playlists. See: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-12#section-4.4.3.1 (CJP)\n      const targetDurationLine = playlistLines.find((line) => line.startsWith('#EXT-X-TARGETDURATION')) as string;\n      // EXT-X-TARGETDURATION has exactly one unnamed attribute that represents the target duration value, which is required,\n      // so parsing and casting presumptuously here. See spec link above for more info. (CJP)\n      const targetDurationValue = targetDurationLine?.split(':')?.[1];\n      // NOTE: Defaulting here and using optional chaining above since some people are seeing RTEs on iPhones under edge cases.\n      // Identifying root cause would be ideal, but this will at least avoid the RTE. (CJP)\n      const targetDuration = +(targetDurationValue ?? 6);\n      liveEdgeStartOffset = targetDuration * 3;\n    }\n  }\n\n  return {\n    streamType,\n    targetLiveWindow,\n    liveEdgeStartOffset,\n  };\n};\n\nexport const getStreamInfoFromSrcAndType = async (src: string, type?: MediaTypes | '') => {\n  if (type === ExtensionMimeTypeMap.MP4) {\n    return {\n      streamType: StreamTypes.ON_DEMAND,\n      targetLiveWindow: Number.NaN,\n      liveEdgeStartOffset: undefined,\n      sessionData: undefined,\n    };\n  }\n\n  if (type === ExtensionMimeTypeMap.M3U8) {\n    const multivariantPlaylistResponse = await fetch(src);\n    if (!multivariantPlaylistResponse.ok) {\n      return Promise.reject(multivariantPlaylistResponse);\n    }\n    const multivariantPlaylist = await multivariantPlaylistResponse.text();\n    const mediaPlaylist = await getMediaPlaylistFromMultivariantPlaylist(multivariantPlaylist);\n    return {\n      ...getMultivariantPlaylistSessionData(multivariantPlaylist),\n      ...getStreamInfoFromPlaylist(mediaPlaylist),\n    };\n  }\n\n  // Unknown or undefined type.\n  console.error(`Media type ${type} is an unrecognized or unsupported type for src ${src}.`);\n  return {\n    streamType: undefined,\n    targetLiveWindow: undefined,\n    liveEdgeStartOffset: undefined,\n    sessionData: undefined,\n  };\n};\n\nexport const updateStreamInfoFromSrc = async (\n  src: string,\n  mediaEl: HTMLMediaElement,\n  type: MediaTypes | '' = getType({ src })\n) => {\n  const { streamType, targetLiveWindow, liveEdgeStartOffset, sessionData } = await getStreamInfoFromSrcAndType(\n    src,\n    type\n  );\n\n  const metadata = sessionData?.['com.apple.hls.chapters' as keyof typeof sessionData];\n  if (metadata?.URI || metadata?.VALUE.toLocaleLowerCase().startsWith('http')) {\n    // NOTE: data identified by DATA-ID 'com.apple.hls.chapters' is expected to provide its value\n    // via a remote JSON source identified by the URI attribute. Providing VALUE as a fallback.\n    // For more, see:\n    // https://developer.apple.com/documentation/http-live-streaming/providing-javascript-object-notation-json-chapters#Specify-a-main-playlist\n    fetchAndDispatchMuxMetadata(metadata.URI ?? metadata.VALUE, mediaEl);\n  }\n\n  (muxMediaState.get(mediaEl) ?? {}).liveEdgeStartOffset = liveEdgeStartOffset;\n\n  (muxMediaState.get(mediaEl) ?? {}).targetLiveWindow = targetLiveWindow;\n  mediaEl.dispatchEvent(new CustomEvent('targetlivewindowchange', { composed: true, bubbles: true }));\n\n  (muxMediaState.get(mediaEl) ?? {}).streamType = streamType;\n  mediaEl.dispatchEvent(new CustomEvent('streamtypechange', { composed: true, bubbles: true }));\n};\n\nexport const fetchAndDispatchMuxMetadata = async (metadataUrl: string, mediaEl: HTMLMediaElement) => {\n  try {\n    const resp = await fetch(metadataUrl);\n    if (!resp.ok) {\n      throw new Error(`Failed to fetch Mux metadata: ${resp.status} ${resp.statusText}`);\n    }\n\n    const json = await resp.json();\n    const metadata: Record<string, string> = {};\n\n    if (!json?.[0]?.metadata) return;\n\n    for (const item of json[0].metadata) {\n      if (item.key && item.value) {\n        metadata[item.key] = item.value;\n      }\n    }\n\n    (muxMediaState.get(mediaEl) ?? {}).metadata = metadata;\n\n    const eventUpdateMetadata = new CustomEvent('muxmetadata');\n    mediaEl.dispatchEvent(eventUpdateMetadata);\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nexport const getStreamInfoFromHlsjsLevelDetails = (levelDetails: any) => {\n  const playlistType: HlsPlaylistTypes = levelDetails.type as HlsPlaylistTypes;\n\n  const streamType = toStreamTypeFromPlaylistType(playlistType);\n  const targetLiveWindow = toTargetLiveWindowFromPlaylistType(playlistType);\n  let liveEdgeStartOffset = undefined;\n  const lowLatency = !!levelDetails.partList?.length;\n  if (streamType === StreamTypes.LIVE) {\n    liveEdgeStartOffset = lowLatency ? levelDetails.partTarget * 2 : levelDetails.targetduration * 3;\n  }\n\n  return {\n    streamType,\n    targetLiveWindow,\n    liveEdgeStartOffset,\n    lowLatency,\n  };\n};\n\nexport const updateStreamInfoFromHlsjsLevelDetails = (\n  levelDetails: any,\n  mediaEl: HTMLMediaElement,\n  hls: Pick<Hls, 'config' | 'userConfig' | 'liveSyncPosition'>\n) => {\n  const { streamType, targetLiveWindow, liveEdgeStartOffset, lowLatency } =\n    getStreamInfoFromHlsjsLevelDetails(levelDetails);\n\n  if (streamType === StreamTypes.LIVE) {\n    // Update hls.js config for live/ll-live\n    if (lowLatency) {\n      hls.config.backBufferLength = hls.userConfig.backBufferLength ?? 4;\n      hls.config.maxFragLookUpTolerance = hls.userConfig.maxFragLookUpTolerance ?? 0.001;\n      // For ll-hls, ensure that up switches are weighted the same as down switches to mitigate\n      // cases of getting stuck at lower bitrates.\n      hls.config.abrBandWidthUpFactor = hls.userConfig.abrBandWidthUpFactor ?? hls.config.abrBandWidthFactor;\n    } else {\n      hls.config.backBufferLength = hls.userConfig.backBufferLength ?? 8;\n    }\n\n    // Proxy `seekable.end()` to constrain based on rules in\n    // https://github.com/video-dev/media-ui-extensions/blob/main/proposals/0007-live-edge.md#property-constraint-on-htmlmediaelementseekableend-to-model-seekable-live-edge\n    const seekable: TimeRanges = Object.freeze({\n      get length() {\n        return mediaEl.seekable.length;\n      },\n      start(index: number) {\n        return mediaEl.seekable.start(index);\n      },\n      end(index: number) {\n        // Defer to native seekable for:\n        // 1) \"out of range\" cases\n        // 2) \"finite duration\" media (whether live/\"DVR\" that has ended or on demand)\n        if (index > this.length || index < 0 || Number.isFinite(mediaEl.duration)) return mediaEl.seekable.end(index);\n        // Otherwise rely on the live sync position (but still fall back to native seekable when nullish)\n        return hls.liveSyncPosition ?? mediaEl.seekable.end(index);\n      },\n    });\n    (muxMediaState.get(mediaEl) ?? {}).seekable = seekable;\n  }\n\n  (muxMediaState.get(mediaEl) ?? {}).liveEdgeStartOffset = liveEdgeStartOffset;\n\n  (muxMediaState.get(mediaEl) ?? {}).targetLiveWindow = targetLiveWindow;\n  mediaEl.dispatchEvent(new CustomEvent('targetlivewindowchange', { composed: true, bubbles: true }));\n\n  (muxMediaState.get(mediaEl) ?? {}).streamType = streamType;\n  mediaEl.dispatchEvent(new CustomEvent('streamtypechange', { composed: true, bubbles: true }));\n};\n\ndeclare global {\n  interface NavigatorUAData {\n    platform: string;\n    mobile: boolean;\n    brands: Array<{ brand: string; version: string }>;\n  }\n\n  interface Navigator {\n    userAgentData?: NavigatorUAData;\n  }\n}\n\nconst userAgentStr = globalThis?.navigator?.userAgent ?? '';\nconst userAgentPlatform = globalThis?.navigator?.userAgentData?.platform ?? '';\n\n// NOTE: Our primary *goal* with this is to detect \"non-Apple-OS\" platforms which may also support\n// native HLS playback. Our primary concern with any check for this is \"false negatives\" where we\n// identify an \"Apple-OS\" as a \"non-Apple-OS\". As such, instead of having logic to attempt to identify\n// \"!isAppleOS\", we opt to target known platforms that can support both native playback and MSE/hls.js.\n// For now, these are \"Android or Android-like\" platforms. If we end up matching platforms other than\n// Android (or e.g. forks thereof), this is fine so long as it doesn't include Apple-OS platforms.\n// Below are two strategies:\n// 1. UA string parsing - here, we're extra cautious to only match if the UA string explicitly includes 'android'.\n//   This is prone to false negatives (aka \"Android or Android-like\" platforms that yield false), since\n//   detection using UA strings is intentionally and notoriously unreliable (See: https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent)\n//   and Google is even officially attempting to lock this down even more for security and privacy reasons\n//   (See: https://developers.google.com/privacy-sandbox/blog/user-agent-reduction-android-model-and-version)\n// 2. userAgentData.platform checking - here, we're matching either 'android' or 'x11', and could add more matches in the future\n//    While still prone to false negatives, we can be a bit more aggressive with matches here for a few reasons.\n//    First, navigator.userAgentData is still experimental, is only supported on a subset of Chromium browsers,\n//    and neither Mozilla nor Webkit have even established an official browser support position. In other words,\n//    Apple-OS Safari and even other Apple-OS browsers (including Chrome) will typically not even support this\n//    feature, and, if and when they do, the purpose of this new API is to avoid obfuscatory information, so\n//    we should be able to better trust userAgentData.platform to not result in erroneous matches.\nconst isAndroidLike =\n  userAgentStr.toLowerCase().includes('android') ||\n  ['x11', 'android'].some((platformStr) => userAgentPlatform.toLowerCase().includes(platformStr));\n\n// NOTE: Exporting for testing\nexport const muxMediaState: WeakMap<\n  HTMLMediaElement,\n  Partial<MuxMediaProps> & { seekable?: TimeRanges; liveEdgeStartOffset?: number; retryCount?: number }\n> = new WeakMap();\n\nconst MUX_VIDEO_DOMAIN = 'mux.com';\nconst MSE_SUPPORTED = Hls.isSupported?.();\nconst DEFAULT_PREFER_MSE = isAndroidLike;\n\nexport const generatePlayerInitTime = () => {\n  return mux.utils.now();\n};\n\nexport const generateUUID = mux.utils.generateUUID;\n\ntype MuxVideoURLProps = Partial<\n  Pick<\n    MuxMediaPropTypes,\n    | 'playbackId'\n    | 'customDomain'\n    | 'maxResolution'\n    | 'minResolution'\n    | 'renditionOrder'\n    | 'programStartTime'\n    | 'programEndTime'\n    | 'assetStartTime'\n    | 'assetEndTime'\n    | 'tokens'\n    | 'playbackToken'\n    | 'extraSourceParams'\n  >\n>;\n\nexport const toMuxVideoURL = ({\n  playbackId: playbackIdWithParams,\n  customDomain: domain = MUX_VIDEO_DOMAIN,\n  maxResolution,\n  minResolution,\n  renditionOrder,\n  programStartTime,\n  programEndTime,\n  assetStartTime,\n  assetEndTime,\n  // Normalizes different ways of providing playback token\n  playbackToken,\n  tokens: { playback: token = playbackToken } = {},\n  extraSourceParams = {},\n}: MuxVideoURLProps = {}) => {\n  if (!playbackIdWithParams) return undefined;\n  // Normalizes different ways of providing playback id\n  const [playbackId, queryPart = ''] = toPlaybackIdParts(playbackIdWithParams);\n  const url = new URL(`https://stream.${domain}/${playbackId}.m3u8${queryPart}`);\n  /*\n   * All identified query params here can only be added to public\n   * playback IDs. In order to use these features with signed URLs\n   * the query param must be added to the signing token.\n   *\n   * */\n  if (token || url.searchParams.has('token')) {\n    url.searchParams.forEach((_, key) => {\n      if (key != 'token') url.searchParams.delete(key);\n    });\n    if (token) url.searchParams.set('token', token);\n  } else {\n    if (maxResolution) {\n      url.searchParams.set('max_resolution', maxResolution);\n    }\n    if (minResolution) {\n      url.searchParams.set('min_resolution', minResolution);\n      if (maxResolution && +maxResolution.slice(0, -1) < +minResolution.slice(0, -1)) {\n        console.error(\n          'minResolution must be <= maxResolution',\n          'minResolution',\n          minResolution,\n          'maxResolution',\n          maxResolution\n        );\n      }\n    }\n    if (renditionOrder) {\n      url.searchParams.set('rendition_order', renditionOrder);\n    }\n    if (programStartTime) {\n      url.searchParams.set('program_start_time', `${programStartTime}`);\n    }\n    if (programEndTime) {\n      url.searchParams.set('program_end_time', `${programEndTime}`);\n    }\n    if (assetStartTime) {\n      url.searchParams.set('asset_start_time', `${assetStartTime}`);\n    }\n    if (assetEndTime) {\n      url.searchParams.set('asset_end_time', `${assetEndTime}`);\n    }\n    Object.entries(extraSourceParams).forEach(([k, v]) => {\n      if (v == undefined) return;\n      url.searchParams.set(k, v);\n    });\n  }\n  return url.toString();\n};\n\nconst toPlaybackIdFromParameterized = (playbackIdWithParams: string | undefined) => {\n  if (!playbackIdWithParams) return undefined;\n  const [playbackId] = playbackIdWithParams.split('?');\n  // `|| undefined` is here to handle potential invalid cases\n  return playbackId || undefined;\n};\n\nexport const toPlaybackIdFromSrc = (src: string | undefined) => {\n  if (!src || !src.startsWith('https://stream.')) return undefined;\n  const [playbackId] = new URL(src).pathname.slice(1).split(/\\.m3u8|\\//);\n  // `|| undefined` is here to handle potential invalid cases\n  return playbackId || undefined;\n};\n\nconst toVideoId = (props: Partial<MuxMediaPropsInternal>) => {\n  if (props?.metadata?.video_id) return props.metadata.video_id;\n  if (!isMuxVideoSrc(props)) return props.src;\n  return toPlaybackIdFromParameterized(props.playbackId) ?? toPlaybackIdFromSrc(props.src) ?? props.src;\n};\n\nexport const getError = (mediaEl: HTMLMediaElement) => {\n  return muxMediaState.get(mediaEl)?.error;\n};\n\nexport const getMetadata = (mediaEl: HTMLMediaElement) => {\n  return muxMediaState.get(mediaEl)?.metadata;\n};\n\nexport const getStreamType = (mediaEl: HTMLMediaElement) => {\n  return muxMediaState.get(mediaEl)?.streamType ?? StreamTypes.UNKNOWN;\n};\n\nexport const getTargetLiveWindow = (mediaEl: HTMLMediaElement) => {\n  return muxMediaState.get(mediaEl)?.targetLiveWindow ?? Number.NaN;\n};\n\nexport const getSeekable = (mediaEl: HTMLMediaElement) => {\n  return muxMediaState.get(mediaEl)?.seekable ?? mediaEl.seekable;\n};\n\nexport const getLiveEdgeStart = (mediaEl: HTMLMediaElement) => {\n  const liveEdgeStartOffset = muxMediaState.get(mediaEl)?.liveEdgeStartOffset;\n  if (typeof liveEdgeStartOffset !== 'number') return Number.NaN;\n  const seekable = getSeekable(mediaEl);\n  // We aren't guaranteed that seekable is ready before invoking this, so handle that case.\n  if (!seekable.length) return Number.NaN;\n  return seekable.end(seekable.length - 1) - liveEdgeStartOffset;\n};\n\nconst DEFAULT_ENDED_MOE = 0.034;\n\nconst isApproximatelyEqual = (x: number, y: number, moe = DEFAULT_ENDED_MOE) => Math.abs(x - y) <= moe;\nconst isApproximatelyGTE = (x: number, y: number, moe = DEFAULT_ENDED_MOE) => x > y || isApproximatelyEqual(x, y, moe);\n\nexport const isPseudoEnded = (mediaEl: HTMLMediaElement, moe = DEFAULT_ENDED_MOE) => {\n  return mediaEl.paused && isApproximatelyGTE(mediaEl.currentTime, mediaEl.duration, moe);\n};\n\nexport const isStuckOnLastFragment = (\n  mediaEl: HTMLMediaElement,\n  hls?: Pick<\n    Hls,\n    /** Should we add audio fragments logic here, too? (CJP) */\n    // | 'audioTrack'\n    // | 'audioTracks'\n    'levels' | 'currentLevel'\n  >\n) => {\n  if (!hls || !mediaEl.buffered.length) return undefined;\n  if (mediaEl.readyState > 2) return false;\n  const videoLevelDetails =\n    hls.currentLevel >= 0\n      ? hls.levels?.[hls.currentLevel]?.details\n      : hls.levels.find((level) => !!level.details)?.details;\n\n  // Don't define for live streams (for now).\n  if (!videoLevelDetails || videoLevelDetails.live) return undefined;\n\n  const { fragments } = videoLevelDetails;\n\n  // Don't give a definitive true|false before we have no fragments (for now).\n  if (!fragments?.length) return undefined;\n\n  // Do a cheap check up front to see if we're close to the end.\n  // For more on TARGET_DURATION, see https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-14#section-4.4.3.1 (CJP)\n  if (mediaEl.currentTime < mediaEl.duration - (videoLevelDetails.targetduration + 0.5)) return false;\n\n  const lastFragment = fragments[fragments.length - 1];\n\n  // We're not yet playing the last fragment, so we can't be stuck on it.\n  if (mediaEl.currentTime <= lastFragment.start) return false;\n\n  const lastFragmentMidpoint = lastFragment.start + lastFragment.duration / 2;\n  const lastBufferedStart = mediaEl.buffered.start(mediaEl.buffered.length - 1);\n  const lastBufferedEnd = mediaEl.buffered.end(mediaEl.buffered.length - 1);\n\n  // True if we've already buffered (half of) the last fragment\n  const lastFragmentInBuffer = lastFragmentMidpoint > lastBufferedStart && lastFragmentMidpoint < lastBufferedEnd;\n  // If we haven't buffered half already, assume we're still waiting to fetch+buffer the fragment, otherwise,\n  // since we already checked the ready state, this means we're stuck on the last segment, and should pretend we're ended!\n  return lastFragmentInBuffer;\n};\n\nexport const getEnded = (\n  mediaEl: HTMLMediaElement,\n  hls?: Pick<\n    Hls,\n    /** Should we add audio fragments logic here, too? (CJP) */\n    // | 'audioTrack'\n    // | 'audioTracks'\n    'levels' | 'currentLevel'\n  >\n) => {\n  // Since looping media never truly ends, don't apply pseudo-ended logic\n  // Also, trust when the HTMLMediaElement says we have ended (only apply pseudo-ended logic when it reports false)\n  if (mediaEl.ended || mediaEl.loop) return mediaEl.ended;\n  // Externalize conversion to boolean for \"under-determined cases\" here (See isStuckOnLastFragment() for details)\n  if (hls && !!isStuckOnLastFragment(mediaEl, hls)) return true;\n  return isPseudoEnded(mediaEl);\n};\n\nexport const initialize = (props: Partial<MuxMediaPropsInternal>, mediaEl: HTMLMediaElement, core?: PlaybackCore) => {\n  // Automatically tear down previously initialized mux data & hls instance if it exists.\n  teardown(mediaEl, core, props);\n  // NOTE: metadata should never be nullish/nil. Adding here for type safety due to current type defs.\n  const { metadata = {} } = props;\n  const { view_session_id = generateUUID() } = metadata;\n  const video_id = toVideoId(props);\n  metadata.view_session_id = view_session_id;\n  metadata.video_id = video_id;\n  props.metadata = metadata;\n\n  // Used to signal DRM Type to Mux Data. See, e.g. `getDRMConfig()`\n  const drmTypeCb = (drmType?: string) => {\n    mediaEl.mux?.emit('hb', { view_drm_type: drmType });\n  };\n\n  props.drmTypeCb = drmTypeCb;\n\n  muxMediaState.set(mediaEl as HTMLMediaElement, { retryCount: 0 });\n  const nextHlsInstance = setupHls(props, mediaEl);\n  const setPreload = setupPreload(props as Pick<MuxMediaProps, 'preload' | 'src'>, mediaEl, nextHlsInstance);\n\n  if (props?.muxDataKeepSession && mediaEl?.mux && !mediaEl.mux.deleted) {\n    if (nextHlsInstance) {\n      mediaEl.mux.addHLSJS({\n        hlsjs: nextHlsInstance as HlsInterface,\n        Hls: nextHlsInstance ? Hls : undefined,\n      });\n    }\n  } else {\n    setupMux(props, mediaEl, nextHlsInstance);\n  }\n\n  loadMedia(props, mediaEl, nextHlsInstance);\n  setupCuePoints(mediaEl);\n  setupChapters(mediaEl);\n  const setAutoplay = setupAutoplay(props as Pick<MuxMediaProps, 'autoplay'>, mediaEl, nextHlsInstance);\n\n  return {\n    engine: nextHlsInstance,\n    setAutoplay,\n    setPreload,\n  };\n};\n\nexport const teardown = (\n  mediaEl?: HTMLMediaElement | null,\n  core?: PlaybackCore,\n  props?: Partial<MuxMediaPropsInternal>\n) => {\n  const hls = core?.engine;\n\n  if (mediaEl?.mux && !mediaEl.mux.deleted) {\n    if (props?.muxDataKeepSession) {\n      if (hls) mediaEl.mux.removeHLSJS();\n    } else {\n      mediaEl.mux.destroy();\n      delete mediaEl.mux;\n    }\n  }\n\n  if (hls) {\n    hls.detachMedia();\n    hls.destroy();\n  }\n\n  if (mediaEl) {\n    if (mediaEl.hasAttribute('src')) {\n      mediaEl.removeAttribute('src');\n      mediaEl.load();\n    }\n    mediaEl.removeEventListener('error', handleNativeError);\n    mediaEl.removeEventListener('error', handleInternalError);\n    mediaEl.removeEventListener('durationchange', seekInSeekableRange);\n    muxMediaState.delete(mediaEl);\n    mediaEl.dispatchEvent(new Event('teardown'));\n  }\n};\n\n/**\n * Returns true if we should use native playback. e.g. progressive files (mp3, mp4, webm) or native HLS on Safari.\n * We should use native playback for hls media sources if we\n *\n *   a) can use native playback (excluding Android, it's MSE by default)\n *   b) not prefer to use MSE/hls.js if it's supported\n */\nfunction useNative(\n  props: Partial<Pick<MuxMediaProps, 'preferPlayback' | 'type'>>,\n  mediaEl: Pick<HTMLMediaElement, 'canPlayType'>\n) {\n  const type = getType(props);\n  const hlsType = type === ExtensionMimeTypeMap.M3U8;\n  if (!hlsType) return true;\n\n  const canUseNative = !type || (mediaEl.canPlayType(type) ?? true);\n  const { preferPlayback } = props;\n\n  const preferMse = preferPlayback === PlaybackTypes.MSE;\n  const preferNative = preferPlayback === PlaybackTypes.NATIVE;\n  const forceMse = MSE_SUPPORTED && (preferMse || DEFAULT_PREFER_MSE);\n\n  return canUseNative && (preferNative || !forceMse);\n}\n\nexport const setupHls = (\n  props: Partial<\n    Pick<\n      MuxMediaPropsInternal,\n      'debug' | 'streamType' | 'type' | 'startTime' | 'metadata' | 'preferCmcd' | '_hlsConfig' | 'tokens' | 'drmTypeCb'\n    >\n  >,\n  mediaEl: HTMLMediaElement\n) => {\n  const { debug, streamType, startTime: startPosition = -1, metadata, preferCmcd, _hlsConfig = {} } = props;\n  const type = getType(props);\n  const hlsType = type === ExtensionMimeTypeMap.M3U8;\n  const shouldUseNative = useNative(props, mediaEl);\n\n  // 1. if we are trying to play an hls media source create hls if we should be using it \"under the hood\"\n  if (hlsType && !shouldUseNative && MSE_SUPPORTED) {\n    const defaultConfig = {\n      backBufferLength: 30,\n      renderTextTracksNatively: false,\n      liveDurationInfinity: true,\n      capLevelToPlayerSize: true,\n      capLevelOnFPSDrop: true,\n    };\n    const streamTypeConfig = getStreamTypeConfig(streamType);\n    const drmConfig = getDRMConfig(props);\n    // NOTE: `metadata.view_session_id` & `metadata.video_id` are guaranteed here (CJP)\n    // @ts-ignore\n    const cmcd = [CmcdTypes.QUERY, CmcdTypes.HEADER].includes(preferCmcd)\n      ? {\n          useHeaders: preferCmcd === CmcdTypes.HEADER,\n          sessionId: metadata?.view_session_id,\n          contentId: metadata?.video_id,\n        }\n      : undefined;\n    const hls = new Hls({\n      // Kind of like preload metadata, but causes spinner.\n      // autoStartLoad: false,\n      debug,\n      startPosition,\n      cmcd,\n      xhrSetup: (xhr, url) => {\n        if (preferCmcd && preferCmcd !== CmcdTypes.QUERY) return;\n        const urlObj = new URL(url);\n        if (!urlObj.searchParams.has('CMCD')) return;\n        const cmcdVal = (urlObj.searchParams.get('CMCD')?.split(',') ?? [])\n          .filter((cmcdKVStr) => cmcdKVStr.startsWith('sid') || cmcdKVStr.startsWith('cid'))\n          .join(',');\n        urlObj.searchParams.set('CMCD', cmcdVal);\n\n        xhr.open('GET', urlObj);\n      },\n      capLevelController: MinCapLevelController,\n      ...defaultConfig,\n      ...streamTypeConfig,\n      ...drmConfig,\n      ..._hlsConfig,\n    }) as HlsInterface;\n\n    hls.on(Hls.Events.MANIFEST_PARSED, async function (_event, data) {\n      const chapters = data.sessionData?.['com.apple.hls.chapters'];\n      if (chapters?.URI || chapters?.VALUE.toLocaleLowerCase().startsWith('http')) {\n        fetchAndDispatchMuxMetadata(chapters?.URI ?? chapters?.VALUE, mediaEl);\n      }\n    });\n\n    return hls;\n  }\n  return undefined;\n};\n\nexport const getStreamTypeConfig = (streamType?: ValueOf<StreamTypes>) => {\n  // for regular live videos, set backBufferLength to 8\n  if (streamType === StreamTypes.LIVE) {\n    const liveConfig = {\n      backBufferLength: 8,\n    };\n\n    return liveConfig;\n  }\n\n  return {};\n};\n\nexport const getDRMConfig = (\n  props: Partial<Pick<MuxMediaPropsInternal, 'src' | 'playbackId' | 'tokens' | 'customDomain' | 'drmTypeCb'>>\n): Partial<HlsConfig> => {\n  const {\n    tokens: { drm: drmToken } = {},\n    playbackId: playbackIdWithOptionalParams, // Since Mux Player typically sets `src` instead of `playbackId`, fall back to it here (CJP)\n    drmTypeCb,\n  } = props;\n  const playbackId = toPlaybackIdFromParameterized(playbackIdWithOptionalParams);\n  if (!drmToken || !playbackId) return {};\n  return {\n    emeEnabled: true,\n    drmSystems: {\n      'com.apple.fps': {\n        licenseUrl: toLicenseKeyURL(props, 'fairplay'),\n        serverCertificateUrl: toAppCertURL(props, 'fairplay'),\n      },\n      'com.widevine.alpha': {\n        licenseUrl: toLicenseKeyURL(props, 'widevine'),\n      },\n      'com.microsoft.playready': {\n        licenseUrl: toLicenseKeyURL(props, 'playready'),\n      },\n    },\n    requestMediaKeySystemAccessFunc: (keySystem, supportedConfigurations) => {\n      if (keySystem === 'com.widevine.alpha') {\n        supportedConfigurations = [\n          // NOTE: For widevine, by default we'll duplicate the key system configs but add L1-level\n          // security to the first set of duplicates so the key system will \"prefer\" that\n          // if/when available. (CJP)\n          // See, e.g.: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess#supportedconfigurations\n          ...supportedConfigurations.map((mediaKeySystemConfig) => {\n            const videoCapabilities = mediaKeySystemConfig.videoCapabilities?.map((capability) => {\n              return {\n                ...capability,\n                robustness: 'HW_SECURE_ALL',\n              };\n            });\n            return {\n              ...mediaKeySystemConfig,\n              videoCapabilities,\n            };\n          }),\n          ...supportedConfigurations,\n        ];\n      }\n      return navigator.requestMediaKeySystemAccess(keySystem, supportedConfigurations).then((value) => {\n        const drmType = toDRMTypeFromKeySystem(keySystem);\n        drmTypeCb?.(drmType);\n        return value;\n      });\n    },\n  };\n};\n\nexport const getAppCertificate = async (appCertificateUrl: string) => {\n  const resp = await fetch(appCertificateUrl);\n  if (resp.status !== 200) {\n    return Promise.reject(resp);\n  }\n  const body = await resp.arrayBuffer();\n  return body;\n};\n\nexport const getLicenseKey = async (message: ArrayBuffer, licenseServerUrl: string) => {\n  const resp = await fetch(licenseServerUrl, {\n    method: 'POST',\n    headers: { 'Content-type': 'application/octet-stream' },\n    body: message,\n  });\n  if (resp.status !== 200) {\n    return Promise.reject(resp);\n  }\n  const keyBuffer = await resp.arrayBuffer();\n  return new Uint8Array(keyBuffer);\n};\n\nexport const setupNativeFairplayDRM = (\n  props: Partial<Pick<MuxMediaPropsInternal, 'playbackId' | 'tokens' | 'playbackToken' | 'customDomain' | 'drmTypeCb'>>,\n  mediaEl: HTMLMediaElement\n) => {\n  const onFpEncrypted = async (event: MediaEncryptedEvent) => {\n    try {\n      const initDataType = event.initDataType;\n      if (initDataType !== 'skd') {\n        console.error(`Received unexpected initialization data type \"${initDataType}\"`);\n        return;\n      }\n\n      if (!mediaEl.mediaKeys) {\n        const access = await navigator\n          .requestMediaKeySystemAccess('com.apple.fps', [\n            {\n              initDataTypes: [initDataType],\n              videoCapabilities: [{ contentType: 'application/vnd.apple.mpegurl', robustness: '' }],\n              distinctiveIdentifier: 'not-allowed',\n              persistentState: 'not-allowed',\n              sessionTypes: ['temporary'],\n            },\n          ])\n          .then((value) => {\n            props.drmTypeCb?.(DRMType.FAIRPLAY);\n            return value;\n          })\n          .catch(() => {\n            const message = i18n(\n              'Cannot play DRM-protected content with current security configuration on this browser. Try playing in another browser.'\n            );\n            // Should we flag this as a business exception?\n            const mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, true);\n            mediaError.errorCategory = MuxErrorCategory.DRM;\n            mediaError.muxCode = MuxErrorCode.ENCRYPTED_UNSUPPORTED_KEY_SYSTEM;\n            saveAndDispatchError(mediaEl, mediaError);\n          });\n\n        if (!access) return;\n\n        const keys = await access.createMediaKeys();\n\n        try {\n          const fairPlayAppCert = await getAppCertificate(toAppCertURL(props, 'fairplay')).catch((errOrResp) => {\n            if (errOrResp instanceof Response) {\n              const mediaError = getErrorFromResponse(errOrResp, MuxErrorCategory.DRM, props);\n              console.error('mediaError', mediaError?.message, mediaError?.context);\n              if (mediaError) {\n                return Promise.reject(mediaError);\n              }\n              // NOTE: This should never happen. Adding for exhaustiveness (CJP).\n              return Promise.reject(new Error('Unexpected error in app cert request'));\n            }\n            return Promise.reject(errOrResp);\n          });\n          await keys.setServerCertificate(fairPlayAppCert).catch(() => {\n            const message = i18n(\n              'Your server certificate failed when attempting to set it. This may be an issue with a no longer valid certificate.'\n            );\n            const mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, true);\n            mediaError.errorCategory = MuxErrorCategory.DRM;\n            mediaError.muxCode = MuxErrorCode.ENCRYPTED_UPDATE_SERVER_CERT_FAILED;\n            return Promise.reject(mediaError);\n          });\n          // @ts-ignore\n        } catch (error: Error | MediaError) {\n          saveAndDispatchError(mediaEl, error);\n          return;\n        }\n        await mediaEl.setMediaKeys(keys);\n      }\n\n      const initData = event.initData;\n      if (initData == null) {\n        console.error(`Could not start encrypted playback due to missing initData in ${event.type} event`);\n        return;\n      }\n\n      const session = (mediaEl.mediaKeys as MediaKeys).createSession();\n      session.addEventListener('keystatuseschange', () => {\n        // recheck key statuses\n        // NOTE: As an improvement, we could also add checks for a status of 'expired' and\n        // attempt to renew the license here (CJP)\n        session.keyStatuses.forEach((mediaKeyStatus) => {\n          let mediaError;\n          if (mediaKeyStatus === 'internal-error') {\n            const message = i18n(\n              'The DRM Content Decryption Module system had an internal failure. Try reloading the page, upading your browser, or playing in another browser.'\n            );\n            mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, true);\n            mediaError.errorCategory = MuxErrorCategory.DRM;\n            mediaError.muxCode = MuxErrorCode.ENCRYPTED_CDM_ERROR;\n          } else if (mediaKeyStatus === 'output-restricted' || mediaKeyStatus === 'output-downscaled') {\n            const message = i18n(\n              'DRM playback is being attempted in an environment that is not sufficiently secure. User may see black screen.'\n            );\n            // NOTE: When encountered, this is a non-fatal error (though it's certainly interruptive of standard playback experience). (CJP)\n            mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, false);\n            mediaError.errorCategory = MuxErrorCategory.DRM;\n            mediaError.muxCode = MuxErrorCode.ENCRYPTED_OUTPUT_RESTRICTED;\n          }\n\n          if (mediaError) {\n            saveAndDispatchError(mediaEl, mediaError);\n          }\n        });\n      });\n      const message = await Promise.all([\n        session.generateRequest(initDataType, initData).catch(() => {\n          // eslint-disable-next-line no-shadow\n          const message = i18n(\n            'Failed to generate a DRM license request. This may be an issue with the player or your protected content.'\n          );\n          const mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, true);\n          mediaError.errorCategory = MuxErrorCategory.DRM;\n          mediaError.muxCode = MuxErrorCode.ENCRYPTED_GENERATE_REQUEST_FAILED;\n          saveAndDispatchError(mediaEl, mediaError);\n        }),\n        new Promise<MediaKeyMessageEvent['message']>((resolve) => {\n          session.addEventListener(\n            'message',\n            (messageEvent) => {\n              resolve(messageEvent.message);\n            },\n            { once: true }\n          );\n        }),\n      ]).then(([, messageEventMsg]) => messageEventMsg);\n\n      const response = await getLicenseKey(message, toLicenseKeyURL(props, 'fairplay')).catch((errOrResp) => {\n        if (errOrResp instanceof Response) {\n          const mediaError = getErrorFromResponse(errOrResp, MuxErrorCategory.DRM, props);\n          console.error('mediaError', mediaError?.message, mediaError?.context);\n          if (mediaError) {\n            return Promise.reject(mediaError);\n          }\n          // NOTE: This should never happen. Adding for exhaustiveness (CJP).\n          return Promise.reject(new Error('Unexpected error in license key request'));\n        }\n        return Promise.reject(errOrResp);\n      });\n      await session.update(response).catch(() => {\n        // eslint-disable-next-line no-shadow\n        const message = i18n(\n          'Failed to update DRM license. This may be an issue with the player or your protected content.'\n        );\n        const mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, true);\n        mediaError.errorCategory = MuxErrorCategory.DRM;\n        mediaError.muxCode = MuxErrorCode.ENCRYPTED_UPDATE_LICENSE_FAILED;\n        return Promise.reject(mediaError);\n      });\n      // @ts-ignore\n    } catch (error: Error | MediaError) {\n      saveAndDispatchError(mediaEl, error);\n      return;\n    }\n  };\n\n  addEventListenerWithTeardown(mediaEl, 'encrypted', onFpEncrypted);\n};\n\nexport const toLicenseKeyURL = (\n  {\n    playbackId: playbackIdWithParams,\n    tokens: { drm: token } = {},\n    customDomain = MUX_VIDEO_DOMAIN,\n  }: Partial<Pick<MuxMediaPropsInternal, 'playbackId' | 'tokens' | 'customDomain'>>,\n  scheme: 'widevine' | 'playready' | 'fairplay'\n) => {\n  const playbackId = toPlaybackIdFromParameterized(playbackIdWithParams);\n  // NOTE: Mux Video currently doesn't support custom domains for license/DRM endpoints, but\n  // customDomain can also be used for internal use cases, so treat that as an exception case for now. (CJP)\n  const domain = customDomain.toLocaleLowerCase().endsWith(MUX_VIDEO_DOMAIN) ? customDomain : MUX_VIDEO_DOMAIN;\n  return `https://license.${domain}/license/${scheme}/${playbackId}?token=${token}`;\n};\n\nexport const toAppCertURL = (\n  {\n    playbackId: playbackIdWithParams,\n    tokens: { drm: token } = {},\n    customDomain = MUX_VIDEO_DOMAIN,\n  }: Partial<Pick<MuxMediaPropsInternal, 'playbackId' | 'tokens' | 'customDomain'>>,\n  scheme: 'widevine' | 'playready' | 'fairplay'\n) => {\n  const playbackId = toPlaybackIdFromParameterized(playbackIdWithParams);\n  // NOTE: Mux Video currently doesn't support custom domains for license/DRM endpoints, but\n  // customDomain can also be used for internal use cases, so treat that as an exception case for now. (CJP)\n  const domain = customDomain.toLocaleLowerCase().endsWith(MUX_VIDEO_DOMAIN) ? customDomain : MUX_VIDEO_DOMAIN;\n  return `https://license.${domain}/appcert/${scheme}/${playbackId}?token=${token}`;\n};\n\nexport const isMuxVideoSrc = ({\n  playbackId,\n  src,\n  customDomain,\n}: Partial<Pick<MuxMediaPropsInternal, 'playbackId' | 'src' | 'customDomain'>>) => {\n  if (!!playbackId) return true;\n  // having no playback id and no src string should never actually happen, but could\n  if (typeof src !== 'string') return false;\n  // Include base for relative paths\n  const base = window?.location.href;\n  const hostname = new URL(src, base).hostname.toLocaleLowerCase();\n\n  return hostname.includes(MUX_VIDEO_DOMAIN) || (!!customDomain && hostname.includes(customDomain.toLocaleLowerCase()));\n};\n\nexport const setupMux = (\n  props: Partial<\n    Pick<\n      MuxMediaPropsInternal,\n      | 'envKey'\n      | 'playerInitTime'\n      | 'beaconCollectionDomain'\n      | 'errorTranslator'\n      | 'metadata'\n      | 'debug'\n      | 'playerSoftwareName'\n      | 'playerSoftwareVersion'\n      | 'playbackId'\n      | 'src'\n      | 'customDomain'\n      | 'disableCookies'\n      | 'disableTracking'\n      | 'muxDataSDK'\n      | 'muxDataSDKOptions'\n    >\n  >,\n  mediaEl: HTMLMediaElement,\n  hlsjs?: HlsInterface\n) => {\n  const { envKey: env_key, disableTracking, muxDataSDK = mux, muxDataSDKOptions = {} } = props;\n  const inferredEnv = isMuxVideoSrc(props);\n\n  if (!disableTracking && (env_key || inferredEnv)) {\n    const {\n      playerInitTime: player_init_time,\n      playerSoftwareName: player_software_name,\n      playerSoftwareVersion: player_software_version,\n      beaconCollectionDomain,\n      debug,\n      disableCookies,\n    } = props;\n\n    const metadata = {\n      ...props.metadata,\n      video_title: props?.metadata?.video_title || undefined,\n    };\n\n    const muxEmbedErrorTranslator = (error: ErrorEvent) => {\n      // mux-embed auto tracks fatal hls.js errors, turn it off.\n      // playback-core will emit errors with a numeric code manually to mux-embed.\n      if (typeof error.player_error_code === 'string') return false;\n\n      if (typeof props.errorTranslator === 'function') {\n        return props.errorTranslator(error);\n      }\n\n      return error;\n    };\n\n    muxDataSDK.monitor(mediaEl, {\n      debug,\n      beaconCollectionDomain,\n      hlsjs,\n      Hls: hlsjs ? Hls : undefined,\n      automaticErrorTracking: false,\n      errorTranslator: muxEmbedErrorTranslator,\n      disableCookies,\n      ...muxDataSDKOptions,\n      data: {\n        ...(env_key ? { env_key } : {}),\n        // Metadata fields\n        player_software_name,\n        // NOTE: Adding this because there appears to be some instability on whether\n        // player_software_name or player_software \"wins\" for Mux Data (CJP)\n        player_software: player_software_name,\n        player_software_version,\n        player_init_time,\n        // Use any metadata passed in programmatically (which may override the defaults above)\n        ...metadata,\n      },\n    });\n  }\n};\n\nexport const loadMedia = (\n  props: Partial<\n    Pick<\n      MuxMediaProps,\n      | 'preferPlayback'\n      | 'src'\n      | 'type'\n      | 'startTime'\n      | 'streamType'\n      | 'autoplay'\n      | 'playbackId'\n      | 'tokens'\n      | 'customDomain'\n    >\n  >,\n  mediaEl: HTMLMediaElement,\n  hls?: Pick<\n    Hls,\n    | 'config'\n    | 'on'\n    | 'once'\n    | 'off'\n    | 'trigger'\n    | 'startLoad'\n    | 'stopLoad'\n    | 'recoverMediaError'\n    | 'destroy'\n    | 'loadSource'\n    | 'attachMedia'\n    | 'liveSyncPosition'\n    | 'subtitleTracks'\n    | 'subtitleTrack'\n    | 'userConfig'\n    | 'audioTrack'\n    | 'audioTracks'\n    | 'autoLevelEnabled'\n    | 'nextLevel'\n    | 'levels'\n    | 'currentLevel'\n  >\n) => {\n  const shouldUseNative = useNative(props, mediaEl);\n  const { src, customDomain = MUX_VIDEO_DOMAIN } = props;\n\n  const maybeDispatchEndedCallback = () => {\n    // We want to early bail if the underlying media element is already in an ended state,\n    // since that means it will have already fired the ended event.\n    // Do the \"cheaper\" check first\n    if (mediaEl.ended) return;\n    const pseudoEnded = getEnded(mediaEl, hls);\n    if (!pseudoEnded) return;\n\n    if (isStuckOnLastFragment(mediaEl, hls)) {\n      // Nudge the playhead in this case.\n      mediaEl.currentTime = mediaEl.buffered.end(mediaEl.buffered.length - 1);\n    } else {\n      mediaEl.dispatchEvent(new Event('ended'));\n    }\n  };\n\n  let prevSeekableStart: number | undefined;\n  let prevSeekableEnd: number | undefined;\n\n  const seekableChange = () => {\n    const seekableTimeRanges = getSeekable(mediaEl);\n    let nextSeekableStart: number | undefined;\n    let nextSeekableEnd: number | undefined;\n    if (seekableTimeRanges.length > 0) {\n      nextSeekableStart = seekableTimeRanges.start(0);\n      nextSeekableEnd = seekableTimeRanges.end(0);\n    }\n    if (prevSeekableEnd !== nextSeekableEnd || prevSeekableStart !== nextSeekableStart) {\n      mediaEl.dispatchEvent(new CustomEvent('seekablechange', { composed: true }));\n    }\n    prevSeekableStart = nextSeekableStart;\n    prevSeekableEnd = nextSeekableEnd;\n  };\n\n  // Make sure we track transitions from infinite to finite durations for seekable changes as well.\n  addEventListenerWithTeardown(mediaEl, 'durationchange', seekableChange);\n\n  if (mediaEl && shouldUseNative) {\n    const type = getType(props);\n\n    if (typeof src === 'string') {\n      // Fetch the Mux metadata JSON even on preload=none because it's needed for the Mux logo.\n      if (src.endsWith('.mp4') && src.includes(customDomain)) {\n        const playbackId = toPlaybackIdFromSrc(src);\n        const metadataUrl = new URL(`https://stream.${customDomain}/${playbackId}/metadata.json`);\n        fetchAndDispatchMuxMetadata(metadataUrl.toString(), mediaEl);\n      }\n\n      // NOTE: This should only be invoked after stream type has been\n      // derived after stream type has been determined.\n      const setupSeekableChangePoll = () => {\n        // Only monitor for seekable updates if StreamType is \"live\" and duration is not finite.\n        if (getStreamType(mediaEl) !== StreamTypes.LIVE || Number.isFinite(mediaEl.duration)) return;\n\n        // Use 1 second since in this context we don't know what the rate of updates\n        // should/will be.\n        // NOTE: We *could* derive the interval rate if we wanted to add logic to our playlist parsing to\n        // account for the per-spec rate of media playlist GETs. See:\n        // https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-14#section-6.3.4 (CJP)\n        const intervalId = setInterval(seekableChange, 1000);\n\n        // Make sure we clean up after ourselves.\n        mediaEl.addEventListener(\n          'teardown',\n          () => {\n            clearInterval(intervalId);\n          },\n          { once: true }\n        );\n\n        // Assume we're done updating seekable when the duration is finite, which\n        // occurs when e.g. an HLS playlist is ended (`#EXT-X-ENDLIST`).\n        addEventListenerWithTeardown(mediaEl, 'durationchange', () => {\n          if (!Number.isFinite(mediaEl.duration)) return;\n          clearInterval(intervalId);\n        });\n      };\n\n      const setupNativeStreamInfo = async () => {\n        return updateStreamInfoFromSrc(src, mediaEl, type)\n          .then(setupSeekableChangePoll)\n          .catch((errOrResp: Response | Error) => {\n            if (errOrResp instanceof Response) {\n              const mediaError = getErrorFromResponse(errOrResp, MuxErrorCategory.VIDEO, props);\n              if (mediaError) {\n                saveAndDispatchError(mediaEl, mediaError);\n                return;\n              }\n            } else if (errOrResp instanceof Error) {\n              // mediaEl.dispatchEvent(new MediaError())\n            }\n          });\n      };\n\n      if (mediaEl.preload === 'none') {\n        // NOTE: Previously, we relied on the 'loadstart' event to fetch & parse playlists for stream\n        // info for native playback scenarios. Unfortunately, per spec this event will be dispatched\n        // regardless of the preload state and regardless of whether or not fetching of the src media\n        // has, in fact, begun. In order to respect the provided preferences and avoid eager loading\n        // while still attempting to begin fetching playlists for stream info as early as possible when\n        // media *will* be loaded, we will do a \"first to the finish line\" on both the 'play' event,\n        // which will be dispatched earlier *if* it is the event that initiates media loading, and the\n        // 'loadedmetadata' event, which is dispatched only after the media has finished loading metadata,\n        // but will reliably correlate with media loading. (CJP)\n        // For more, see: Steps 7 & 8 of 'the resource selection algorithm' from §4.8.11.5 Loading the\n        // media resource in the HTML Living Standard\n        // (https://html.spec.whatwg.org/multipage/media.html#concept-media-load-algorithm)\n        const playHandler = () => {\n          setupNativeStreamInfo();\n          mediaEl.removeEventListener('loadedmetadata', loadedMetadataHandler);\n        };\n        const loadedMetadataHandler = () => {\n          setupNativeStreamInfo();\n          mediaEl.removeEventListener('play', playHandler);\n        };\n        addEventListenerWithTeardown(mediaEl, 'play', playHandler, { once: true });\n        addEventListenerWithTeardown(mediaEl, 'loadedmetadata', loadedMetadataHandler, { once: true });\n      } else {\n        setupNativeStreamInfo();\n      }\n\n      // NOTE: Currently use drmToken to signal that playback is expected to be DRM-protected\n      if (props.tokens?.drm) {\n        setupNativeFairplayDRM(props, mediaEl);\n      } else {\n        // If we end up receiving an encrypted event in this case, that means the media is DRM-protected\n        // but a token was not provided.\n        addEventListenerWithTeardown(\n          mediaEl,\n          'encrypted',\n          () => {\n            const message = i18n('Attempting to play DRM-protected content without providing a DRM token.');\n            const mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, true);\n            mediaError.errorCategory = MuxErrorCategory.DRM;\n            mediaError.muxCode = MuxErrorCode.ENCRYPTED_MISSING_TOKEN;\n            saveAndDispatchError(mediaEl, mediaError);\n          },\n          { once: true }\n        );\n      }\n\n      mediaEl.setAttribute('src', src);\n\n      if (props.startTime) {\n        (muxMediaState.get(mediaEl) ?? {}).startTime = props.startTime;\n        // seekable is set to the range of the entire video once durationchange fires\n        mediaEl.addEventListener('durationchange', seekInSeekableRange, { once: true });\n      }\n    } else {\n      mediaEl.removeAttribute('src');\n    }\n\n    mediaEl.addEventListener('error', handleNativeError);\n    mediaEl.addEventListener('error', handleInternalError);\n    mediaEl.addEventListener(\n      'emptied',\n      () => {\n        const trackEls: NodeListOf<HTMLTrackElement> = mediaEl.querySelectorAll('track[data-removeondestroy]');\n        trackEls.forEach((trackEl) => {\n          trackEl.remove();\n        });\n      },\n      { once: true }\n    );\n\n    addEventListenerWithTeardown(mediaEl, 'pause', maybeDispatchEndedCallback);\n    // NOTE: Browsers do not consistently fire an 'ended' event upon seeking to the\n    // end of the media while already paused. This was due to an ambiguity in the\n    // HTML specification, but is now more explicit.\n    // See: https://html.spec.whatwg.org/multipage/media.html#reaches-the-end (CJP)\n    addEventListenerWithTeardown(mediaEl, 'seeked', maybeDispatchEndedCallback);\n\n    addEventListenerWithTeardown(mediaEl, 'play', () => {\n      if (mediaEl.ended) return;\n      if (!isApproximatelyGTE(mediaEl.currentTime, mediaEl.duration)) return;\n      // If we were \"pseudo-ended\" before playback was attempted, seek back to the\n      // beginning to \"replay\", like \"real\" ended behavior.\n      mediaEl.currentTime = mediaEl.seekable.length ? mediaEl.seekable.start(0) : 0;\n    });\n  } else if (hls && src) {\n    hls.once(Hls.Events.LEVEL_LOADED, (_evt, data) => {\n      updateStreamInfoFromHlsjsLevelDetails(data.details, mediaEl, hls);\n      seekableChange();\n      // Only monitor for seekable updates if StreamType is \"live\" and duration is not finite.\n      if (getStreamType(mediaEl) === StreamTypes.LIVE && !Number.isFinite(mediaEl.duration)) {\n        hls.on(Hls.Events.LEVEL_UPDATED, seekableChange);\n\n        // Assume we're done updating seekable when the duration is finite, which\n        // occurs when e.g. an HLS playlist is ended (`#EXT-X-ENDLIST`).\n        addEventListenerWithTeardown(mediaEl, 'durationchange', () => {\n          if (!Number.isFinite(mediaEl.duration)) return;\n          hls.off(Hls.Events.LEVELS_UPDATED, seekableChange);\n        });\n      }\n    });\n\n    hls.on(Hls.Events.ERROR, (_event, data) => {\n      const error = getErrorFromHlsErrorData(data, props);\n\n      if (error.muxCode === MuxErrorCode.NETWORK_NOT_READY) {\n        const maxRetries = 6; // 5 minutes and 5 seconds total (5s, 60s, 60s, 60s, 60s, 60s)\n        const state = muxMediaState.get(mediaEl) ?? {};\n        const retryCount = state.retryCount ?? 0;\n\n        if (retryCount < maxRetries) {\n          // First retry is 5 seconds, subsequent retries are 60 seconds\n          const retryDelay = retryCount === 0 ? 5000 : 60000;\n\n          // New error with the retry delay\n          const retryDelayError = new MediaError(\n            `Retrying in ${retryDelay / 1000} seconds...`,\n            error.code,\n            error.fatal\n          );\n          Object.assign(retryDelayError, error);\n          saveAndDispatchError(mediaEl, retryDelayError);\n\n          setTimeout(() => {\n            state.retryCount = retryCount + 1;\n            if (data.details === 'manifestLoadError' && data.url) {\n              hls.loadSource(data.url);\n            }\n          }, retryDelay);\n          return;\n        } else {\n          state.retryCount = 0;\n          // New error with the retry link\n          const retryLinkError = new MediaError(\n            'Try again later or <a href=\"#\" onclick=\"window.location.reload(); return false;\" style=\"color: #4a90e2;\">click here to retry</a>',\n            error.code,\n            error.fatal\n          );\n          Object.assign(retryLinkError, error);\n          saveAndDispatchError(mediaEl, retryLinkError);\n          return;\n        }\n      }\n      saveAndDispatchError(mediaEl, error);\n    });\n\n    hls.on(Hls.Events.MANIFEST_LOADED, () => {\n      // Clear error state and UI\n      const state = muxMediaState.get(mediaEl);\n      if (state && state.error) {\n        state.error = null;\n        state.retryCount = 0;\n\n        mediaEl.dispatchEvent(new Event('emptied'));\n        mediaEl.dispatchEvent(new Event('loadstart'));\n      }\n    });\n\n    mediaEl.addEventListener('error', handleInternalError);\n    addEventListenerWithTeardown(mediaEl, 'waiting', maybeDispatchEndedCallback);\n\n    setupMediaTracks(props as HTMLMediaElement, hls);\n    setupTextTracks(mediaEl, hls);\n\n    hls.attachMedia(mediaEl);\n  } else {\n    console.error(\n      \"It looks like the video you're trying to play will not work on this system! If possible, try upgrading to the newest versions of your browser or software.\"\n    );\n  }\n};\n\nfunction seekInSeekableRange(event: Event) {\n  const mediaEl = event.target as HTMLMediaElement;\n  const startTime = muxMediaState.get(mediaEl)?.startTime;\n  if (!startTime) return;\n\n  if (inSeekableRange(mediaEl.seekable, mediaEl.duration, startTime)) {\n    // Setting preload to `none` from `auto` was required on iOS to fix a bug\n    // that caused no `timeupdate` events to fire after seeking ¯\\_(ツ)_/¯\n    const wasAuto = mediaEl.preload === 'auto';\n    if (wasAuto) {\n      mediaEl.preload = 'none';\n    }\n\n    mediaEl.currentTime = startTime;\n\n    if (wasAuto) {\n      mediaEl.preload = 'auto';\n    }\n  }\n}\n\nasync function handleNativeError(event: Event) {\n  // Return if the event was created or modified by a script or dispatched\n  // via EventTarget.dispatchEvent() preventing an infinite loop.\n  if (!event.isTrusted) return;\n\n  // Stop immediate propagation of the native error event, re-dispatch below!\n  event.stopImmediatePropagation();\n\n  const mediaEl = event.target as HTMLMediaElement;\n  // Safari sometimes throws an error event with a null error.\n  if (!mediaEl?.error) return;\n\n  const { message, code } = mediaEl.error;\n  const error = new MediaError(message, code);\n\n  // This accounts for cases where native playback is being used but\n  // a non-200 response occurs on the request for the playback-id's playlist.\n  // In this case, we currently already fetch the playlist in parallel (for\n  // things like inferring the stream type, live edge start window, etc.),\n  // so we'll wait briefly for that response to translate to a more accurate\n  // error.\n  if (\n    mediaEl.src &&\n    code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED &&\n    mediaEl.readyState === HTMLMediaElement.HAVE_NOTHING\n  ) {\n    setTimeout(() => {\n      const ourError = getError(mediaEl) ?? mediaEl.error;\n      // If the code is (still) MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED,\n      // assume it's an (unlikely) case where we did, in fact, encounter\n      // media that is unsupported.\n      if (ourError?.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED) {\n        saveAndDispatchError(mediaEl, error);\n      }\n      // Since a parallel request for the source should be initiated to determine\n      // stream info (e.g. streamType) at roughly the same time as when the source\n      // is loaded by the media element, we should be able to keep this timeout short.\n      // NOTE: Although there is a case where the parallel request may happen later\n      // (namely, after metadata is loaded), this should be mutually exclusive from\n      // the case we're accounting for here, since unsupported media should not\n      // ever get metadata loaded in the first place. (CJP)\n    }, 500);\n    return;\n  }\n\n  if (mediaEl.src && (code !== MediaError.MEDIA_ERR_DECODE || code !== undefined)) {\n    // Attempt to get the response code from the video src url.\n    try {\n      const { status } = await fetch(mediaEl.src);\n      // Use the same hls.js data structure.\n      error.data = { response: { code: status } };\n    } catch {}\n  }\n\n  saveAndDispatchError(mediaEl, error);\n}\n\nfunction saveAndDispatchError(mediaEl: HTMLMediaElement, error: MediaError) {\n  // Prevent dispatching non-fatal errors.\n  if (!error.fatal) return;\n\n  (muxMediaState.get(mediaEl) ?? {}).error = error as unknown as HTMLMediaElement['error'];\n\n  mediaEl.dispatchEvent(\n    new CustomEvent('error', {\n      detail: error,\n    })\n  );\n}\n\n/**\n * Use a event listener instead of a function call when dispatching the Custom error\n * event so consumers are still able to disable or intercept this error event.\n * @param {Event} event\n */\nfunction handleInternalError(event: Event | CustomEvent<MediaError>) {\n  if (!(event instanceof CustomEvent) || !(event.detail instanceof MediaError)) return;\n\n  const mediaEl = event.target as HTMLMediaElement;\n  const error = event.detail;\n  // Prevent tracking non-fatal errors in Mux data.\n  if (!error || !error.fatal) return;\n\n  (muxMediaState.get(mediaEl) ?? {}).error = error as unknown as HTMLMediaElement['error'];\n\n  // Only pass valid mux-embed props: player_error_code, player_error_message, player_error_context\n  mediaEl.mux?.emit('error', {\n    player_error_code: error.code,\n    player_error_message: error.message,\n    player_error_context: error.context,\n  });\n}\n\nconst getErrorFromHlsErrorData = (\n  data: ErrorData,\n  props: Partial<Pick<MuxMediaPropsInternal, 'playbackId' | 'drmToken' | 'playbackToken' | 'tokens'>>\n) => {\n  console.error('getErrorFromHlsErrorData()', data);\n\n  const ErrorCodeMap: Partial<Record<ValueOf<typeof Hls.ErrorTypes>, 0 | 1 | 2 | 3 | 4 | 5>> = {\n    [Hls.ErrorTypes.NETWORK_ERROR]: MediaError.MEDIA_ERR_NETWORK,\n    [Hls.ErrorTypes.MEDIA_ERROR]: MediaError.MEDIA_ERR_DECODE,\n    [Hls.ErrorTypes.KEY_SYSTEM_ERROR]: MediaError.MEDIA_ERR_ENCRYPTED,\n  } as const;\n\n  // eslint-disable-next-line no-shadow\n  const hlsErrorDataToErrorCode = (data: ErrorData) => {\n    if (\n      [\n        Hls.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n        Hls.ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n      ].includes(data.details)\n    ) {\n      return MediaError.MEDIA_ERR_NETWORK;\n    }\n    return ErrorCodeMap[data.type];\n  };\n\n  // eslint-disable-next-line no-shadow\n  const hlsErrorDataToCategory = (data: ErrorData) => {\n    if (data.type === Hls.ErrorTypes.KEY_SYSTEM_ERROR) return MuxErrorCategory.DRM;\n    if (data.type === Hls.ErrorTypes.NETWORK_ERROR) return MuxErrorCategory.VIDEO;\n  };\n\n  let mediaError: MediaError;\n  const errorCode = hlsErrorDataToErrorCode(data);\n  if (errorCode === MediaError.MEDIA_ERR_NETWORK && data.response) {\n    const category = hlsErrorDataToCategory(data) ?? MuxErrorCategory.VIDEO;\n    mediaError =\n      getErrorFromResponse(data.response, category, props, data.fatal) ?? new MediaError('', errorCode, data.fatal);\n  } else if (errorCode === MediaError.MEDIA_ERR_ENCRYPTED) {\n    if (data.details === Hls.ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE) {\n      const message = i18n('Attempting to play DRM-protected content without providing a DRM token.');\n      mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, data.fatal);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_MISSING_TOKEN;\n    } else if (data.details === Hls.ErrorDetails.KEY_SYSTEM_NO_ACCESS) {\n      /** @TODO For UI message add suggestion to try another browser */\n      const message = i18n(\n        'Cannot play DRM-protected content with current security configuration on this browser. Try playing in another browser.'\n      );\n      // Should we flag this as a business exception?\n      mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, data.fatal);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_UNSUPPORTED_KEY_SYSTEM;\n    } else if (data.details === Hls.ErrorDetails.KEY_SYSTEM_NO_SESSION) {\n      const message = i18n(\n        'Failed to generate a DRM license request. This may be an issue with the player or your protected content.'\n      );\n      // NOTE: For some reason, perhaps due to issues with EXT-X-KEY parsing, hls.js defines this as a non-fatal error.\n      // For us, we should be able to assume it is instead fatal. (CJP)\n      mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, true);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_GENERATE_REQUEST_FAILED;\n    } else if (data.details === Hls.ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED) {\n      const message = i18n(\n        'Failed to update DRM license. This may be an issue with the player or your protected content.'\n      );\n      mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, data.fatal);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_UPDATE_LICENSE_FAILED;\n    } else if (data.details === Hls.ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED) {\n      const message = i18n(\n        'Your server certificate failed when attempting to set it. This may be an issue with a no longer valid certificate.'\n      );\n      mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, data.fatal);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_UPDATE_SERVER_CERT_FAILED;\n    } else if (data.details === Hls.ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR) {\n      const message = i18n(\n        'The DRM Content Decryption Module system had an internal failure. Try reloading the page, upading your browser, or playing in another browser.'\n      );\n      mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, data.fatal);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_CDM_ERROR;\n    } else if (data.details === Hls.ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED) {\n      const message = i18n(\n        'DRM playback is being attempted in an environment that is not sufficiently secure. User may see black screen.'\n      );\n      // NOTE: When encountered, this is a non-fatal error (though it's certainly interruptive of standard playback experience). (CJP)\n      mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, false);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_OUTPUT_RESTRICTED;\n    } else {\n      mediaError = new MediaError(data.error.message, MediaError.MEDIA_ERR_ENCRYPTED, data.fatal);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_ERROR;\n    }\n  } else {\n    mediaError = new MediaError('', errorCode, data.fatal);\n  }\n  if (!mediaError.context) {\n    mediaError.context =\n      `${data.url ? `url: ${data.url}\\n` : ''}` +\n      `${\n        data.response && (data.response.code || data.response.text)\n          ? `response: ${data.response.code}, ${data.response.text}\\n`\n          : ''\n      }` +\n      `${data.reason ? `failure reason: ${data.reason}\\n` : ''}` +\n      `${data.level ? `level: ${data.level}\\n` : ''}` +\n      `${data.parent ? `parent stream controller: ${data.parent}\\n` : ''}` +\n      `${data.buffer ? `buffer length: ${data.buffer}\\n` : ''}` +\n      `${data.error ? `error: ${data.error}\\n` : ''}` +\n      `${data.event ? `event: ${data.event}\\n` : ''}` +\n      `${data.err ? `error message: ${data.err?.message}\\n` : ''}`;\n  }\n  mediaError.data = data;\n  return mediaError;\n};\n","import Hls from 'hls.js';\nimport type HlsClassType from 'hls.js';\nexport default Hls;\nexport type HlsInterface = HlsClassType;\n","// Identifies what kind of request was made that resulted in an error\nexport const MuxErrorCategory = {\n  VIDEO: 'video',\n  THUMBNAIL: 'thumbnail',\n  STORYBOARD: 'storyboard',\n  DRM: 'drm',\n} as const;\n\nexport const MuxErrorCode = {\n  NOT_AN_ERROR: 0,\n  NETWORK_OFFLINE: 2000002,\n  NETWORK_UNKNOWN_ERROR: 2000000,\n  NETWORK_NO_STATUS: 2000001,\n  NETWORK_INVALID_URL: 2400000,\n  NETWORK_NOT_FOUND: 2404000,\n  NETWORK_NOT_READY: 2412000,\n  NETWORK_GENERIC_SERVER_FAIL: 2500000,\n  NETWORK_TOKEN_MISSING: 2403201,\n  NETWORK_TOKEN_MALFORMED: 2412202,\n  NETWORK_TOKEN_EXPIRED: 2403210,\n  NETWORK_TOKEN_AUD_MISSING: 2403221,\n  NETWORK_TOKEN_AUD_MISMATCH: 2403222,\n  NETWORK_TOKEN_SUB_MISMATCH: 2403232,\n  ENCRYPTED_ERROR: 5000000, // Generic\n  ENCRYPTED_UNSUPPORTED_KEY_SYSTEM: 5000001,\n  ENCRYPTED_GENERATE_REQUEST_FAILED: 5000002,\n  ENCRYPTED_UPDATE_LICENSE_FAILED: 5000003,\n  ENCRYPTED_UPDATE_SERVER_CERT_FAILED: 5000004,\n  ENCRYPTED_CDM_ERROR: 5000005,\n  ENCRYPTED_OUTPUT_RESTRICTED: 5000006,\n  ENCRYPTED_MISSING_TOKEN: 5000002,\n} as const;\n\nexport type MuxErrorCategory = typeof MuxErrorCategory;\nexport type MuxErrorCode = typeof MuxErrorCode;\n\nexport type MuxErrorCategoryValue = MuxErrorCategory[keyof MuxErrorCategory];\nexport type MuxErrorCodeValue = MuxErrorCode[keyof MuxErrorCode];\n\nexport const errorCategoryToTokenNameOrPrefix = (category: MuxErrorCategoryValue) => {\n  if (category === MuxErrorCategory.VIDEO) return 'playback';\n  return category;\n};\n\n// Typescript says it's strictly a string, but it can also be a number or an object with a toString method.\n// https://github.com/microsoft/TypeScript/issues/6032\n// https://262.ecma-international.org/6.0/#sec-error-message\n\ntype Stringable = string | { toString(): string };\n\ndeclare global {\n  interface ErrorConstructor {\n    new (message?: Stringable): Error;\n    (message?: Stringable): Error;\n    readonly prototype: Error;\n  }\n}\n\nexport class MediaError extends Error {\n  static MEDIA_ERR_ABORTED = 1 as const;\n  static MEDIA_ERR_NETWORK = 2 as const;\n  static MEDIA_ERR_DECODE = 3 as const;\n  static MEDIA_ERR_SRC_NOT_SUPPORTED = 4 as const;\n  static MEDIA_ERR_ENCRYPTED = 5 as const;\n  // @see https://docs.mux.com/guides/data/monitor-html5-video-element#customize-error-tracking-behavior\n  static MEDIA_ERR_CUSTOM = 100;\n\n  static defaultMessages: Record<number, string> = {\n    1: 'You aborted the media playback',\n    2: 'A network error caused the media download to fail.',\n    3: 'A media error caused playback to be aborted. The media could be corrupt or your browser does not support this format.',\n    4: 'An unsupported error occurred. The server or network failed, or your browser does not support this format.',\n    5: 'The media is encrypted and there are no keys to decrypt it.',\n  };\n\n  name: string;\n  code: number;\n  public muxCode?: MuxErrorCodeValue;\n  public errorCategory?: MuxErrorCategoryValue;\n  context?: string;\n  fatal: boolean;\n  data?: any;\n  streamType?: 'live' | 'on-demand' | 'unknown';\n\n  constructor(message?: Stringable, code: number = MediaError.MEDIA_ERR_CUSTOM, fatal?: boolean, context?: string) {\n    super(message);\n    this.name = 'MediaError';\n    this.code = code;\n    this.context = context;\n    this.fatal = fatal ?? (code >= MediaError.MEDIA_ERR_NETWORK && code <= MediaError.MEDIA_ERR_ENCRYPTED);\n\n    if (!this.message) {\n      this.message = MediaError.defaultMessages[this.code] ?? '';\n    }\n  }\n}\n","/* eslint @typescript-eslint/triple-slash-reference: \"off\" */\n/// <reference path=\"../../../node_modules/mux-embed/dist/types/mux-embed.d.ts\" preserve=\"true\" />\nimport type { Options, Mux } from 'mux-embed';\nimport type { MediaError } from './errors';\nimport type { HlsConfig } from 'hls.js';\nimport type Hls from 'hls.js';\n\ntype KeyTypes = string | number | symbol;\ntype Maybe<T> = T | null | undefined;\n\nconst isNil = (x: unknown): x is null | undefined => x == undefined;\n\n// Type Guard to determine if a given key is actually a key of some object of type T\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport const isKeyOf = <T extends {} = any>(k: KeyTypes, o: Maybe<T>): k is keyof T => {\n  if (isNil(o)) return false;\n  return k in o;\n};\n\nexport type ValueOf<T> = T[keyof T];\nexport type Metadata = Partial<Required<Options>['data']>;\ntype MetaData = Metadata;\nexport type PlaybackEngine = Hls;\nexport type MuxDataSDK = Mux;\n\nexport type PlaybackCore = {\n  engine?: PlaybackEngine;\n  muxDataSDK?: MuxDataSDK;\n  setAutoplay: (autoplay?: Autoplay) => void;\n  setPreload: (preload?: HTMLMediaElement['preload']) => void;\n};\n\n// TODO add INVIEW_MUTED, INVIEW_ANY\nexport type AutoplayTypes = {\n  ANY: 'any';\n  MUTED: 'muted';\n};\n\nexport const AutoplayTypes: AutoplayTypes = {\n  ANY: 'any',\n  MUTED: 'muted',\n};\n\nexport type Autoplay = boolean | ValueOf<AutoplayTypes>;\n\nexport type HlsPlaylistTypes = 'VOD' | 'EVENT' | null | undefined;\n\nexport type StreamTypes = {\n  ON_DEMAND: 'on-demand';\n  LIVE: 'live';\n  UNKNOWN: 'unknown';\n};\n\nexport const StreamTypes: StreamTypes = {\n  ON_DEMAND: 'on-demand',\n  LIVE: 'live',\n  UNKNOWN: 'unknown',\n};\n\nexport type PlaybackTypes = {\n  MSE: 'mse';\n  NATIVE: 'native';\n};\n\nexport const PlaybackTypes: PlaybackTypes = {\n  MSE: 'mse',\n  NATIVE: 'native',\n};\n\nexport type CmcdTypes = {\n  HEADER: 'header';\n  QUERY: 'query';\n  NONE: 'none';\n};\n\nexport const CmcdTypes: CmcdTypes = {\n  HEADER: 'header',\n  QUERY: 'query',\n  NONE: 'none',\n};\n\nexport const CmcdTypeValues = Object.values(CmcdTypes);\n\nexport type ExtensionMimeTypeMap = {\n  M3U8: 'application/vnd.apple.mpegurl';\n  MP4: 'video/mp4';\n};\n\nexport const ExtensionMimeTypeMap: ExtensionMimeTypeMap = {\n  M3U8: 'application/vnd.apple.mpegurl',\n  MP4: 'video/mp4',\n};\n\nexport type MimeTypeShorthandMap = {\n  HLS: ExtensionMimeTypeMap['M3U8'];\n};\n\nexport const MimeTypeShorthandMap: MimeTypeShorthandMap = {\n  HLS: ExtensionMimeTypeMap.M3U8,\n};\n\nexport const shorthandKeys = Object.keys(MimeTypeShorthandMap);\n\nexport type MediaTypes =\n  | ValueOf<ExtensionMimeTypeMap>\n  | keyof MimeTypeShorthandMap\n  /** @TODO Figure out a way to \"downgrade\" derived types below to early TS syntax (e.g. 3.4) instead of explicit versions here (CJP) */\n  | 'hls';\n// | `${Lowercase<keyof MimeTypeShorthandMap>}`\n// | `${Uppercase<keyof MimeTypeShorthandMap>}`;\n\nexport const allMediaTypes = [\n  ...(Object.values(ExtensionMimeTypeMap) as ValueOf<ExtensionMimeTypeMap>[]),\n  /** @TODO Figure out a way to \"downgrade\" derived types below to early TS syntax (e.g. 3.4) instead of explicit versions here (CJP) */\n  'hls',\n  'HLS',\n  // ...(shorthandKeys as (keyof MimeTypeShorthandMap)[]),\n  // ...(shorthandKeys.map((k) => k.toUpperCase()) as `${Uppercase<keyof MimeTypeShorthandMap>}`[]),\n  // ...(shorthandKeys.map((k) => k.toLowerCase()) as `${Lowercase<keyof MimeTypeShorthandMap>}`[]),\n] as MediaTypes[];\n\n// Both cuepoints and chapters have optional end times\n// so support both joined up and sparse cue placements\ntype CueLike<T = any> = {\n  startTime: number;\n  endTime?: number;\n  value: T;\n};\nexport type CuePoint<T = any> =\n  | CueLike<T> // new shape\n  | { time: number; value: T }; // legacy shape, still supported for now\nexport type Chapter = CueLike<string>;\n\nexport const MaxResolution = {\n  upTo720p: '720p',\n  upTo1080p: '1080p',\n  upTo1440p: '1440p',\n  upTo2160p: '2160p',\n} as const;\n\nexport const MinResolution = {\n  noLessThan480p: '480p',\n  noLessThan540p: '540p',\n  noLessThan720p: '720p',\n  noLessThan1080p: '1080p',\n  noLessThan1440p: '1440p',\n  noLessThan2160p: '2160p',\n} as const;\n\nexport const RenditionOrder = {\n  DESCENDING: 'desc',\n} as const;\n\nexport type MaxResolutionValue = ValueOf<typeof MaxResolution>;\nexport type MinResolutionValue = ValueOf<typeof MinResolution>;\nexport type RenditionOrderValue = ValueOf<typeof RenditionOrder>;\n\nexport type Tokens = {\n  playback?: string;\n  drm?: string;\n  thumbnail?: string;\n  storyboard?: string;\n};\n\nexport type MuxMediaPropTypes = {\n  _hlsConfig?: Partial<HlsConfig>;\n  autoPlay?: Autoplay;\n  autoplay?: Autoplay;\n  beaconCollectionDomain: Options['beaconCollectionDomain'];\n  customDomain: string;\n  debug: Options['debug'] & Hls['config']['debug'];\n  disableCookies: Options['disableCookies'];\n  disableTracking: boolean;\n  drmToken?: string;\n  playbackToken?: string;\n  envKey: MetaData['env_key'];\n  error?: HTMLMediaElement['error'] | MediaError;\n  errorTranslator: Options['errorTranslator'];\n  liveEdgeStart: number;\n  maxResolution: MaxResolutionValue;\n  metadata: Partial<Options['data']>;\n  minResolution: MinResolutionValue;\n  playbackId: string;\n  playerInitTime: MetaData['player_init_time'];\n  preferCmcd: ValueOf<CmcdTypes> | undefined;\n  preferPlayback: ValueOf<PlaybackTypes> | undefined;\n  programStartTime: number;\n  programEndTime: number;\n  assetStartTime: number;\n  assetEndTime: number;\n  renditionOrder: RenditionOrderValue;\n  startTime: Hls['config']['startPosition'];\n  streamType: ValueOf<StreamTypes>;\n  targetLiveWindow: number;\n  tokens: Tokens;\n  type: MediaTypes;\n  extraSourceParams: Record<string, any>;\n};\n\nexport type HTMLMediaElementProps = Partial<Pick<HTMLMediaElement, 'src' | 'preload' | 'error' | 'seekable'>>;\n\nexport type MuxMediaProps = HTMLMediaElementProps & MuxMediaPropTypes;\nexport type MuxMediaPropsInternal = MuxMediaProps & {\n  playerSoftwareName: MetaData['player_software_name'];\n  playerSoftwareVersion: MetaData['player_software_version'];\n  muxDataSDK?: Mux;\n  muxDataSDKOptions?: Mux;\n  muxDataKeepSession?: boolean;\n  drmTypeCb?: (drmType: Metadata['view_drm_type']) => void;\n};\n\n// TODO: Make these more uniform, remove bubbles, discuss to remove detail.\nexport type MuxMediaEventsMap = {\n  cuepointchange: CustomEvent<{ composed: true; bubbles: true; detail: CuePoint }>;\n  chapterchange: CustomEvent<{ composed: true; bubbles: true; detail: Chapter }>;\n  targetlivewindowchange: CustomEvent<{ composed: true; bubbles: true }>;\n  streamtypechange: CustomEvent<{ composed: true; bubbles: true }>;\n  seekablechange: CustomEvent<{ composed: true }>;\n  error: CustomEvent<{ detail: MediaError }>;\n};\n","const code = 'en'; export default { code }","import { isKeyOf, ExtensionMimeTypeMap, MimeTypeShorthandMap, StreamTypes } from './types';\nimport type { HlsPlaylistTypes, MuxMediaProps } from './types';\n// @ts-ignore\nimport lang from '../lang/en.json';\n\ntype addEventListenerWithTeardown = <\n  K extends keyof HTMLMediaElementEventMap,\n  T extends EventTarget = HTMLMediaElement,\n>(\n  mediaEl: HTMLMediaElement,\n  type: K,\n  listener: (this: T, ev: HTMLMediaElementEventMap[K]) => any,\n  options?: boolean | AddEventListenerOptions,\n  target?: T | HTMLMediaElement\n) => void;\n\n// Adds an event listener to a media element that will be removed when an 'teardown' event is dispatched.\n// Using this instead of 'emptied' as that can fire on initial load based on prior state of the media element\n// Will be fired as a result of (directly or indirectly) invoking playback-core's `teardown()` function.\nexport const addEventListenerWithTeardown: addEventListenerWithTeardown = (\n  mediaEl,\n  type,\n  listener,\n  options,\n  target = mediaEl\n) => {\n  /** @TODO fix types (hard problem due to lack of explicit relationship between Element and EventMap definitions) */\n  // @ts-ignore\n  target.addEventListener(type, listener, options);\n  // NOTE: Using custom teardown\n  mediaEl.addEventListener(\n    'teardown',\n    () => {\n      /** @TODO fix types (hard problem due to lack of explicit relationship between Element and EventMap definitions) */\n      // @ts-ignore\n      target.removeEventListener(type, listener);\n    },\n    { once: true }\n  );\n};\n\nexport function inSeekableRange(seekable: TimeRanges, duration: number, time: number) {\n  if (duration && time > duration) {\n    time = duration;\n  }\n  for (let i = 0; i < seekable.length; i++) {\n    if (seekable.start(i) <= time && seekable.end(i) >= time) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport const toPlaybackIdParts = (playbackIdWithOptionalParams: string): [string, string?] => {\n  const qIndex = playbackIdWithOptionalParams.indexOf('?');\n  if (qIndex < 0) return [playbackIdWithOptionalParams];\n  const idPart = playbackIdWithOptionalParams.slice(0, qIndex);\n  const queryPart = playbackIdWithOptionalParams.slice(qIndex);\n  return [idPart, queryPart];\n};\n\nexport const getType = (props: Partial<Pick<MuxMediaProps, 'type' | 'src' | 'customDomain'>>) => {\n  const { type } = props;\n  if (type) {\n    const upperType = type.toUpperCase();\n    return isKeyOf(upperType, MimeTypeShorthandMap) ? MimeTypeShorthandMap[upperType] : type;\n  }\n  return inferMimeTypeFromURL(props);\n};\n\nexport const toStreamTypeFromPlaylistType = (playlistType: HlsPlaylistTypes) => {\n  return playlistType === 'VOD' ? StreamTypes.ON_DEMAND : StreamTypes.LIVE;\n};\n\nexport const toTargetLiveWindowFromPlaylistType = (playlistType: HlsPlaylistTypes) => {\n  if (playlistType === 'EVENT') return Number.POSITIVE_INFINITY;\n  if (playlistType === 'VOD') return Number.NaN;\n  return 0;\n};\n\nexport const inferMimeTypeFromURL = (props: Partial<Pick<MuxMediaProps, 'src' | 'customDomain'>>) => {\n  const { src } = props;\n  if (!src) return '';\n\n  let pathname = '';\n  try {\n    pathname = new URL(src).pathname;\n  } catch (_e) {\n    console.error('invalid url');\n  }\n\n  const extDelimIdx = pathname.lastIndexOf('.');\n  if (extDelimIdx < 0) {\n    if (isExtensionLessMuxM3U8URL(props)) {\n      return ExtensionMimeTypeMap.M3U8; // Treat extension-less Mux URLs as HLS\n    }\n    return '';\n  }\n\n  const ext = pathname.slice(extDelimIdx + 1);\n  const upperExt = ext.toUpperCase();\n\n  return isKeyOf(upperExt, ExtensionMimeTypeMap) ? ExtensionMimeTypeMap[upperExt] : '';\n};\n\nconst MUX_VIDEO_DOMAIN = 'mux.com';\nexport const isExtensionLessMuxM3U8URL = ({\n  src,\n  customDomain = MUX_VIDEO_DOMAIN,\n}: Partial<Pick<MuxMediaProps, 'src' | 'customDomain'>>) => {\n  let urlObj;\n  try {\n    urlObj = new URL(`${src}`);\n  } catch {\n    return false;\n  }\n  const validProtocol = urlObj.protocol === 'https:';\n  const validHostname = urlObj.hostname === `stream.${customDomain}`.toLowerCase();\n  const pathParts = urlObj.pathname.split('/');\n  const validPathPartsLength = pathParts.length === 2;\n  const validExtensionlessPath = !pathParts?.[1].includes('.');\n  return validProtocol && validHostname && validPathPartsLength && validExtensionlessPath;\n};\n\nexport type MuxJWT = {\n  sub: string;\n  aud: 'v' | 't' | 'g' | 's' | 'd';\n  exp: number;\n};\n\nexport const parseJwt = (token: string | undefined): Partial<MuxJWT> | undefined => {\n  const base64Url = (token ?? '').split('.')[1];\n\n  // exit early on invalid value\n  if (!base64Url) return undefined;\n\n  // Account for malformed JWTs\n  try {\n    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n    const jsonPayload = decodeURIComponent(\n      atob(base64)\n        .split('')\n        .map(function (c) {\n          return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n        .join('')\n    );\n    return JSON.parse(jsonPayload);\n  } catch {\n    return undefined;\n  }\n};\n\nexport const isJWTExpired = ({ exp }: Partial<Pick<MuxJWT, 'exp'>>, referenceTime: number = Date.now()) => {\n  return !exp || exp * 1000 < referenceTime;\n};\n\n// NOTE: Treating missing sub (and expected sub) as mismatches for now (CJP)\nexport const isJWTSubMismatch = ({ sub }: Partial<Pick<MuxJWT, 'sub'>>, expectedSub: string | undefined) => {\n  return sub !== expectedSub;\n};\n\nexport const isJWTAudMissing = ({ aud }: Partial<Pick<MuxJWT, 'aud'>>, _expectedAud: string | undefined) => {\n  return !aud;\n};\n\nexport const isJWTAudMismatch = ({ aud }: Partial<Pick<MuxJWT, 'aud'>>, expectedAud: string | undefined) => {\n  return aud !== expectedAud;\n};\n\nconst DEFAULT_LOCALE = 'en';\n\n// NL example\n// lang = {\n//   \"Network Error\": \"Netwerk Fout\",\n// };\nexport function i18n(str: string, translate = true) {\n  const message = translate ? ((lang as unknown as any)?.[str] ?? str) : str;\n  const locale = translate ? (lang as unknown as any).code : DEFAULT_LOCALE;\n  return new IntlMessageFormat(message, locale);\n}\n\n/**\n * Poor man's IntlMessageFormat, enrich if need be.\n * @see https://formatjs.io/docs/intl-messageformat/\n */\nclass IntlMessageFormat {\n  message: string;\n  locale: string;\n\n  /** @TODO re-implement esbuild custom plugin for code usage (CJP) */\n  constructor(message: string, locale = (lang as unknown as any) ?? DEFAULT_LOCALE) {\n    this.message = message;\n    this.locale = locale;\n  }\n\n  format(values: Record<string, any>): string {\n    return this.message.replace(/\\{(\\w+)\\}/g, (_match, key) => {\n      return values[key] ?? '';\n    });\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n","import { addEventListenerWithTeardown } from './util';\nimport { ValueOf, Autoplay, AutoplayTypes, PlaybackEngine, MuxMediaPropsInternal, StreamTypes } from './types';\nimport Hls from './hls';\n\nconst AutoplayTypeValues = Object.values(AutoplayTypes);\nexport const isAutoplayValue = (value: unknown): value is Autoplay => {\n  return (\n    typeof value === 'boolean' ||\n    (typeof value === 'string' && AutoplayTypeValues.includes(value as ValueOf<AutoplayTypes>))\n  );\n};\n\n// Given a video element, will listen to lifecycle events to determine important\n// things like whether the video is live or whether the video has played\n// and then handles autoplaying the video as appropraite.\n// It works with both the native video element or hls.js.\n// This returns a method UpdateAutoplay, that allows the user to change\n// the value of the autoplay attribute and it will react appropriately.\nexport const setupAutoplay = (\n  props: Partial<MuxMediaPropsInternal>,\n  mediaEl: HTMLMediaElement,\n  hls?: PlaybackEngine\n) => {\n  const { autoplay: maybeAutoplay } = props;\n  let hasPlayed = false;\n  let isLive = false;\n  let autoplay: Autoplay = isAutoplayValue(maybeAutoplay) ? maybeAutoplay : !!maybeAutoplay;\n\n  const updateHasPlayed = () => {\n    // hasPlayed\n\n    if (!hasPlayed) {\n      addEventListenerWithTeardown(\n        mediaEl,\n        'playing',\n        () => {\n          hasPlayed = true;\n        },\n        { once: true }\n      );\n    }\n  };\n\n  updateHasPlayed();\n\n  // on `loadstart`\n  // hasPlayed should default to false\n  // we should try and autoplay\n  addEventListenerWithTeardown(\n    mediaEl,\n    'loadstart',\n    () => {\n      hasPlayed = false;\n      updateHasPlayed();\n      handleAutoplay(mediaEl, autoplay);\n    },\n    { once: true }\n  );\n\n  // on `loadedmetadata` we can check whether we're live in the case of native playback\n  addEventListenerWithTeardown(\n    mediaEl,\n    'loadstart',\n    () => {\n      // only update isLive here if we're using native playback\n      if (!hls) {\n        // defer to streamType if set (including inferred)\n        if (props.streamType && props.streamType !== StreamTypes.UNKNOWN) {\n          isLive = props.streamType === StreamTypes.LIVE;\n        } else {\n          isLive = !Number.isFinite(mediaEl.duration);\n        }\n      }\n      handleAutoplay(mediaEl, autoplay);\n    },\n    { once: true }\n  );\n\n  // determine if we're live for hls.js\n  if (hls) {\n    hls.once(Hls.Events.LEVEL_LOADED, (_event: any, data: any) => {\n      // defer to streamType if set (including inferred)\n      if (props.streamType && props.streamType !== StreamTypes.UNKNOWN) {\n        isLive = props.streamType === StreamTypes.LIVE;\n      } else {\n        isLive = data.details.live ?? false;\n      }\n    });\n  }\n\n  // When we are not auto-playing, we should seek to the live sync position\n  // This will seek first play event of *any* live video including event-type,\n  // which probably shouldn't seek\n  if (!autoplay) {\n    const handleSeek = () => {\n      // don't seek if we're not live or if a `startTime` has been explicitly set\n      if (!isLive || Number.isFinite(props.startTime)) {\n        return;\n      }\n      // seek to either hls.js's liveSyncPosition or the native seekable end\n      if (hls?.liveSyncPosition) {\n        mediaEl.currentTime = hls.liveSyncPosition;\n      } else {\n        if (Number.isFinite(mediaEl.seekable.end(0))) {\n          mediaEl.currentTime = mediaEl.seekable.end(0);\n        }\n      }\n    };\n    if (hls) {\n      addEventListenerWithTeardown(\n        mediaEl,\n        'play',\n        () => {\n          if (mediaEl.preload === 'metadata') {\n            hls.once(Hls.Events.LEVEL_UPDATED, handleSeek);\n          } else {\n            handleSeek();\n          }\n        },\n        { once: true }\n      );\n    }\n  }\n\n  // this method allows us to update the value of autoplay\n  // and try autoplaying appropriately.\n  const updateAutoplay = (newAutoplay?: Autoplay) => {\n    if (!hasPlayed) {\n      autoplay = isAutoplayValue(newAutoplay) ? newAutoplay : !!newAutoplay;\n      handleAutoplay(mediaEl, autoplay);\n    }\n  };\n\n  return updateAutoplay;\n};\n\nexport const handleAutoplay = (mediaEl: HTMLMediaElement, autoplay: Autoplay) => {\n  if (!autoplay) {\n    return;\n  }\n\n  const oldMuted = mediaEl.muted;\n  const restoreMuted = () => (mediaEl.muted = oldMuted);\n\n  switch (autoplay) {\n    // ANY:\n    // try to play with current options\n    // if it fails, mute and try playing again\n    // if that fails, restore muted state and don't try playing again\n    case AutoplayTypes.ANY:\n      mediaEl.play().catch(() => {\n        mediaEl.muted = true;\n        mediaEl.play().catch(restoreMuted);\n      });\n      break;\n\n    // MUTED:\n    // mute the player and then try playing\n    // if that fails, restore muted state\n    case AutoplayTypes.MUTED:\n      mediaEl.muted = true;\n      mediaEl.play().catch(restoreMuted);\n      break;\n\n    // Default or if autoplay is a boolean attribute:\n    // Try playing the video and catch the failed autoplay warning\n    default: // eslint-disable-next-line\n      mediaEl.play().catch(() => {});\n      break;\n  }\n};\n","import { addEventListenerWithTeardown } from './util';\nimport { PlaybackEngine } from './types';\n\nexport const setupPreload = (\n  { preload, src }: Partial<HTMLMediaElement>,\n  mediaEl: HTMLMediaElement,\n  hls?: PlaybackEngine\n) => {\n  const updatePreload = (val?: HTMLMediaElement['preload']) => {\n    if (val != null && ['', 'none', 'metadata', 'auto'].includes(val)) {\n      mediaEl.setAttribute('preload', val);\n    } else {\n      mediaEl.removeAttribute('preload');\n    }\n  };\n\n  // handle native without hls.js (MSE)\n  if (!hls) {\n    updatePreload(preload);\n    return updatePreload;\n  }\n\n  let hasLoadedSource = false;\n  let hasPlayFired = false;\n\n  const originalLength = hls.config.maxBufferLength;\n  const originalSize = hls.config.maxBufferSize;\n\n  const updateHlsPreload = (val?: HTMLMediaElement['preload']) => {\n    // even if it doesn't have an effect on a <video> w/ MSE\n    // still update the `preload` attribute.\n    updatePreload(val);\n\n    const newPreload = val ?? mediaEl.preload;\n    if (hasPlayFired || newPreload === 'none') return;\n    if (newPreload === 'metadata') {\n      // load the least amount of data possible\n      hls.config.maxBufferLength = 1;\n      hls.config.maxBufferSize = 1;\n    } else {\n      hls.config.maxBufferLength = originalLength;\n      hls.config.maxBufferSize = originalSize;\n    }\n\n    safeLoadSource();\n  };\n\n  const safeLoadSource = () => {\n    if (!hasLoadedSource && src) {\n      hasLoadedSource = true;\n      hls.loadSource(src);\n    }\n  };\n\n  addEventListenerWithTeardown(\n    mediaEl,\n    'play',\n    () => {\n      hasPlayFired = true;\n\n      // once a user has played, allow for it to load data as normal\n      hls.config.maxBufferLength = originalLength;\n      hls.config.maxBufferSize = originalSize;\n\n      // load the source on first play if needed\n      safeLoadSource();\n    },\n    { once: true }\n  );\n\n  updateHlsPreload(preload);\n\n  return updateHlsPreload;\n};\n","import Hls from './hls';\n\nexport function setupMediaTracks(\n  customMediaEl: HTMLMediaElement,\n  hls: Pick<\n    Hls,\n    'audioTrack' | 'audioTracks' | 'autoLevelEnabled' | 'nextLevel' | 'levels' | 'on' | 'once' | 'off' | 'trigger'\n  >\n) {\n  if (!('videoTracks' in customMediaEl)) return;\n\n  // Create a map to save the unique id's we create for each level and rendition.\n  // hls.js uses the levels array index primarily but we'll use the id to have a\n  // 1 to 1 relation from rendition to level.\n  const levelIdMap = new WeakMap();\n\n  hls.on(Hls.Events.MANIFEST_PARSED, function (_event, data) {\n    removeAllMediaTracks();\n\n    const videoTrack = customMediaEl.addVideoTrack('main');\n    videoTrack.selected = true;\n\n    for (const [id, level] of data.levels.entries()) {\n      const videoRendition = videoTrack.addRendition(\n        level.url[0],\n        level.width,\n        level.height,\n        level.videoCodec,\n        level.bitrate\n      );\n\n      // The returned levels all have an id of `0`, save the id in a WeakMap.\n      levelIdMap.set(level, `${id}`);\n      videoRendition.id = `${id}`;\n    }\n  });\n\n  hls.on(Hls.Events.AUDIO_TRACKS_UPDATED, function (_event, data) {\n    removeAudioTracks();\n\n    for (const a of data.audioTracks) {\n      // hls.js doesn't return a `kind` property for audio tracks yet.\n      const kind = a.default ? 'main' : 'alternative';\n      const audioTrack = customMediaEl.addAudioTrack(kind, a.name, a.lang);\n      audioTrack.id = `${a.id}`;\n\n      if (a.default) {\n        audioTrack.enabled = true;\n      }\n    }\n  });\n\n  customMediaEl.audioTracks.addEventListener('change', () => {\n    // Cast to number, hls.js uses numeric id's.\n    const audioTrackId = +[...customMediaEl.audioTracks].find((t) => t.enabled)?.id;\n    const availableIds = hls.audioTracks.map((t) => t.id);\n    if (audioTrackId != hls.audioTrack && availableIds.includes(audioTrackId)) {\n      hls.audioTrack = audioTrackId;\n    }\n  });\n\n  // Fired when a level is removed after calling `removeLevel()`\n  hls.on(Hls.Events.LEVELS_UPDATED, function (_event, data) {\n    const videoTrack = customMediaEl.videoTracks[customMediaEl.videoTracks.selectedIndex ?? 0];\n    if (!videoTrack) return;\n\n    const levelIds: string[] = data.levels.map((l) => levelIdMap.get(l));\n\n    for (const rendition of customMediaEl.videoRenditions) {\n      if (rendition.id && !levelIds.includes(rendition.id)) {\n        videoTrack.removeRendition(rendition);\n      }\n    }\n  });\n\n  // hls.js doesn't support enabling multiple renditions.\n  //\n  // 1. if all renditions are enabled it's auto selection.\n  // 2. if 1 of the renditions is disabled we assume a selection was made\n  //    and lock it to the first rendition that is enabled.\n  const switchRendition = (event: Event) => {\n    // @ts-ignore\n    const level = event.target.selectedIndex as number;\n    if (level != hls.nextLevel) {\n      hls.nextLevel = level;\n    }\n  };\n\n  customMediaEl.videoRenditions?.addEventListener('change', switchRendition);\n\n  const removeVideoTracks = () => {\n    for (const videoTrack of customMediaEl.videoTracks) {\n      customMediaEl.removeVideoTrack(videoTrack);\n    }\n  };\n\n  const removeAudioTracks = () => {\n    for (const audioTrack of customMediaEl.audioTracks) {\n      customMediaEl.removeAudioTrack(audioTrack);\n    }\n  };\n\n  const removeAllMediaTracks = () => {\n    removeVideoTracks();\n    removeAudioTracks();\n  };\n\n  // NOTE: Since this is only relevant for hls, using destroying event (CJP).\n  hls.once(Hls.Events.DESTROYING, removeAllMediaTracks);\n}\n","import Hls from './hls';\nimport { CuePoint, Chapter } from './types';\nimport { addEventListenerWithTeardown } from './util';\n\ntype Config = { label: string };\n\n// Shared utils\n\n// Extracts the start time from a cuepoint, considering legacy \"time\" prop\nconst cuePointStart = (cuePoint: CuePoint): number => {\n  if ('time' in cuePoint) {\n    return cuePoint.time;\n  }\n  return cuePoint.startTime;\n};\n\nexport function setupTextTracks(\n  mediaEl: HTMLMediaElement,\n  hls: Pick<Hls, 'on' | 'once' | 'subtitleTracks' | 'subtitleTrack'>\n) {\n  hls.on(Hls.Events.NON_NATIVE_TEXT_TRACKS_FOUND, (_type, { tracks }) => {\n    tracks.forEach((trackObj) => {\n      const baseTrackObj = trackObj.subtitleTrack ?? trackObj.closedCaptions;\n      const idx = hls.subtitleTracks.findIndex(({ lang, name, type }) => {\n        return lang == baseTrackObj?.lang && name === trackObj.label && type.toLowerCase() === trackObj.kind;\n      });\n\n      // NOTE: Undocumented method for determining identifier by hls.js. Relied on for\n      // ensuring CUES_PARSED events can identify and apply cues to the appropriate track (CJP).\n      // See: https://github.com/video-dev/hls.js/blob/master/src/controller/timeline-controller.ts#L640\n      const id = trackObj._id ?? trackObj.default ? 'default' : `${trackObj.kind}${idx}`;\n\n      addTextTrack(mediaEl, trackObj.kind as TextTrackKind, trackObj.label, baseTrackObj?.lang, id, trackObj.default);\n    });\n  });\n\n  const changeHandler = () => {\n    if (!hls.subtitleTracks.length) return;\n\n    const showingTrack = Array.from(mediaEl.textTracks).find((textTrack) => {\n      return textTrack.id && textTrack.mode === 'showing' && ['subtitles', 'captions'].includes(textTrack.kind);\n    });\n\n    if (!showingTrack) return;\n\n    const currentHlsTrack = hls.subtitleTracks[hls.subtitleTrack];\n\n    // If hls.subtitleTrack is -1 or its id changed compared to the one that is showing load the new subtitle track.\n    const hlsTrackId = !currentHlsTrack\n      ? undefined\n      : currentHlsTrack.default\n        ? 'default'\n        : `${hls.subtitleTracks[hls.subtitleTrack].type.toLowerCase()}${hls.subtitleTrack}`;\n\n    if (hls.subtitleTrack < 0 || showingTrack?.id !== hlsTrackId) {\n      const idx = hls.subtitleTracks.findIndex(({ lang, name, type, default: defaultTrack }) => {\n        return (\n          (showingTrack.id === 'default' && defaultTrack) ||\n          (lang == showingTrack.language && name === showingTrack.label && type.toLowerCase() === showingTrack.kind)\n        );\n      });\n      // After the subtitleTrack is set here, hls.js will load the playlist and CUES_PARSED events will be fired below.\n      hls.subtitleTrack = idx;\n    }\n\n    if (showingTrack?.id === hlsTrackId) {\n      // Refresh the cues after a texttrack mode change to fix a Chrome bug causing the captions not to render.\n      if (showingTrack.cues) {\n        Array.from(showingTrack.cues).forEach((cue) => {\n          showingTrack.addCue(cue);\n        });\n      }\n    }\n  };\n\n  mediaEl.textTracks.addEventListener('change', changeHandler);\n\n  hls.on(Hls.Events.CUES_PARSED, (_type, { track, cues }) => {\n    const textTrack = mediaEl.textTracks.getTrackById(track);\n    if (!textTrack) return;\n\n    const disabled = textTrack.mode === 'disabled';\n    if (disabled) {\n      textTrack.mode = 'hidden';\n    }\n\n    cues.forEach((cue: VTTCue) => {\n      if (textTrack.cues?.getCueById(cue.id)) return;\n      textTrack.addCue(cue);\n    });\n\n    if (disabled) {\n      textTrack.mode = 'disabled';\n    }\n  });\n\n  // NOTE: Since this is only relevant for hls, using destroying event (CJP).\n  hls.once(Hls.Events.DESTROYING, () => {\n    mediaEl.textTracks.removeEventListener('change', changeHandler);\n    // Use data attribute to identify tracks that should be removed when switching sources/destroying hls.js instance.\n    const trackEls: NodeListOf<HTMLTrackElement> = mediaEl.querySelectorAll('track[data-removeondestroy]');\n    trackEls.forEach((trackEl) => {\n      trackEl.remove();\n    });\n  });\n\n  const forceHiddenTracks = () => {\n    // Keeping this a forEach in case we want to expand the scope of this.\n    Array.from(mediaEl.textTracks).forEach((track) => {\n      if (['subtitles', 'caption'].includes(track.kind)) return;\n      if (!(track.label === 'thumbnails' || track.kind === 'chapters')) return;\n      if (!track.cues?.length) {\n        let selector = 'track';\n        if (track.kind) selector += `[kind=\"${track.kind}\"]`;\n        if (track.label) selector += `[label=\"${track.label}\"]`;\n        const trackEl = mediaEl.querySelector(selector);\n        // Force a reload of the cues if they've been removed\n        const src = trackEl?.getAttribute('src') ?? '';\n        trackEl?.removeAttribute('src');\n        setTimeout(() => {\n          trackEl?.setAttribute('src', src);\n        }, 0);\n      }\n      // Force hidden mode if it's not hidden\n      if (track.mode !== 'hidden') {\n        track.mode = 'hidden';\n      }\n    });\n  };\n\n  // hls.js will forcibly clear all cues from tracks on manifest loads or media attaches.\n  // This ensures that we re-load them after it's done that.\n  hls.once(Hls.Events.MANIFEST_LOADED, forceHiddenTracks);\n  hls.once(Hls.Events.MEDIA_ATTACHED, forceHiddenTracks);\n}\n\nexport function addTextTrack(\n  mediaEl: HTMLMediaElement,\n  kind: TextTrackKind,\n  label: string,\n  lang?: string,\n  id?: string,\n  defaultTrack?: boolean\n): TextTrack {\n  const trackEl = document.createElement('track');\n  trackEl.kind = kind;\n  trackEl.label = label;\n  if (lang) {\n    // This attribute must be present if the element's kind attribute is in the subtitles state.\n    trackEl.srclang = lang;\n  }\n  if (id) {\n    trackEl.id = id;\n  }\n  if (!!defaultTrack) {\n    trackEl.default = true;\n  }\n  trackEl.track.mode = ['subtitles', 'captions'].includes(kind) ? 'disabled' : 'hidden';\n\n  // Add data attribute to identify tracks that should be removed when switching sources/destroying hls.js instance.\n  trackEl.setAttribute('data-removeondestroy', '');\n  mediaEl.append(trackEl);\n\n  return trackEl.track as TextTrack;\n}\n\nexport function removeTextTrack(mediaEl: HTMLMediaElement, track: TextTrack) {\n  const trackElement: HTMLTrackElement | undefined = Array.prototype.find.call(\n    mediaEl.querySelectorAll('track'),\n    (trackEl: HTMLTrackElement) => trackEl.track === track\n  );\n  trackElement?.remove();\n}\n\nexport function getTextTrack(mediaEl: HTMLMediaElement, label: string, kind: TextTrackKind) {\n  return Array.from(mediaEl.querySelectorAll('track')).find((trackEl) => {\n    return trackEl.track.label === label && trackEl.track.kind === kind;\n  })?.track;\n}\n\nexport async function addCuesToTextTrack<T = any>(\n  mediaEl: HTMLMediaElement,\n  cues: CuePoint<T>[] | Chapter[],\n  label: string,\n  kind: TextTrackKind\n) {\n  // If the track has already been created/added, use it.\n  let track = getTextTrack(mediaEl, label, kind);\n  if (!track) {\n    // Otherwise, create a new one\n    track = addTextTrack(mediaEl, kind, label);\n    track.mode = 'hidden';\n    // Wait a tick before providing a newly created track. Otherwise e.g. cues disappear when using track.addCue().\n    await new Promise((resolve) => setTimeout(() => resolve(undefined), 0));\n  }\n\n  if (track.mode !== 'hidden') {\n    track.mode = 'hidden';\n  }\n\n  // Copy cuePoints to ensure sort is not mutative\n  [...cues]\n    // Sort descending to ensure last cuepoints are added as cues first. This is done\n    // so the track's cue's can be used for reference when determining an appropriate\n    // endTime, allowing support of multiple invocations of addCuePoints\n    .sort((cuePointA, cuePointB) => cuePointStart(cuePointB) - cuePointStart(cuePointA))\n    .forEach((cuePoint) => {\n      const value = cuePoint.value;\n      const startTime = cuePointStart(cuePoint);\n\n      if ('endTime' in cuePoint && cuePoint.endTime != undefined) {\n        track?.addCue(\n          new VTTCue(\n            startTime,\n            cuePoint.endTime,\n            kind === 'chapters' ? (value as string) : JSON.stringify(value ?? null)\n          )\n        );\n      } else {\n        // find the cue that starts immediately after the cuePoint's time\n        const cueAfterIndex = Array.prototype.findIndex.call(track?.cues, (cue) => cue.startTime >= startTime);\n        const cueAfter = track?.cues?.[cueAfterIndex];\n        const endTime = cueAfter\n          ? cueAfter.startTime\n          : Number.isFinite(mediaEl.duration)\n            ? mediaEl.duration\n            : Number.MAX_SAFE_INTEGER;\n\n        // Adjust the endTime of the already added previous cue,\n        // if present, so it does not overlap with the newly added cue.\n        const previousCue = track?.cues?.[cueAfterIndex - 1];\n        if (previousCue) {\n          previousCue.endTime = startTime;\n        }\n        track?.addCue(\n          new VTTCue(startTime, endTime, kind === 'chapters' ? (value as string) : JSON.stringify(value ?? null))\n        );\n      }\n    });\n\n  // NOTE: this doesn't naturally fire when we update the list\n  // of cue points (without changing the active cue). We manually\n  // fire this to force the state manager to reflect the new change\n  mediaEl.textTracks.dispatchEvent(\n    new Event('change', {\n      bubbles: true,\n      composed: true,\n    })\n  );\n\n  return track;\n}\n\n// Cuepoints\n\nconst DEFAULT_CUEPOINTS_TRACK_LABEL = 'cuepoints';\nexport const DefaultCuePointsConfig: Config = Object.freeze({ label: DEFAULT_CUEPOINTS_TRACK_LABEL });\n\nexport async function addCuePoints<T>(\n  mediaEl: HTMLMediaElement,\n  cuePoints: CuePoint<T>[],\n  cuePointsConfig: Config = DefaultCuePointsConfig\n) {\n  return addCuesToTextTrack(mediaEl, cuePoints, cuePointsConfig.label, 'metadata');\n}\n\nconst toCuePoint = (cue: VTTCue) => ({\n  time: cue.startTime,\n  value: JSON.parse(cue.text),\n});\n\nexport function getCuePoints(\n  mediaEl: HTMLMediaElement,\n  cuePointsConfig: Config = { label: DEFAULT_CUEPOINTS_TRACK_LABEL }\n) {\n  const track = getTextTrack(mediaEl, cuePointsConfig.label, 'metadata');\n  if (!track?.cues) return [];\n  return Array.from(track.cues, (cue) => toCuePoint(cue as VTTCue));\n}\n\nexport function getActiveCuePoint(\n  mediaEl: HTMLMediaElement,\n  cuePointsConfig: Config = { label: DEFAULT_CUEPOINTS_TRACK_LABEL }\n) {\n  const track = getTextTrack(mediaEl, cuePointsConfig.label, 'metadata');\n  if (!track?.activeCues?.length) return undefined;\n  if (track.activeCues.length === 1) return toCuePoint(track.activeCues[0] as VTTCue);\n  // NOTE: There is a bug in Chromium where there may be \"lingering activeCues\" even\n  // after the playhead is no longer within their [startTime, endTime) bounds. This\n  // accounts for those cases (CJP)\n  const { currentTime } = mediaEl;\n  const actualActiveCue = Array.prototype.find.call(track.activeCues ?? [], ({ startTime, endTime }) => {\n    return startTime <= currentTime && endTime > currentTime;\n  }) as VTTCue | undefined;\n  if (!actualActiveCue) {\n    return toCuePoint(track.activeCues[0] as VTTCue);\n  }\n  return toCuePoint(actualActiveCue);\n}\n\nexport async function setupCuePoints(mediaEl: HTMLMediaElement, cuePointsConfig: Config = DefaultCuePointsConfig) {\n  return new Promise((resolve) => {\n    addEventListenerWithTeardown(mediaEl, 'loadstart', async () => {\n      const track = await addCuePoints(mediaEl, [], cuePointsConfig);\n      addEventListenerWithTeardown(\n        mediaEl,\n        'cuechange',\n        () => {\n          const activeCuePoint = getActiveCuePoint(mediaEl);\n          if (activeCuePoint) {\n            const evt = new CustomEvent('cuepointchange', {\n              composed: true,\n              bubbles: true,\n              detail: activeCuePoint,\n            });\n            mediaEl.dispatchEvent(evt);\n          }\n        },\n        {},\n        track\n      );\n      resolve(track);\n    });\n  });\n}\n\n/**\n * Chapters\n */\n\nconst DEFAULT_CHAPTERS_TRACK_LABEL = 'chapters';\nexport const DefaultChaptersConfig: Config = Object.freeze({ label: DEFAULT_CHAPTERS_TRACK_LABEL });\n\nconst vttCueToChapter = (cue: VTTCue) => ({\n  startTime: cue.startTime,\n  endTime: cue.endTime,\n  value: cue.text,\n});\n\nexport async function addChapters(\n  mediaEl: HTMLMediaElement,\n  chapters: Chapter[],\n  chaptersConfig: Config = DefaultChaptersConfig\n) {\n  return addCuesToTextTrack(mediaEl, chapters, chaptersConfig.label, 'chapters');\n}\n\nexport function getChapters(\n  mediaEl: HTMLMediaElement,\n  chaptersConfig: Config = { label: DEFAULT_CHAPTERS_TRACK_LABEL }\n) {\n  const track = getTextTrack(mediaEl, chaptersConfig.label, 'chapters');\n  if (!track?.cues?.length) return [];\n  return Array.from(track.cues, (cue) => vttCueToChapter(cue as VTTCue));\n}\n\nexport function getActiveChapter(\n  mediaEl: HTMLMediaElement,\n  chaptersConfig: Config = { label: DEFAULT_CHAPTERS_TRACK_LABEL }\n) {\n  const track = getTextTrack(mediaEl, chaptersConfig.label, 'chapters');\n  if (!track?.activeCues?.length) return undefined;\n  if (track.activeCues.length === 1) return vttCueToChapter(track.activeCues[0] as VTTCue);\n  // NOTE: There is a bug in Chromium where there may be \"lingering activeCues\" even\n  // after the playhead is no longer within their [startTime, endTime) bounds. This\n  // accounts for those cases (CJP)\n  const { currentTime } = mediaEl;\n  const actualActiveCue = Array.prototype.find.call(track.activeCues ?? [], ({ startTime, endTime }) => {\n    return startTime <= currentTime && endTime > currentTime;\n  }) as VTTCue | undefined;\n  if (!actualActiveCue) {\n    return vttCueToChapter(track.activeCues[0] as VTTCue);\n  }\n  return vttCueToChapter(actualActiveCue);\n}\n\nexport async function setupChapters(mediaEl: HTMLMediaElement, chaptersConfig: Config = DefaultChaptersConfig) {\n  return new Promise((resolve) => {\n    addEventListenerWithTeardown(mediaEl, 'loadstart', async () => {\n      const track = await addChapters(mediaEl, [], chaptersConfig);\n\n      addEventListenerWithTeardown(\n        mediaEl,\n        'cuechange',\n        () => {\n          const activeCuePoint = getActiveChapter(mediaEl);\n          if (activeCuePoint) {\n            const evt = new CustomEvent('chapterchange', {\n              composed: true,\n              bubbles: true,\n              detail: activeCuePoint,\n            });\n            mediaEl.dispatchEvent(evt);\n          }\n        },\n        {},\n        track\n      );\n\n      resolve(track);\n    });\n  });\n}\n","import { PlaybackEngine } from './types';\n\ntype MediaWithPDT = HTMLMediaElement & { getStartDate?: () => Date };\n\nexport function getStartDate(mediaEl: MediaWithPDT, hls: PlaybackEngine | undefined) {\n  if (hls) {\n    const playingDate = hls.playingDate;\n\n    if (playingDate != null) {\n      // If the video is very long and the currentTime will transition day boundaries,\n      // this may end up not being accurate\n      return new Date(playingDate.getTime() - mediaEl.currentTime * 1000);\n    }\n  }\n\n  if (typeof mediaEl.getStartDate === 'function') {\n    return mediaEl.getStartDate();\n  }\n\n  return new Date(NaN);\n}\n\nexport function getCurrentPdt(mediaEl: MediaWithPDT, hls: PlaybackEngine | undefined) {\n  if (hls && hls.playingDate) {\n    return hls.playingDate;\n  }\n\n  if (typeof mediaEl.getStartDate === 'function') {\n    const startDate = mediaEl.getStartDate();\n\n    // If the video is very long and the currentTime will transition day boundaries,\n    // this may end up not being accurate\n    return new Date(startDate.getTime() + mediaEl.currentTime * 1000);\n  }\n\n  return new Date(NaN);\n}\n","import type { LoaderResponse } from 'hls.js';\nimport {\n  i18n,\n  isJWTAudMismatch,\n  isJWTAudMissing,\n  isJWTExpired,\n  isJWTSubMismatch,\n  parseJwt,\n  toPlaybackIdParts,\n} from './util';\nimport { isKeyOf, MuxMediaPropsInternal, StreamTypes } from './types';\nimport type { MuxErrorCategoryValue } from './errors';\nimport { errorCategoryToTokenNameOrPrefix, MediaError, MuxErrorCategory, MuxErrorCode } from './errors';\n\nexport const MuxJWTAud = {\n  VIDEO: 'v',\n  // NOTE: These are not \"built in\" for mux-video/mux-audio (only mux-player) (CJP)\n  THUMBNAIL: 't',\n  STORYBOARD: 's',\n  // GIF: 'g', // currently unused\n  DRM: 'd',\n} as const;\n\nexport const categoryToAud = (category: MuxErrorCategoryValue) => {\n  if (category === MuxErrorCategory.VIDEO) return MuxJWTAud.VIDEO;\n  if (category === MuxErrorCategory.DRM) return MuxJWTAud.DRM;\n};\n\nexport const categoryToToken = (\n  category: MuxErrorCategoryValue,\n  muxMediaEl: Partial<Pick<MuxMediaPropsInternal, 'drmToken' | 'playbackToken' | 'tokens'>>\n) => {\n  const nameOrPrefix = errorCategoryToTokenNameOrPrefix(category);\n  const tokenName = `${nameOrPrefix}Token` as const;\n  if (muxMediaEl.tokens?.[nameOrPrefix]) return muxMediaEl.tokens?.[nameOrPrefix];\n  return isKeyOf(tokenName, muxMediaEl) ? muxMediaEl[tokenName] : undefined;\n};\n\nexport const getErrorFromResponse = (\n  resp: Pick<Response, 'status' | 'url'> | Pick<LoaderResponse, 'code' | 'url'>,\n  category: MuxErrorCategoryValue,\n  muxMediaEl: Partial<\n    Pick<MuxMediaPropsInternal, 'playbackId' | 'drmToken' | 'playbackToken' | 'tokens' | 'streamType'>\n  >,\n  fatal?: boolean,\n  translate = false,\n  offline = !globalThis.navigator?.onLine // NOTE: Passing this in for testing purposes\n) => {\n  if (offline) {\n    const message = i18n(`Your device appears to be offline`, translate);\n    const context = undefined;\n    const mediaErrorCode = MediaError.MEDIA_ERR_NETWORK;\n    // Being offline is not immediately a fatal error for playback.\n    const mediaError = new MediaError(message, mediaErrorCode, false, context);\n    mediaError.errorCategory = category;\n    mediaError.muxCode = MuxErrorCode.NETWORK_OFFLINE;\n    mediaError.data = resp;\n    return mediaError;\n  }\n  const status = 'status' in resp ? resp.status : resp.code;\n  const requestTime = Date.now();\n  const mediaErrorCode = MediaError.MEDIA_ERR_NETWORK;\n  // Not an error. WHAT ARE YOU EVEN DOING HERE?!?\n  if (status === 200) return undefined;\n  const tokenNamePrefix = errorCategoryToTokenNameOrPrefix(category);\n  const token = categoryToToken(category, muxMediaEl);\n  const expectedAud = categoryToAud(category);\n  const [playbackId] = toPlaybackIdParts(muxMediaEl.playbackId ?? '');\n  // NOTE: *should* have playback id when reaching here\n  // if (!status) return MuxErrorCode.NETWORK_NO_STATUS;\n  if (!status || !playbackId) return undefined;\n\n  const jwtObj = parseJwt(token);\n  // Make sure we didn't get here because of a malformed JWT and/or claim\n  if (!!token && !jwtObj) {\n    // 403 for DRM\n    const message = i18n(`The {tokenNamePrefix}-token provided is invalid or malformed.`, translate).format({\n      tokenNamePrefix,\n    });\n    const context = i18n(`Compact JWT string: {token}`, translate).format({\n      token,\n    });\n    const mediaError = new MediaError(message, mediaErrorCode, true, context);\n    mediaError.errorCategory = category;\n    mediaError.muxCode = MuxErrorCode.NETWORK_TOKEN_MALFORMED;\n    mediaError.data = resp;\n    return mediaError;\n  }\n\n  if (status >= 500) {\n    /**\n     * @TODO We plausibly should have some basic retry logic for all other 500 status\n     * cases (CJP)\n     **/\n    const mediaError = new MediaError('', mediaErrorCode, fatal ?? true);\n    mediaError.errorCategory = category;\n    mediaError.muxCode = MuxErrorCode.NETWORK_UNKNOWN_ERROR;\n    /** @TODO Add error msg + context crud here (NOT YET DEFINED) (CJP) */\n    return mediaError;\n  }\n\n  if (status === 403) {\n    if (jwtObj) {\n      if (isJWTExpired(jwtObj, requestTime)) {\n        const dateOptions: any = {\n          timeStyle: 'medium',\n          dateStyle: 'medium',\n        };\n        // E.g. for DRM: \"The video’s secured drm-token has expired.\"\n        // E.g. for Video: \"The video’s secured playback-token has expired.\"\n        const message = i18n(`The video’s secured {tokenNamePrefix}-token has expired.`, translate).format({\n          tokenNamePrefix,\n        });\n        const context = i18n(`Expired at: {expiredDate}. Current time: {currentDate}.`, translate).format({\n          expiredDate: new Intl.DateTimeFormat('en', dateOptions).format(jwtObj.exp ?? 0 * 1000),\n          currentDate: new Intl.DateTimeFormat('en', dateOptions).format(requestTime),\n        });\n        const mediaError = new MediaError(message, mediaErrorCode, true, context);\n        mediaError.errorCategory = category;\n        mediaError.muxCode = MuxErrorCode.NETWORK_TOKEN_EXPIRED;\n        mediaError.data = resp;\n        return mediaError;\n      }\n      if (isJWTSubMismatch(jwtObj, playbackId)) {\n        const message = i18n(\n          `The video’s playback ID does not match the one encoded in the {tokenNamePrefix}-token.`,\n          translate\n        ).format({\n          tokenNamePrefix,\n        });\n        const context = i18n(\n          `Specified playback ID: {playbackId} and the playback ID encoded in the {tokenNamePrefix}-token: {tokenPlaybackId}`,\n          translate\n        ).format({\n          tokenNamePrefix,\n          playbackId,\n          tokenPlaybackId: jwtObj.sub,\n        });\n        const mediaError = new MediaError(message, mediaErrorCode, true, context);\n        mediaError.errorCategory = category;\n        mediaError.muxCode = MuxErrorCode.NETWORK_TOKEN_SUB_MISMATCH;\n        mediaError.data = resp;\n        return mediaError;\n      }\n      if (isJWTAudMissing(jwtObj, expectedAud)) {\n        const message = i18n(`The {tokenNamePrefix}-token is formatted with incorrect information.`, translate).format({\n          tokenNamePrefix,\n        });\n        const context = i18n(\n          `The {tokenNamePrefix}-token has no aud value. aud value should be {expectedAud}.`,\n          translate\n        ).format({\n          tokenNamePrefix,\n          expectedAud,\n        });\n        const mediaError = new MediaError(message, mediaErrorCode, true, context);\n        mediaError.errorCategory = category;\n        mediaError.muxCode = MuxErrorCode.NETWORK_TOKEN_AUD_MISSING;\n        mediaError.data = resp;\n        return mediaError;\n      }\n      if (isJWTAudMismatch(jwtObj, expectedAud)) {\n        const message = i18n(`The {tokenNamePrefix}-token is formatted with incorrect information.`, translate).format({\n          tokenNamePrefix,\n        });\n        const context = i18n(\n          `The {tokenNamePrefix}-token has an incorrect aud value: {aud}. aud value should be {expectedAud}.`,\n          translate\n        ).format({\n          tokenNamePrefix,\n          expectedAud,\n          aud: jwtObj.aud,\n        });\n        const mediaError = new MediaError(message, mediaErrorCode, true, context);\n        mediaError.errorCategory = category;\n        mediaError.muxCode = MuxErrorCode.NETWORK_TOKEN_AUD_MISMATCH;\n        mediaError.data = resp;\n        return mediaError;\n      }\n\n      // NOTE: This *should* not happen for DRM, since the drm token\n      // is currently used to detect whether or not DRM should\n      // be setup at all. Including for exhaustiveness. (CJP)\n    } else {\n      const message = i18n(\n        `Authorization error trying to access this {category} URL. If this is a signed URL, you might need to provide a {tokenNamePrefix}-token.`,\n        translate\n      ).format({\n        tokenNamePrefix,\n        category,\n      });\n      const context = i18n(`Specified playback ID: {playbackId}`, translate).format({ playbackId });\n      const mediaError = new MediaError(message, mediaErrorCode, fatal ?? true, context);\n      mediaError.errorCategory = category;\n      mediaError.muxCode = MuxErrorCode.NETWORK_TOKEN_MISSING;\n      mediaError.data = resp;\n      return mediaError;\n    }\n  }\n\n  if (status === 412) {\n    const message = i18n(\n      `This playback-id may belong to a live stream that is not currently active or an asset that is not ready.`,\n      translate\n    );\n    const context = i18n(`Specified playback ID: {playbackId}`, translate).format({ playbackId });\n    const mediaError = new MediaError(message, mediaErrorCode, fatal ?? true, context);\n    mediaError.errorCategory = category;\n    mediaError.muxCode = MuxErrorCode.NETWORK_NOT_READY;\n    mediaError.streamType =\n      muxMediaEl.streamType === StreamTypes.LIVE\n        ? 'live'\n        : muxMediaEl.streamType === StreamTypes.ON_DEMAND\n          ? 'on-demand'\n          : 'unknown';\n    mediaError.data = resp;\n    return mediaError;\n  }\n\n  /**\n   * NOTE: When using a \"structurally valid but non-existent\" playback id for a DRM (license or app certificate) request, this will result in a 403 status.\n   * However, since we will only currently make a DRM request after successfully loading the media, this case should not need\n   * to be accounted for. If we ever eagerly fetch FPS app certs prior to or in parallel to media requests, we would potentially\n   * want to account for that case (either by normalizing statuses, in our messaging for generic 403 above, or through more complex\n   * solutions like waiting for the media response). (CJP)\n   */\n  if (status === 404) {\n    // NOTE: This *should* not happen for DRM (only playback/media requests), since the URL should never be invalid if code\n    // is correct. Aka if we end up here it's almost definitely a bug.\n    const message = i18n(\n      `This URL or playback-id does not exist. You may have used an Asset ID or an ID from a different resource.`,\n      translate\n    );\n    const context = i18n(`Specified playback ID: {playbackId}`, translate).format({ playbackId });\n    const mediaError = new MediaError(message, mediaErrorCode, fatal ?? true, context);\n    mediaError.errorCategory = category;\n    mediaError.muxCode = MuxErrorCode.NETWORK_NOT_FOUND;\n    mediaError.data = resp;\n    return mediaError;\n  }\n\n  /**\n   * NOTE: Omitting a token for a DRM (license or app certificate) request results in a 400 status, unlike playback/media requests,\n   * which are a 403 status (See above).\n   * However, since we will only currently setup Mux Player for DRM if a drm token is provided, this case should not need\n   * to be accounted for. If we ever change this, we would potentially\n   * want to account for that case (either by normalizing statuses, in our messaging for generic 400 above, or through more complex\n   * solutions like checking the category before deciding on error details here). (CJP)\n   */\n  if (status === 400) {\n    const message = i18n(`The URL or playback-id was invalid. You may have used an invalid value as a playback-id.`);\n    const context = i18n(`Specified playback ID: {playbackId}`, translate).format({ playbackId });\n    const mediaError = new MediaError(message, mediaErrorCode, fatal ?? true, context);\n    mediaError.errorCategory = category;\n    mediaError.muxCode = MuxErrorCode.NETWORK_INVALID_URL;\n    mediaError.data = resp;\n    return mediaError;\n  }\n\n  const mediaError = new MediaError('', mediaErrorCode, fatal ?? true);\n  mediaError.errorCategory = category;\n  mediaError.muxCode = MuxErrorCode.NETWORK_UNKNOWN_ERROR;\n  mediaError.data = resp;\n  return mediaError;\n};\n","import Hls from './hls';\nimport type { HlsInterface } from './hls';\nimport type { Level } from 'hls.js';\n\n// The hls.js commonJS module doesn't export CapLevelController, so get it from the default config.\nconst CapLevelController = Hls.DefaultConfig.capLevelController;\n\n/**\n * A custom HLS.js CapLevelController that behaves like the default one, except\n * it enforces a \"minimum maximum\" to avoid forced capping to lower quality at small sizes\n */\nclass MinCapLevelController extends CapLevelController {\n  // Never cap below this level.\n  static minMaxResolution = 720;\n\n  constructor(hls: HlsInterface) {\n    super(hls);\n  }\n\n  get levels() {\n    // NOTE: hls is a TS-private member in CapLevelController. Should be TS-protected (CJP)\n    // @ts-ignore\n    return (this.hls.levels ?? []) as Level[];\n  }\n\n  getValidLevels(capLevelIndex: number) {\n    return this.levels.filter(\n      // NOTE: isLevelAllowed is a TS-private member in CapLevelController. Should be TS-protected (CJP)\n      // @ts-ignore\n      (level, index) => this.isLevelAllowed(level) && index <= capLevelIndex\n    );\n  }\n\n  getMaxLevel(capLevelIndex: number) {\n    const baseMaxLevel = super.getMaxLevel(capLevelIndex);\n    const validLevels = this.getValidLevels(capLevelIndex);\n\n    // Default maxLevel selection ended up out of bounds to indicate e.g. no capping/no levels available (yet), so use it\n    if (!validLevels[baseMaxLevel]) return baseMaxLevel;\n\n    const baseMaxLevelResolution = Math.min(validLevels[baseMaxLevel].width, validLevels[baseMaxLevel].height);\n    const preferredMinMaxResolution = MinCapLevelController.minMaxResolution;\n\n    // Default maxLevel selection already meets our conditions, so use it\n    if (baseMaxLevelResolution >= preferredMinMaxResolution) return baseMaxLevel;\n\n    // Default maxLevel selection is below the preferred \"min max\", so find the lowest level\n    // that is >= the preference. We can simply repurpose CapLevelController:getMaxLevelByMediaSize()\n    // for this, \"lying\" about the element's size.\n    // NOTE: Since CapLevelController:getMaxLevelByMediaSize() uses \"max square size\" under the hood\n    // already, we don't need to duplicate that logic here.\n    const maxLevel = CapLevelController.getMaxLevelByMediaSize(\n      validLevels,\n      preferredMinMaxResolution * (16 / 9),\n      preferredMinMaxResolution\n    );\n\n    return maxLevel;\n  }\n}\n\nexport default MinCapLevelController;\n"]},"metadata":{},"sourceType":"module"}