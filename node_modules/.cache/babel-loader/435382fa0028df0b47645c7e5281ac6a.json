{"ast":null,"code":"import { AttrPart, InnerTemplatePart, TemplateInstance } from \"./template-parts.js\";\nimport { isNumericString } from \"./utils.js\";\nconst pipeModifiers = {\n  string: value => String(value)\n};\nclass PartialTemplate {\n  constructor(template) {\n    this.template = template;\n    this.state = void 0;\n  }\n}\nconst templates = /* @__PURE__ */new WeakMap();\nconst templateInstances = /* @__PURE__ */new WeakMap();\nconst Directives = {\n  partial: (part, state) => {\n    state[part.expression] = new PartialTemplate(part.template);\n  },\n  if: (part, state) => {\n    var _a;\n    if (evaluateExpression(part.expression, state)) {\n      if (templates.get(part) !== part.template) {\n        templates.set(part, part.template);\n        const tpl = new TemplateInstance(part.template, state, processor);\n        part.replace(tpl);\n        templateInstances.set(part, tpl);\n      } else {\n        (_a = templateInstances.get(part)) == null ? void 0 : _a.update(state);\n      }\n    } else {\n      part.replace(\"\");\n      templates.delete(part);\n      templateInstances.delete(part);\n    }\n  }\n};\nconst DirectiveNames = Object.keys(Directives);\nconst processor = {\n  processCallback(instance, parts, state) {\n    var _a, _b;\n    if (!state) return;\n    for (const [expression, part] of parts) {\n      if (part instanceof InnerTemplatePart) {\n        if (!part.directive) {\n          const directive = DirectiveNames.find(n => part.template.hasAttribute(n));\n          if (directive) {\n            part.directive = directive;\n            part.expression = part.template.getAttribute(directive);\n          }\n        }\n        (_a = Directives[part.directive]) == null ? void 0 : _a.call(Directives, part, state);\n        continue;\n      }\n      let value = evaluateExpression(expression, state);\n      if (value instanceof PartialTemplate) {\n        if (templates.get(part) !== value.template) {\n          templates.set(part, value.template);\n          value = new TemplateInstance(value.template, value.state, processor);\n          part.value = value;\n          templateInstances.set(part, value);\n        } else {\n          (_b = templateInstances.get(part)) == null ? void 0 : _b.update(value.state);\n        }\n        continue;\n      }\n      if (value) {\n        if (part instanceof AttrPart) {\n          if (part.attributeName.startsWith(\"aria-\")) {\n            value = String(value);\n          }\n        }\n        if (part instanceof AttrPart) {\n          if (typeof value === \"boolean\") {\n            part.booleanValue = value;\n          } else if (typeof value === \"function\") {\n            part.element[part.attributeName] = value;\n          } else {\n            part.value = value;\n          }\n        } else {\n          part.value = value;\n          templates.delete(part);\n          templateInstances.delete(part);\n        }\n      } else {\n        if (part instanceof AttrPart) {\n          part.value = void 0;\n        } else {\n          part.value = void 0;\n          templates.delete(part);\n          templateInstances.delete(part);\n        }\n      }\n    }\n  }\n};\nconst operators = {\n  \"!\": a => !a,\n  \"!!\": a => !!a,\n  \"==\": (a, b) => a == b,\n  \"!=\": (a, b) => a != b,\n  \">\": (a, b) => a > b,\n  \">=\": (a, b) => a >= b,\n  \"<\": (a, b) => a < b,\n  \"<=\": (a, b) => a <= b,\n  \"??\": (a, b) => a != null ? a : b,\n  \"|\": (a, b) => {\n    var _a;\n    return (_a = pipeModifiers[b]) == null ? void 0 : _a.call(pipeModifiers, a);\n  }\n};\nfunction tokenizeExpression(expr) {\n  return tokenize(expr, {\n    boolean: /true|false/,\n    number: /-?\\d+\\.?\\d*/,\n    string: /([\"'])((?:\\\\.|[^\\\\])*?)\\1/,\n    operator: /[!=><][=!]?|\\?\\?|\\|/,\n    ws: /\\s+/,\n    param: /[$a-z_][$\\w]*/i\n  }).filter(_ref => {\n    let {\n      type\n    } = _ref;\n    return type !== \"ws\";\n  });\n}\nfunction evaluateExpression(expr) {\n  let state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a, _b, _c, _d, _e, _f, _g;\n  const tokens = tokenizeExpression(expr);\n  if (tokens.length === 0 || tokens.some(_ref2 => {\n    let {\n      type\n    } = _ref2;\n    return !type;\n  })) {\n    return invalidExpression(expr);\n  }\n  if (((_a = tokens[0]) == null ? void 0 : _a.token) === \">\") {\n    const partial = state[(_b = tokens[1]) == null ? void 0 : _b.token];\n    if (!partial) {\n      return invalidExpression(expr);\n    }\n    const partialState = {\n      ...state\n    };\n    partial.state = partialState;\n    const args = tokens.slice(2);\n    for (let i = 0; i < args.length; i += 3) {\n      const name = (_c = args[i]) == null ? void 0 : _c.token;\n      const operator = (_d = args[i + 1]) == null ? void 0 : _d.token;\n      const value = (_e = args[i + 2]) == null ? void 0 : _e.token;\n      if (name && operator === \"=\") {\n        partialState[name] = getParamValue(value, state);\n      }\n    }\n    return partial;\n  }\n  if (tokens.length === 1) {\n    if (!isValidParam(tokens[0])) {\n      return invalidExpression(expr);\n    }\n    return getParamValue(tokens[0].token, state);\n  }\n  if (tokens.length === 2) {\n    const operator = (_f = tokens[0]) == null ? void 0 : _f.token;\n    const run = operators[operator];\n    if (!run || !isValidParam(tokens[1])) {\n      return invalidExpression(expr);\n    }\n    const a = getParamValue(tokens[1].token, state);\n    return run(a);\n  }\n  if (tokens.length === 3) {\n    const operator = (_g = tokens[1]) == null ? void 0 : _g.token;\n    const run = operators[operator];\n    if (!run || !isValidParam(tokens[0]) || !isValidParam(tokens[2])) {\n      return invalidExpression(expr);\n    }\n    const a = getParamValue(tokens[0].token, state);\n    if (operator === \"|\") {\n      return run(a, tokens[2].token);\n    }\n    const b = getParamValue(tokens[2].token, state);\n    return run(a, b);\n  }\n}\nfunction invalidExpression(expr) {\n  console.warn(`Warning: invalid expression \\`${expr}\\``);\n  return false;\n}\nfunction isValidParam(_ref3) {\n  let {\n    type\n  } = _ref3;\n  return [\"number\", \"boolean\", \"string\", \"param\"].includes(type);\n}\nfunction getParamValue(raw, state) {\n  const firstChar = raw[0];\n  const lastChar = raw.slice(-1);\n  if (raw === \"true\" || raw === \"false\") {\n    return raw === \"true\";\n  }\n  if (firstChar === lastChar && [`'`, `\"`].includes(firstChar)) {\n    return raw.slice(1, -1);\n  }\n  if (isNumericString(raw)) {\n    return parseFloat(raw);\n  }\n  return state[raw];\n}\nfunction tokenize(str, parsers) {\n  let len, match, token;\n  const tokens = [];\n  while (str) {\n    token = null;\n    len = str.length;\n    for (const key in parsers) {\n      match = parsers[key].exec(str);\n      if (match && match.index < len) {\n        token = {\n          token: match[0],\n          type: key,\n          matches: match.slice(1)\n        };\n        len = match.index;\n      }\n    }\n    if (len) {\n      tokens.push({\n        token: str.substr(0, len),\n        type: void 0\n      });\n    }\n    if (token) {\n      tokens.push(token);\n    }\n    str = str.substr(len + (token ? token.token.length : 0));\n  }\n  return tokens;\n}\nexport { evaluateExpression, getParamValue, processor, tokenizeExpression };","map":null,"metadata":{},"sourceType":"module"}