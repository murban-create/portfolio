{"ast":null,"code":"/* global WeakRef */\n\nexport const privateProps = new WeakMap();\nexport class InvalidStateError extends Error {}\nexport class NotSupportedError extends Error {}\nexport class NotFoundError extends Error {}\nconst HLS_RESPONSE_HEADERS = ['application/x-mpegURL', 'application/vnd.apple.mpegurl', 'audio/mpegurl'];\n\n// Fallback to a plain Set if WeakRef is not available.\nexport const IterableWeakSet = globalThis.WeakRef ? class extends Set {\n  add(el) {\n    super.add(new WeakRef(el));\n  }\n  forEach(fn) {\n    super.forEach(ref => {\n      const value = ref.deref();\n      if (value) fn(value);\n    });\n  }\n} : Set;\nexport function onCastApiAvailable(callback) {\n  var _globalThis$chrome, _globalThis$chrome$ca, _globalThis$cast;\n  if (!((_globalThis$chrome = globalThis.chrome) !== null && _globalThis$chrome !== void 0 && (_globalThis$chrome$ca = _globalThis$chrome.cast) !== null && _globalThis$chrome$ca !== void 0 && _globalThis$chrome$ca.isAvailable)) {\n    globalThis.__onGCastApiAvailable = () => {\n      // The globalThis.__onGCastApiAvailable callback alone is not reliable for\n      // the added cast.framework. It's loaded in a separate JS file.\n      // https://www.gstatic.com/eureka/clank/101/cast_sender.js\n      // https://www.gstatic.com/cast/sdk/libs/sender/1.0/cast_framework.js\n      customElements.whenDefined('google-cast-button').then(callback);\n    };\n  } else if (!((_globalThis$cast = globalThis.cast) !== null && _globalThis$cast !== void 0 && _globalThis$cast.framework)) {\n    customElements.whenDefined('google-cast-button').then(callback);\n  } else {\n    callback();\n  }\n}\nexport function requiresCastFramework() {\n  // todo: exclude for Android>=56 which supports the Remote Playback API natively.\n  return globalThis.chrome;\n}\nexport function loadCastFramework() {\n  var _globalThis$chrome2;\n  const sdkUrl = 'https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1';\n  if ((_globalThis$chrome2 = globalThis.chrome) !== null && _globalThis$chrome2 !== void 0 && _globalThis$chrome2.cast || document.querySelector(`script[src=\"${sdkUrl}\"]`)) return;\n  const script = document.createElement('script');\n  script.src = sdkUrl;\n  document.head.append(script);\n}\nexport function castContext() {\n  var _globalThis$cast2, _globalThis$cast2$fra;\n  return (_globalThis$cast2 = globalThis.cast) === null || _globalThis$cast2 === void 0 ? void 0 : (_globalThis$cast2$fra = _globalThis$cast2.framework) === null || _globalThis$cast2$fra === void 0 ? void 0 : _globalThis$cast2$fra.CastContext.getInstance();\n}\nexport function currentSession() {\n  var _castContext;\n  return (_castContext = castContext()) === null || _castContext === void 0 ? void 0 : _castContext.getCurrentSession();\n}\nexport function currentMedia() {\n  var _currentSession;\n  return (_currentSession = currentSession()) === null || _currentSession === void 0 ? void 0 : _currentSession.getSessionObj().media[0];\n}\nexport function editTracksInfo(request) {\n  return new Promise((resolve, reject) => {\n    currentMedia().editTracksInfo(request, resolve, reject);\n  });\n}\nexport function getMediaStatus(request) {\n  return new Promise((resolve, reject) => {\n    currentMedia().getStatus(request, resolve, reject);\n  });\n}\nexport function setCastOptions(options) {\n  return castContext().setOptions({\n    ...getDefaultCastOptions(),\n    ...options\n  });\n}\nexport function getDefaultCastOptions() {\n  return {\n    // Set the receiver application ID to your own (created in the\n    // Google Cast Developer Console), or optionally\n    // use the chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID\n    receiverApplicationId: 'CC1AD845',\n    // Auto join policy can be one of the following three:\n    // ORIGIN_SCOPED - Auto connect from same appId and page origin\n    // TAB_AND_ORIGIN_SCOPED - Auto connect from same appId, page origin, and tab\n    // PAGE_SCOPED - No auto connect\n    autoJoinPolicy: 'origin_scoped',\n    // The following flag enables Cast Connect(requires Chrome 87 or higher)\n    // https://developers.googleblog.com/2020/08/introducing-cast-connect-android-tv.html\n    androidReceiverCompatible: false,\n    language: 'en-US',\n    resumeSavedSession: true\n  };\n}\n\n//Get the segment format given the end of the URL (.m4s, .ts, etc)\nfunction getFormat(segment) {\n  if (!segment) return undefined;\n  const regex = /\\.([a-zA-Z0-9]+)(?:\\?.*)?$/;\n  const match = segment.match(regex);\n  return match ? match[1] : null;\n}\nfunction parsePlaylistUrls(playlistContent) {\n  const lines = playlistContent.split('\\n');\n  const urls = [];\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n\n    // Locate available video playlists and get the next line which is the URI (https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-17#section-4.4.6.2)\n    if (line.startsWith('#EXT-X-STREAM-INF')) {\n      const nextLine = lines[i + 1] ? lines[i + 1].trim() : '';\n      if (nextLine && !nextLine.startsWith('#')) {\n        urls.push(nextLine);\n      }\n    }\n  }\n  return urls;\n}\nfunction parseSegment(playlistContent) {\n  const lines = playlistContent.split('\\n');\n  const url = lines.find(line => !line.trim().startsWith('#') && line.trim() !== '');\n  return url;\n}\nexport async function isHls(url) {\n  try {\n    const response = await fetch(url, {\n      method: 'HEAD'\n    });\n    const contentType = response.headers.get('Content-Type');\n    return HLS_RESPONSE_HEADERS.some(header => contentType === header);\n  } catch (err) {\n    console.error('Error while trying to get the Content-Type of the manifest', err);\n    return false;\n  }\n}\nexport async function getPlaylistSegmentFormat(url) {\n  try {\n    const mainManifestContent = await (await fetch(url)).text();\n    let availableChunksContent = mainManifestContent;\n    const playlists = parsePlaylistUrls(mainManifestContent);\n    if (playlists.length > 0) {\n      const chosenPlaylistUrl = new URL(playlists[0], url).toString();\n      availableChunksContent = await (await fetch(chosenPlaylistUrl)).text();\n    }\n    const segment = parseSegment(availableChunksContent);\n    const format = getFormat(segment);\n    return format;\n  } catch (err) {\n    console.error('Error while trying to parse the manifest playlist', err);\n    return undefined;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}