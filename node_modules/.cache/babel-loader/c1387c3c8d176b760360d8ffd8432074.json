{"ast":null,"code":"/* global chrome, cast */\nimport { privateProps, IterableWeakSet, InvalidStateError, NotSupportedError, onCastApiAvailable, castContext, currentSession, currentMedia, editTracksInfo, getMediaStatus, setCastOptions } from './castable-utils.js';\nconst remoteInstances = new IterableWeakSet();\nconst castElementRef = new WeakSet();\nlet cf;\nonCastApiAvailable(() => {\n  var _globalThis$chrome, _globalThis$chrome$ca;\n  if (!((_globalThis$chrome = globalThis.chrome) !== null && _globalThis$chrome !== void 0 && (_globalThis$chrome$ca = _globalThis$chrome.cast) !== null && _globalThis$chrome$ca !== void 0 && _globalThis$chrome$ca.isAvailable)) {\n    var _globalThis$chrome2, _globalThis$chrome2$c;\n    // Useful to see in verbose logs if this shows undefined or false.\n    console.debug('chrome.cast.isAvailable', (_globalThis$chrome2 = globalThis.chrome) === null || _globalThis$chrome2 === void 0 ? void 0 : (_globalThis$chrome2$c = _globalThis$chrome2.cast) === null || _globalThis$chrome2$c === void 0 ? void 0 : _globalThis$chrome2$c.isAvailable);\n    return;\n  }\n  if (!cf) {\n    cf = cast.framework;\n    castContext().addEventListener(cf.CastContextEventType.CAST_STATE_CHANGED, e => {\n      remoteInstances.forEach(r => {\n        var _privateProps$get$onC, _privateProps$get;\n        return (_privateProps$get$onC = (_privateProps$get = privateProps.get(r)).onCastStateChanged) === null || _privateProps$get$onC === void 0 ? void 0 : _privateProps$get$onC.call(_privateProps$get, e);\n      });\n    });\n    castContext().addEventListener(cf.CastContextEventType.SESSION_STATE_CHANGED, e => {\n      remoteInstances.forEach(r => {\n        var _privateProps$get$onS, _privateProps$get2;\n        return (_privateProps$get$onS = (_privateProps$get2 = privateProps.get(r)).onSessionStateChanged) === null || _privateProps$get$onS === void 0 ? void 0 : _privateProps$get$onS.call(_privateProps$get2, e);\n      });\n    });\n    remoteInstances.forEach(r => {\n      var _privateProps$get$ini, _privateProps$get3;\n      return (_privateProps$get$ini = (_privateProps$get3 = privateProps.get(r)).init) === null || _privateProps$get$ini === void 0 ? void 0 : _privateProps$get$ini.call(_privateProps$get3);\n    });\n  }\n});\nlet remotePlaybackCallbackIdCount = 0;\n\n/**\n * Remote Playback shim for the Google cast SDK.\n * https://w3c.github.io/remote-playback/\n */\nexport class RemotePlayback extends EventTarget {\n  #media;\n  #isInit;\n  #remotePlayer;\n  #remoteListeners;\n  #state = 'disconnected';\n  #available = false;\n  #callbacks = new Set();\n  #callbackIds = new WeakMap();\n  constructor(media) {\n    super();\n    this.#media = media;\n    remoteInstances.add(this);\n    privateProps.set(this, {\n      init: () => this.#init(),\n      onCastStateChanged: () => this.#onCastStateChanged(),\n      onSessionStateChanged: () => this.#onSessionStateChanged(),\n      getCastPlayer: () => this.#castPlayer\n    });\n    this.#init();\n  }\n  get #castPlayer() {\n    if (castElementRef.has(this.#media)) return this.#remotePlayer;\n    return undefined;\n  }\n\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/RemotePlayback/state\n   * @return {'disconnected'|'connecting'|'connected'}\n   */\n  get state() {\n    return this.#state;\n  }\n  async watchAvailability(callback) {\n    if (this.#media.disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n    this.#callbackIds.set(callback, ++remotePlaybackCallbackIdCount);\n    this.#callbacks.add(callback);\n\n    // https://w3c.github.io/remote-playback/#getting-the-remote-playback-devices-availability-information\n    queueMicrotask(() => callback(this.#hasDevicesAvailable()));\n    return remotePlaybackCallbackIdCount;\n  }\n  async cancelWatchAvailability(callback) {\n    if (this.#media.disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n    if (callback) {\n      this.#callbacks.delete(callback);\n    } else {\n      this.#callbacks.clear();\n    }\n  }\n  async prompt() {\n    var _globalThis$chrome3, _globalThis$chrome3$c, _privateProps$get4, _privateProps$get4$lo;\n    if (this.#media.disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n    if (!((_globalThis$chrome3 = globalThis.chrome) !== null && _globalThis$chrome3 !== void 0 && (_globalThis$chrome3$c = _globalThis$chrome3.cast) !== null && _globalThis$chrome3$c !== void 0 && _globalThis$chrome3$c.isAvailable)) {\n      throw new NotSupportedError('The RemotePlayback API is disabled on this platform.');\n    }\n    const willDisconnect = castElementRef.has(this.#media);\n    castElementRef.add(this.#media);\n    setCastOptions(this.#media.castOptions);\n    Object.entries(this.#remoteListeners).forEach(_ref => {\n      let [event, listener] = _ref;\n      this.#remotePlayer.controller.addEventListener(event, listener);\n    });\n    try {\n      // Open browser cast menu.\n      await castContext().requestSession();\n    } catch (err) {\n      // If there will be no disconnect, reset some state here.\n      if (!willDisconnect) {\n        castElementRef.delete(this.#media);\n      }\n\n      // Don't throw an error if disconnecting or cancelling.\n      if (err === 'cancel') {\n        return;\n      }\n      throw new Error(err);\n    }\n    (_privateProps$get4 = privateProps.get(this.#media)) === null || _privateProps$get4 === void 0 ? void 0 : (_privateProps$get4$lo = _privateProps$get4.loadOnPrompt) === null || _privateProps$get4$lo === void 0 ? void 0 : _privateProps$get4$lo.call(_privateProps$get4);\n  }\n  #disconnect() {\n    if (!castElementRef.has(this.#media)) return;\n    Object.entries(this.#remoteListeners).forEach(_ref2 => {\n      let [event, listener] = _ref2;\n      this.#remotePlayer.controller.removeEventListener(event, listener);\n    });\n    castElementRef.delete(this.#media);\n\n    // isMuted is not in savedPlayerState. should we sync this back to local?\n    this.#media.muted = this.#remotePlayer.isMuted;\n    this.#media.currentTime = this.#remotePlayer.savedPlayerState.currentTime;\n    if (this.#remotePlayer.savedPlayerState.isPaused === false) {\n      this.#media.play();\n    }\n  }\n  #hasDevicesAvailable() {\n    var _castContext;\n    // Cast state: NO_DEVICES_AVAILABLE, NOT_CONNECTED, CONNECTING, CONNECTED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.CastState\n    const castState = (_castContext = castContext()) === null || _castContext === void 0 ? void 0 : _castContext.getCastState();\n    return castState && castState !== 'NO_DEVICES_AVAILABLE';\n  }\n  #onCastStateChanged() {\n    // Cast state: NO_DEVICES_AVAILABLE, NOT_CONNECTED, CONNECTING, CONNECTED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.CastState\n    const castState = castContext().getCastState();\n    if (castElementRef.has(this.#media)) {\n      if (castState === 'CONNECTING') {\n        this.#state = 'connecting';\n        this.dispatchEvent(new Event('connecting'));\n      }\n    }\n    if (!this.#available && castState !== null && castState !== void 0 && castState.includes('CONNECT')) {\n      this.#available = true;\n      for (let callback of this.#callbacks) callback(true);\n    } else if (this.#available && (!castState || castState === 'NO_DEVICES_AVAILABLE')) {\n      this.#available = false;\n      for (let callback of this.#callbacks) callback(false);\n    }\n  }\n  async #onSessionStateChanged() {\n    // Session states: NO_SESSION, SESSION_STARTING, SESSION_STARTED, SESSION_START_FAILED,\n    //                 SESSION_ENDING, SESSION_ENDED, SESSION_RESUMED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.SessionState\n\n    const {\n      SESSION_RESUMED\n    } = cf.SessionState;\n    if (castContext().getSessionState() === SESSION_RESUMED) {\n      var _currentMedia;\n      /**\n       * Figure out if this was the video that started the resumed session.\n       * @TODO make this more specific than just checking against the video src!! (WL)\n       *\n       * If this video element can get the same unique id on each browser refresh\n       * it would be possible to pass this unique id w/ `LoadRequest.customData`\n       * and verify against currentMedia().customData below.\n       */\n      if (this.#media.castSrc === ((_currentMedia = currentMedia()) === null || _currentMedia === void 0 ? void 0 : _currentMedia.media.contentId)) {\n        castElementRef.add(this.#media);\n        Object.entries(this.#remoteListeners).forEach(_ref3 => {\n          let [event, listener] = _ref3;\n          this.#remotePlayer.controller.addEventListener(event, listener);\n        });\n\n        /**\n         * There is cast framework resume session bug when you refresh the page a few\n         * times the this.#remotePlayer.currentTime will not be in sync with the receiver :(\n         * The below status request syncs it back up.\n         */\n        try {\n          await getMediaStatus(new chrome.cast.media.GetStatusRequest());\n        } catch (error) {\n          console.error(error);\n        }\n\n        // Dispatch the play, playing events manually to sync remote playing state.\n        this.#remoteListeners[cf.RemotePlayerEventType.IS_PAUSED_CHANGED]();\n        this.#remoteListeners[cf.RemotePlayerEventType.PLAYER_STATE_CHANGED]();\n      }\n    }\n  }\n  #init() {\n    if (!cf || this.#isInit) return;\n    this.#isInit = true;\n    setCastOptions(this.#media.castOptions);\n\n    /**\n     * @TODO add listeners for addtrack, removetrack (WL)\n     * This only has an impact on <track> with a `src` because these have to be\n     * loaded manually in the load() method. This will require a new load() call\n     * for each added/removed track w/ src.\n     */\n    this.#media.textTracks.addEventListener('change', () => this.#updateRemoteTextTrack());\n    this.#onCastStateChanged();\n    this.#remotePlayer = new cf.RemotePlayer();\n    new cf.RemotePlayerController(this.#remotePlayer);\n    this.#remoteListeners = {\n      [cf.RemotePlayerEventType.IS_CONNECTED_CHANGED]: _ref4 => {\n        let {\n          value\n        } = _ref4;\n        if (value === true) {\n          this.#state = 'connected';\n          this.dispatchEvent(new Event('connect'));\n        } else {\n          this.#disconnect();\n          this.#state = 'disconnected';\n          this.dispatchEvent(new Event('disconnect'));\n        }\n      },\n      [cf.RemotePlayerEventType.DURATION_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('durationchange'));\n      },\n      [cf.RemotePlayerEventType.VOLUME_LEVEL_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('volumechange'));\n      },\n      [cf.RemotePlayerEventType.IS_MUTED_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('volumechange'));\n      },\n      [cf.RemotePlayerEventType.CURRENT_TIME_CHANGED]: () => {\n        var _this$castPlayer;\n        if (!((_this$castPlayer = this.#castPlayer) !== null && _this$castPlayer !== void 0 && _this$castPlayer.isMediaLoaded)) return;\n        this.#media.dispatchEvent(new Event('timeupdate'));\n      },\n      [cf.RemotePlayerEventType.VIDEO_INFO_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('resize'));\n      },\n      [cf.RemotePlayerEventType.IS_PAUSED_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event(this.paused ? 'pause' : 'play'));\n      },\n      [cf.RemotePlayerEventType.PLAYER_STATE_CHANGED]: () => {\n        var _this$castPlayer2, _this$castPlayer3;\n        // Player states: IDLE, PLAYING, PAUSED, BUFFERING\n        // https://developers.google.com/cast/docs/reference/web_sender/chrome.cast.media#.PlayerState\n\n        // pause event is handled above.\n        if (((_this$castPlayer2 = this.#castPlayer) === null || _this$castPlayer2 === void 0 ? void 0 : _this$castPlayer2.playerState) === chrome.cast.media.PlayerState.PAUSED) {\n          return;\n        }\n        this.#media.dispatchEvent(new Event({\n          [chrome.cast.media.PlayerState.PLAYING]: 'playing',\n          [chrome.cast.media.PlayerState.BUFFERING]: 'waiting',\n          [chrome.cast.media.PlayerState.IDLE]: 'emptied'\n        }[(_this$castPlayer3 = this.#castPlayer) === null || _this$castPlayer3 === void 0 ? void 0 : _this$castPlayer3.playerState]));\n      },\n      [cf.RemotePlayerEventType.IS_MEDIA_LOADED_CHANGED]: async () => {\n        var _this$castPlayer4;\n        if (!((_this$castPlayer4 = this.#castPlayer) !== null && _this$castPlayer4 !== void 0 && _this$castPlayer4.isMediaLoaded)) return;\n\n        // mediaInfo is not immediately available due to a bug? wait one tick\n        await Promise.resolve();\n        this.#onRemoteMediaLoaded();\n      }\n    };\n  }\n  #onRemoteMediaLoaded() {\n    this.#updateRemoteTextTrack();\n  }\n  async #updateRemoteTextTrack() {\n    var _this$remotePlayer$me, _currentSession, _currentSession$getSe;\n    if (!this.#castPlayer) return;\n\n    // Get the tracks w/ trackId's that have been loaded; manually or via a playlist like a M3U8 or MPD.\n    const remoteTracks = ((_this$remotePlayer$me = this.#remotePlayer.mediaInfo) === null || _this$remotePlayer$me === void 0 ? void 0 : _this$remotePlayer$me.tracks) ?? [];\n    const remoteSubtitles = remoteTracks.filter(_ref5 => {\n      let {\n        type\n      } = _ref5;\n      return type === chrome.cast.media.TrackType.TEXT;\n    });\n    const localSubtitles = [...this.#media.textTracks].filter(_ref6 => {\n      let {\n        kind\n      } = _ref6;\n      return kind === 'subtitles' || kind === 'captions';\n    });\n\n    // Create a new array from the local subs w/ the trackId's from the remote subs.\n    const subtitles = remoteSubtitles.map(_ref7 => {\n      let {\n        language,\n        name,\n        trackId\n      } = _ref7;\n      // Find the corresponding local text track and assign the trackId.\n      const {\n        mode\n      } = localSubtitles.find(local => local.language === language && local.label === name) ?? {};\n      if (mode) return {\n        mode,\n        trackId\n      };\n      return false;\n    }).filter(Boolean);\n    const hiddenSubtitles = subtitles.filter(_ref8 => {\n      let {\n        mode\n      } = _ref8;\n      return mode !== 'showing';\n    });\n    const hiddenTrackIds = hiddenSubtitles.map(_ref9 => {\n      let {\n        trackId\n      } = _ref9;\n      return trackId;\n    });\n    const showingSubtitle = subtitles.find(_ref10 => {\n      let {\n        mode\n      } = _ref10;\n      return mode === 'showing';\n    });\n\n    // Note this could also include audio or video tracks, diff against local state.\n    const activeTrackIds = ((_currentSession = currentSession()) === null || _currentSession === void 0 ? void 0 : (_currentSession$getSe = _currentSession.getSessionObj().media[0]) === null || _currentSession$getSe === void 0 ? void 0 : _currentSession$getSe.activeTrackIds) ?? [];\n    let requestTrackIds = activeTrackIds;\n    if (activeTrackIds.length) {\n      // Filter out all local hidden subtitle trackId's.\n      requestTrackIds = requestTrackIds.filter(id => !hiddenTrackIds.includes(id));\n    }\n    if (showingSubtitle !== null && showingSubtitle !== void 0 && showingSubtitle.trackId) {\n      requestTrackIds = [...requestTrackIds, showingSubtitle.trackId];\n    }\n\n    // Remove duplicate ids.\n    requestTrackIds = [...new Set(requestTrackIds)];\n    const arrayEquals = (a, b) => a.length === b.length && a.every(a => b.includes(a));\n    if (!arrayEquals(activeTrackIds, requestTrackIds)) {\n      try {\n        const request = new chrome.cast.media.EditTracksInfoRequest(requestTrackIds);\n        await editTracksInfo(request);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  }\n}","map":{"version":3,"names":["privateProps","IterableWeakSet","InvalidStateError","NotSupportedError","onCastApiAvailable","castContext","currentSession","currentMedia","editTracksInfo","getMediaStatus","setCastOptions","remoteInstances","castElementRef","WeakSet","cf","_globalThis$chrome","_globalThis$chrome$ca","globalThis","chrome","cast","isAvailable","_globalThis$chrome2","_globalThis$chrome2$c","console","debug","framework","addEventListener","CastContextEventType","CAST_STATE_CHANGED","e","forEach","r","_privateProps$get$onC","_privateProps$get","get","onCastStateChanged","call","SESSION_STATE_CHANGED","_privateProps$get$onS","_privateProps$get2","onSessionStateChanged","_privateProps$get$ini","_privateProps$get3","init","remotePlaybackCallbackIdCount","RemotePlayback","EventTarget","media","isInit","remotePlayer","remoteListeners","state","available","callbacks","Set","callbackIds","WeakMap","constructor","add","set","getCastPlayer","castPlayer","#castPlayer","has","undefined","watchAvailability","callback","disableRemotePlayback","queueMicrotask","hasDevicesAvailable","cancelWatchAvailability","delete","clear","prompt","_globalThis$chrome3","_globalThis$chrome3$c","_privateProps$get4","_privateProps$get4$lo","willDisconnect","castOptions","Object","entries","_ref","event","listener","controller","requestSession","err","Error","loadOnPrompt","disconnect","#disconnect","_ref2","removeEventListener","muted","isMuted","currentTime","savedPlayerState","isPaused","play","#hasDevicesAvailable","_castContext","castState","getCastState","#onCastStateChanged","dispatchEvent","Event","includes","#onSessionStateChanged","SESSION_RESUMED","SessionState","getSessionState","_currentMedia","castSrc","contentId","_ref3","GetStatusRequest","error","RemotePlayerEventType","IS_PAUSED_CHANGED","PLAYER_STATE_CHANGED","#init","textTracks","updateRemoteTextTrack","RemotePlayer","RemotePlayerController","IS_CONNECTED_CHANGED","_ref4","value","DURATION_CHANGED","VOLUME_LEVEL_CHANGED","IS_MUTED_CHANGED","CURRENT_TIME_CHANGED","_this$castPlayer","isMediaLoaded","VIDEO_INFO_CHANGED","paused","_this$castPlayer2","_this$castPlayer3","playerState","PlayerState","PAUSED","PLAYING","BUFFERING","IDLE","IS_MEDIA_LOADED_CHANGED","_this$castPlayer4","Promise","resolve","onRemoteMediaLoaded","#onRemoteMediaLoaded","#updateRemoteTextTrack","_this$remotePlayer$me","_currentSession","_currentSession$getSe","remoteTracks","mediaInfo","tracks","remoteSubtitles","filter","_ref5","type","TrackType","TEXT","localSubtitles","_ref6","kind","subtitles","map","_ref7","language","name","trackId","mode","find","local","label","Boolean","hiddenSubtitles","_ref8","hiddenTrackIds","_ref9","showingSubtitle","_ref10","activeTrackIds","getSessionObj","requestTrackIds","length","id","arrayEquals","a","b","every","request","EditTracksInfoRequest"],"sources":["/Users/monawiebkeurban/Documents/portfolio/node_modules/castable-video/castable-remote-playback.js"],"sourcesContent":["/* global chrome, cast */\nimport {\n  privateProps,\n  IterableWeakSet,\n  InvalidStateError,\n  NotSupportedError,\n  onCastApiAvailable,\n  castContext,\n  currentSession,\n  currentMedia,\n  editTracksInfo,\n  getMediaStatus,\n  setCastOptions\n} from './castable-utils.js';\n\nconst remoteInstances = new IterableWeakSet();\nconst castElementRef = new WeakSet();\n\nlet cf;\n\nonCastApiAvailable(() => {\n  if (!globalThis.chrome?.cast?.isAvailable) {\n    // Useful to see in verbose logs if this shows undefined or false.\n    console.debug('chrome.cast.isAvailable', globalThis.chrome?.cast?.isAvailable);\n    return;\n  }\n\n  if (!cf) {\n    cf = cast.framework;\n\n    castContext().addEventListener(cf.CastContextEventType.CAST_STATE_CHANGED, (e) => {\n      remoteInstances.forEach((r) => privateProps.get(r).onCastStateChanged?.(e));\n    });\n\n    castContext().addEventListener(cf.CastContextEventType.SESSION_STATE_CHANGED, (e) => {\n      remoteInstances.forEach((r) => privateProps.get(r).onSessionStateChanged?.(e));\n    });\n\n    remoteInstances.forEach((r) => privateProps.get(r).init?.());\n  }\n});\n\n\nlet remotePlaybackCallbackIdCount = 0;\n\n/**\n * Remote Playback shim for the Google cast SDK.\n * https://w3c.github.io/remote-playback/\n */\nexport class RemotePlayback extends EventTarget {\n  #media;\n  #isInit;\n  #remotePlayer;\n  #remoteListeners;\n  #state = 'disconnected';\n  #available = false;\n  #callbacks = new Set();\n  #callbackIds = new WeakMap();\n\n  constructor(media) {\n    super();\n\n    this.#media = media;\n\n    remoteInstances.add(this);\n    privateProps.set(this, {\n      init: () => this.#init(),\n      onCastStateChanged: () => this.#onCastStateChanged(),\n      onSessionStateChanged: () => this.#onSessionStateChanged(),\n      getCastPlayer: () => this.#castPlayer,\n    });\n\n    this.#init();\n  }\n\n  get #castPlayer() {\n    if (castElementRef.has(this.#media)) return this.#remotePlayer;\n    return undefined;\n  }\n\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/RemotePlayback/state\n   * @return {'disconnected'|'connecting'|'connected'}\n   */\n  get state() {\n    return this.#state;\n  }\n\n  async watchAvailability(callback) {\n    if (this.#media.disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n\n    this.#callbackIds.set(callback, ++remotePlaybackCallbackIdCount);\n    this.#callbacks.add(callback);\n\n    // https://w3c.github.io/remote-playback/#getting-the-remote-playback-devices-availability-information\n    queueMicrotask(() => callback(this.#hasDevicesAvailable()));\n\n    return remotePlaybackCallbackIdCount;\n  }\n\n  async cancelWatchAvailability(callback) {\n    if (this.#media.disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n\n    if (callback) {\n      this.#callbacks.delete(callback);\n    } else {\n      this.#callbacks.clear();\n    }\n  }\n\n  async prompt() {\n    if (this.#media.disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n\n    if (!globalThis.chrome?.cast?.isAvailable) {\n      throw new NotSupportedError('The RemotePlayback API is disabled on this platform.');\n    }\n\n    const willDisconnect = castElementRef.has(this.#media);\n    castElementRef.add(this.#media);\n\n    setCastOptions(this.#media.castOptions);\n\n    Object.entries(this.#remoteListeners).forEach(([event, listener]) => {\n      this.#remotePlayer.controller.addEventListener(event, listener);\n    });\n\n    try {\n      // Open browser cast menu.\n      await castContext().requestSession();\n    } catch (err) {\n      // If there will be no disconnect, reset some state here.\n      if (!willDisconnect) {\n        castElementRef.delete(this.#media);\n      }\n\n      // Don't throw an error if disconnecting or cancelling.\n      if (err === 'cancel') {\n        return;\n      }\n\n      throw new Error(err);\n    }\n\n    privateProps.get(this.#media)?.loadOnPrompt?.();\n  }\n\n  #disconnect() {\n    if (!castElementRef.has(this.#media)) return;\n\n    Object.entries(this.#remoteListeners).forEach(([event, listener]) => {\n      this.#remotePlayer.controller.removeEventListener(event, listener);\n    });\n\n    castElementRef.delete(this.#media);\n\n    // isMuted is not in savedPlayerState. should we sync this back to local?\n    this.#media.muted = this.#remotePlayer.isMuted;\n    this.#media.currentTime = this.#remotePlayer.savedPlayerState.currentTime;\n    if (this.#remotePlayer.savedPlayerState.isPaused === false) {\n      this.#media.play();\n    }\n  }\n\n  #hasDevicesAvailable() {\n    // Cast state: NO_DEVICES_AVAILABLE, NOT_CONNECTED, CONNECTING, CONNECTED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.CastState\n    const castState = castContext()?.getCastState();\n    return castState && castState !== 'NO_DEVICES_AVAILABLE';\n  }\n\n  #onCastStateChanged() {\n    // Cast state: NO_DEVICES_AVAILABLE, NOT_CONNECTED, CONNECTING, CONNECTED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.CastState\n    const castState = castContext().getCastState();\n\n    if (castElementRef.has(this.#media)) {\n      if (castState === 'CONNECTING') {\n        this.#state = 'connecting';\n        this.dispatchEvent(new Event('connecting'));\n      }\n    }\n\n    if (!this.#available && castState?.includes('CONNECT')) {\n      this.#available = true;\n      for (let callback of this.#callbacks) callback(true);\n    }\n    else if (this.#available && (!castState || castState === 'NO_DEVICES_AVAILABLE')) {\n      this.#available = false;\n      for (let callback of this.#callbacks) callback(false);\n    }\n  }\n\n  async #onSessionStateChanged() {\n    // Session states: NO_SESSION, SESSION_STARTING, SESSION_STARTED, SESSION_START_FAILED,\n    //                 SESSION_ENDING, SESSION_ENDED, SESSION_RESUMED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.SessionState\n\n    const { SESSION_RESUMED } = cf.SessionState;\n    if (castContext().getSessionState() === SESSION_RESUMED) {\n      /**\n       * Figure out if this was the video that started the resumed session.\n       * @TODO make this more specific than just checking against the video src!! (WL)\n       *\n       * If this video element can get the same unique id on each browser refresh\n       * it would be possible to pass this unique id w/ `LoadRequest.customData`\n       * and verify against currentMedia().customData below.\n       */\n      if (this.#media.castSrc === currentMedia()?.media.contentId) {\n        castElementRef.add(this.#media);\n\n        Object.entries(this.#remoteListeners).forEach(([event, listener]) => {\n          this.#remotePlayer.controller.addEventListener(event, listener);\n        });\n\n        /**\n         * There is cast framework resume session bug when you refresh the page a few\n         * times the this.#remotePlayer.currentTime will not be in sync with the receiver :(\n         * The below status request syncs it back up.\n         */\n        try {\n          await getMediaStatus(new chrome.cast.media.GetStatusRequest());\n        } catch (error) {\n          console.error(error);\n        }\n\n        // Dispatch the play, playing events manually to sync remote playing state.\n        this.#remoteListeners[cf.RemotePlayerEventType.IS_PAUSED_CHANGED]();\n        this.#remoteListeners[cf.RemotePlayerEventType.PLAYER_STATE_CHANGED]();\n      }\n    }\n  }\n\n  #init() {\n    if (!cf || this.#isInit) return;\n    this.#isInit = true;\n\n    setCastOptions(this.#media.castOptions);\n\n    /**\n     * @TODO add listeners for addtrack, removetrack (WL)\n     * This only has an impact on <track> with a `src` because these have to be\n     * loaded manually in the load() method. This will require a new load() call\n     * for each added/removed track w/ src.\n     */\n    this.#media.textTracks.addEventListener('change', () => this.#updateRemoteTextTrack());\n\n    this.#onCastStateChanged();\n\n    this.#remotePlayer = new cf.RemotePlayer();\n    new cf.RemotePlayerController(this.#remotePlayer);\n\n    this.#remoteListeners = {\n      [cf.RemotePlayerEventType.IS_CONNECTED_CHANGED]: ({ value }) => {\n        if (value === true) {\n          this.#state = 'connected';\n          this.dispatchEvent(new Event('connect'));\n        } else {\n          this.#disconnect();\n          this.#state = 'disconnected';\n          this.dispatchEvent(new Event('disconnect'));\n        }\n      },\n      [cf.RemotePlayerEventType.DURATION_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('durationchange'));\n      },\n      [cf.RemotePlayerEventType.VOLUME_LEVEL_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('volumechange'));\n      },\n      [cf.RemotePlayerEventType.IS_MUTED_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('volumechange'));\n      },\n      [cf.RemotePlayerEventType.CURRENT_TIME_CHANGED]: () => {\n        if (!this.#castPlayer?.isMediaLoaded) return;\n        this.#media.dispatchEvent(new Event('timeupdate'));\n      },\n      [cf.RemotePlayerEventType.VIDEO_INFO_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('resize'));\n      },\n      [cf.RemotePlayerEventType.IS_PAUSED_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event(this.paused ? 'pause' : 'play'));\n      },\n      [cf.RemotePlayerEventType.PLAYER_STATE_CHANGED]: () => {\n        // Player states: IDLE, PLAYING, PAUSED, BUFFERING\n        // https://developers.google.com/cast/docs/reference/web_sender/chrome.cast.media#.PlayerState\n\n        // pause event is handled above.\n        if (this.#castPlayer?.playerState === chrome.cast.media.PlayerState.PAUSED) {\n          return;\n        }\n\n        this.#media.dispatchEvent(\n          new Event(\n            {\n              [chrome.cast.media.PlayerState.PLAYING]: 'playing',\n              [chrome.cast.media.PlayerState.BUFFERING]: 'waiting',\n              [chrome.cast.media.PlayerState.IDLE]: 'emptied',\n            }[this.#castPlayer?.playerState]\n          )\n        );\n      },\n      [cf.RemotePlayerEventType.IS_MEDIA_LOADED_CHANGED]: async () => {\n        if (!this.#castPlayer?.isMediaLoaded) return;\n\n        // mediaInfo is not immediately available due to a bug? wait one tick\n        await Promise.resolve();\n        this.#onRemoteMediaLoaded();\n      },\n    };\n  }\n\n  #onRemoteMediaLoaded() {\n    this.#updateRemoteTextTrack();\n  }\n\n  async #updateRemoteTextTrack() {\n    if (!this.#castPlayer) return;\n\n    // Get the tracks w/ trackId's that have been loaded; manually or via a playlist like a M3U8 or MPD.\n    const remoteTracks = this.#remotePlayer.mediaInfo?.tracks ?? [];\n    const remoteSubtitles = remoteTracks.filter(\n      ({ type }) => type === chrome.cast.media.TrackType.TEXT\n    );\n\n    const localSubtitles = [...this.#media.textTracks].filter(\n      ({ kind }) => kind === 'subtitles' || kind === 'captions'\n    );\n\n    // Create a new array from the local subs w/ the trackId's from the remote subs.\n    const subtitles = remoteSubtitles\n      .map(({ language, name, trackId }) => {\n        // Find the corresponding local text track and assign the trackId.\n        const { mode } =\n          localSubtitles.find(\n            (local) => local.language === language && local.label === name\n          ) ?? {};\n        if (mode) return { mode, trackId };\n        return false;\n      })\n      .filter(Boolean);\n\n    const hiddenSubtitles = subtitles.filter(\n      ({ mode }) => mode !== 'showing'\n    );\n    const hiddenTrackIds = hiddenSubtitles.map(({ trackId }) => trackId);\n    const showingSubtitle = subtitles.find(({ mode }) => mode === 'showing');\n\n    // Note this could also include audio or video tracks, diff against local state.\n    const activeTrackIds =\n      currentSession()?.getSessionObj().media[0]\n        ?.activeTrackIds ?? [];\n    let requestTrackIds = activeTrackIds;\n\n    if (activeTrackIds.length) {\n      // Filter out all local hidden subtitle trackId's.\n      requestTrackIds = requestTrackIds.filter(\n        (id) => !hiddenTrackIds.includes(id)\n      );\n    }\n\n    if (showingSubtitle?.trackId) {\n      requestTrackIds = [...requestTrackIds, showingSubtitle.trackId];\n    }\n\n    // Remove duplicate ids.\n    requestTrackIds = [...new Set(requestTrackIds)];\n\n    const arrayEquals = (a, b) =>\n      a.length === b.length && a.every((a) => b.includes(a));\n    if (!arrayEquals(activeTrackIds, requestTrackIds)) {\n      try {\n        const request = new chrome.cast.media.EditTracksInfoRequest(\n          requestTrackIds\n        );\n        await editTracksInfo(request);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}