{"ast":null,"code":"import { MediaStateReceiverAttributes } from \"../constants.js\";\nfunction namedNodeMapToObject(namedNodeMap) {\n  const obj = {};\n  for (const attr of namedNodeMap) {\n    obj[attr.name] = attr.value;\n  }\n  return obj;\n}\nfunction getMediaController(host) {\n  var _a;\n  return (_a = getAttributeMediaController(host)) != null ? _a : closestComposedNode(host, \"media-controller\");\n}\nfunction getAttributeMediaController(host) {\n  var _a;\n  const {\n    MEDIA_CONTROLLER\n  } = MediaStateReceiverAttributes;\n  const mediaControllerId = host.getAttribute(MEDIA_CONTROLLER);\n  if (mediaControllerId) {\n    return (_a = getDocumentOrShadowRoot(host)) == null ? void 0 : _a.getElementById(mediaControllerId);\n  }\n}\nconst updateIconText = function (svg, value) {\n  let selector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".value\";\n  const node = svg.querySelector(selector);\n  if (!node) return;\n  node.textContent = value;\n};\nconst getAllSlotted = (el, name) => {\n  const slotSelector = `slot[name=\"${name}\"]`;\n  const slot = el.shadowRoot.querySelector(slotSelector);\n  if (!slot) return [];\n  return slot.children;\n};\nconst getSlotted = (el, name) => getAllSlotted(el, name)[0];\nconst containsComposedNode = (rootNode, childNode) => {\n  if (!rootNode || !childNode) return false;\n  if (rootNode == null ? void 0 : rootNode.contains(childNode)) return true;\n  return containsComposedNode(rootNode, childNode.getRootNode().host);\n};\nconst closestComposedNode = (childNode, selector) => {\n  if (!childNode) return null;\n  const closest = childNode.closest(selector);\n  if (closest) return closest;\n  return closestComposedNode(childNode.getRootNode().host, selector);\n};\nfunction getActiveElement() {\n  let root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;\n  var _a;\n  const activeEl = root == null ? void 0 : root.activeElement;\n  if (!activeEl) return null;\n  return (_a = getActiveElement(activeEl.shadowRoot)) != null ? _a : activeEl;\n}\nfunction getDocumentOrShadowRoot(node) {\n  var _a;\n  const rootNode = (_a = node == null ? void 0 : node.getRootNode) == null ? void 0 : _a.call(node);\n  if (rootNode instanceof ShadowRoot || rootNode instanceof Document) {\n    return rootNode;\n  }\n  return null;\n}\nfunction isElementVisible(element) {\n  let {\n    depth = 3,\n    checkOpacity = true,\n    checkVisibilityCSS = true\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (element.checkVisibility) {\n    return element.checkVisibility({\n      checkOpacity,\n      checkVisibilityCSS\n    });\n  }\n  let el = element;\n  while (el && depth > 0) {\n    const style = getComputedStyle(el);\n    if (checkOpacity && style.opacity === \"0\" || checkVisibilityCSS && style.visibility === \"hidden\" || style.display === \"none\") {\n      return false;\n    }\n    el = el.parentElement;\n    depth--;\n  }\n  return true;\n}\nfunction getPointProgressOnLine(x, y, p1, p2) {\n  const dx = p2.x - p1.x;\n  const dy = p2.y - p1.y;\n  const lengthSquared = dx * dx + dy * dy;\n  if (lengthSquared === 0) return 0;\n  const projection = ((x - p1.x) * dx + (y - p1.y) * dy) / lengthSquared;\n  return Math.max(0, Math.min(1, projection));\n}\nfunction distance(p1, p2) {\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n}\nfunction getOrInsertCSSRule(styleParent, selectorText) {\n  const cssRule = getCSSRule(styleParent, st => st === selectorText);\n  if (cssRule) return cssRule;\n  return insertCSSRule(styleParent, selectorText);\n}\nfunction getCSSRule(styleParent, predicate) {\n  var _a, _b;\n  let style;\n  for (style of (_a = styleParent.querySelectorAll(\"style:not([media])\")) != null ? _a : []) {\n    let cssRules;\n    try {\n      cssRules = (_b = style.sheet) == null ? void 0 : _b.cssRules;\n    } catch {\n      continue;\n    }\n    for (const rule of cssRules != null ? cssRules : []) {\n      if (predicate(rule.selectorText)) return rule;\n    }\n  }\n}\nfunction insertCSSRule(styleParent, selectorText) {\n  var _a, _b;\n  const styles = (_a = styleParent.querySelectorAll(\"style:not([media])\")) != null ? _a : [];\n  const style = styles == null ? void 0 : styles[styles.length - 1];\n  if (!(style == null ? void 0 : style.sheet)) {\n    console.warn(\"Media Chrome: No style sheet found on style tag of\", styleParent);\n    return {\n      // @ts-ignore\n      style: {\n        setProperty: () => {},\n        removeProperty: () => \"\",\n        getPropertyValue: () => \"\"\n      }\n    };\n  }\n  style == null ? void 0 : style.sheet.insertRule(`${selectorText}{}`, style.sheet.cssRules.length);\n  return /** @type {CSSStyleRule} */(_b = style.sheet.cssRules) == null ? void 0 : _b[style.sheet.cssRules.length - 1];\n}\nfunction getNumericAttr(el, attrName) {\n  let defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.NaN;\n  const attrVal = el.getAttribute(attrName);\n  return attrVal != null ? +attrVal : defaultValue;\n}\nfunction setNumericAttr(el, attrName, value) {\n  const nextNumericValue = +value;\n  if (value == null || Number.isNaN(nextNumericValue)) {\n    if (el.hasAttribute(attrName)) {\n      el.removeAttribute(attrName);\n    }\n    return;\n  }\n  if (getNumericAttr(el, attrName, void 0) === nextNumericValue) return;\n  el.setAttribute(attrName, `${nextNumericValue}`);\n}\nfunction getBooleanAttr(el, attrName) {\n  return el.hasAttribute(attrName);\n}\nfunction setBooleanAttr(el, attrName, value) {\n  if (value == null) {\n    if (el.hasAttribute(attrName)) {\n      el.removeAttribute(attrName);\n    }\n    return;\n  }\n  if (getBooleanAttr(el, attrName) == value) return;\n  el.toggleAttribute(attrName, value);\n}\nfunction getStringAttr(el, attrName) {\n  let defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var _a;\n  return (_a = el.getAttribute(attrName)) != null ? _a : defaultValue;\n}\nfunction setStringAttr(el, attrName, value) {\n  if (value == null) {\n    if (el.hasAttribute(attrName)) {\n      el.removeAttribute(attrName);\n    }\n    return;\n  }\n  const nextValue = `${value}`;\n  if (getStringAttr(el, attrName, void 0) === nextValue) return;\n  el.setAttribute(attrName, nextValue);\n}\nexport { closestComposedNode, containsComposedNode, distance, getActiveElement, getAllSlotted, getAttributeMediaController, getBooleanAttr, getCSSRule, getDocumentOrShadowRoot, getMediaController, getNumericAttr, getOrInsertCSSRule, getPointProgressOnLine, getSlotted, getStringAttr, insertCSSRule, isElementVisible, namedNodeMapToObject, setBooleanAttr, setNumericAttr, setStringAttr, updateIconText };","map":null,"metadata":{},"sourceType":"module"}